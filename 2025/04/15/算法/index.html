<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>算法 | NJYgocrazy</title><meta name="author" content="NJY"><meta name="copyright" content="NJY"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="算法前言翻笔记的时候发现一不留神写了这么多字，所以想到来汇总一下所有的算法笔记，也算是记录自己的大一吧。 真正的败狗之路也就是在写了这么多笔记后竟然有望得到 0 个奖项。😭😭😭 祝笔试算法全过。 第一章基础算法快速排序与快速选择快排的基本思想是分治 假设有一串左边界为 l 右边界为 r 的数组，用快排对其排序需要三步 1.确定一个数组内的值用来划分数组这个数一般选用 a[l],a[r],a[">
<meta property="og:type" content="article">
<meta property="og:title" content="算法">
<meta property="og:url" content="http://example.com/2025/04/15/%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="NJYgocrazy">
<meta property="og:description" content="算法前言翻笔记的时候发现一不留神写了这么多字，所以想到来汇总一下所有的算法笔记，也算是记录自己的大一吧。 真正的败狗之路也就是在写了这么多笔记后竟然有望得到 0 个奖项。😭😭😭 祝笔试算法全过。 第一章基础算法快速排序与快速选择快排的基本思想是分治 假设有一串左边界为 l 右边界为 r 的数组，用快排对其排序需要三步 1.确定一个数组内的值用来划分数组这个数一般选用 a[l],a[r],a[">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/ava.jpg">
<meta property="article:published_time" content="2025-04-15T03:21:12.959Z">
<meta property="article:modified_time" content="2025-04-15T03:21:12.960Z">
<meta property="article:author" content="NJY">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/ava.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "算法",
  "url": "http://example.com/2025/04/15/%E7%AE%97%E6%B3%95/",
  "image": "http://example.com/img/ava.jpg",
  "datePublished": "2025-04-15T03:21:12.959Z",
  "dateModified": "2025-04-15T03:21:12.960Z",
  "author": [
    {
      "@type": "Person",
      "name": "NJY",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/04/15/%E7%AE%97%E6%B3%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '算法',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/wendang.jpg);"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/ca.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">NJYgocrazy</span></a><a class="nav-page-title" href="/"><span class="site-name">算法</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-04-15T03:21:12.959Z" title="Created 2025-04-15 03:21:12">2025-04-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-04-15T03:21:12.960Z" title="Updated 2025-04-15 03:21:12">2025-04-15</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>翻笔记的时候发现一不留神写了这么多字，所以想到来汇总一下所有的算法笔记，也算是记录自己的大一吧。</p>
<p>真正的败狗之路也就是在写了这么多笔记后竟然有望得到 0 个奖项。😭😭😭</p>
<p>祝笔试算法全过。</p>
<h2 id="第一章基础算法"><a href="#第一章基础算法" class="headerlink" title="第一章基础算法"></a>第一章基础算法</h2><h3 id="快速排序与快速选择"><a href="#快速排序与快速选择" class="headerlink" title="快速排序与快速选择"></a>快速排序与快速选择</h3><p><strong>快排</strong>的基本思想是分治</p>
<p>假设有一串左边界为 l 右边界为 r 的数组，用快排对其排序需要三步</p>
<h4 id="1-确定一个数组内的值用来划分数组"><a href="#1-确定一个数组内的值用来划分数组" class="headerlink" title="1.确定一个数组内的值用来划分数组"></a>1.确定一个数组内的值用来划分数组</h4><p>这个数一般选用 a[l],a[r],a[(l+r)&#x2F;2]这三种（即左边界右边界和中间值）</p>
<h4 id="2-对于原数组进行划分。"><a href="#2-对于原数组进行划分。" class="headerlink" title="2.对于原数组进行划分。"></a>2.对于原数组进行划分。</h4><p>即以某一个位置为界限，该位置左边全都是小于分界值的，右边的数全都是大于分界值的。</p>
<p>在这一步中需要两个指针 i 和 j 分别从左右开始遍历数组。</p>
<p>以 i 从左边开始遍历，j 从右边开始遍历为例。</p>
<p>如果 i 指向的数字小于分界值，则 i 右移一位继续判断；如果 j 指向的数大于分界值，则 j 左移一位继续判断</p>
<p>如果两边都不再执行指针的移动，则说明两边的指针指向的数与需要的条件恰恰相反，故交换这两个数，然后继续判断。</p>
<p>这样的过程保证了 i 指针左侧的值全是小于分界值的，j 指针右侧的指针全是大于分界值的，故而当 ij 指针相遇或者 ij 指针互相穿过的时候，整个数组就完成了排序。</p>
<h4 id="3-对分出的两个区域进行递归处理"><a href="#3-对分出的两个区域进行递归处理" class="headerlink" title="3.对分出的两个区域进行递归处理"></a>3.对分出的两个区域进行递归处理</h4><p>即是对每一个区域再次进行步骤 2 的过程直到最后区域被缩减到一个即完成了排序</p>
<p>给出快排函数的模板</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void quick_sort(int q[],int l,int r)</span><br><span class="line">&#123;</span><br><span class="line">    if(l&gt;=r) return ;</span><br><span class="line">    int x=q[l],i=l-1,j=r+1;//是因为后面用了dowhile循环，是先移动再判断，故两个指针恰好在左右边界的两侧</span><br><span class="line">    while(i&lt;j)</span><br><span class="line">    &#123;</span><br><span class="line">        do i++ ;while (q[i]&lt;x);</span><br><span class="line">        do j-- ;while(q[j]&gt;x);</span><br><span class="line">        //实现左指针左边全小于，右指针右侧全大于</span><br><span class="line">        if(i&lt;j) swap(q[i],q[j]);//如果不再进行指针加减则交换两个数就可以继续了</span><br><span class="line">    &#125;</span><br><span class="line">    当结束这个循环时说明两个指针恰好相遇或者已经穿过，第一次结束</span><br><span class="line">    quick_sort(q,l,j);//从左边界到右指针，即对左部分再次进行排序</span><br><span class="line">    quick_sort(q,j+1,r);//即对右部分再次进行排序</span><br><span class="line">    //根据以上代码可知，j不断向左移动后最终变为左边界-1，此时对于第一个递归l&gt;j，会直接返回</span><br><span class="line">    排序结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-快速选择"><a href="#4-快速选择" class="headerlink" title="4.快速选择"></a>4.快速选择</h4><p><strong>快选</strong>是在快排的基础上进行的，用于从中选出第 k 小（大同理）</p>
<p>根据快排的原理可以看出，每次左分区的数一定都小于右边界的数，故而想要选出第 k 小的数可以通过每个分区的长度去简化排序的次数</p>
<p>比如左边界的长度 l1 大于等于 k，那么 k 一定会在左边界中，故只需要在左边界中进行递归，最终找到这个点数</p>
<p>如果左边界 l1 的长度小于 k，那么 k 一定会在右边界中，故只需要在右边界中进行递归，但需要注意的是，在右边界中，应该是 k-l2 小的数。</p>
<p>需要注意的是，在每一次递归中都需要更新长度。</p>
<p>代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int quick_choice(int l,int r,int k)</span><br><span class="line">&#123;</span><br><span class="line">    if(l==r) return a[l];//最后区间缩小到只含一个数了那么这个数肯定就是答案</span><br><span class="line">   //以下与快排相同</span><br><span class="line">    int x=a[l],i=l-1,j=r+1;</span><br><span class="line">    while(i&lt;j)</span><br><span class="line">    &#123;</span><br><span class="line">        do i++;while (a[i]&lt;x);</span><br><span class="line">        do j--;while (a[j]&gt;x);</span><br><span class="line">        if(i&lt;j) swap(a[i],a[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    int s1=j-l+1;//计算左边界长度</span><br><span class="line"></span><br><span class="line">    //上面已经解释过为什么这么递归了</span><br><span class="line">    if(s1&gt;=k) return quick_choice(l,j,k);</span><br><span class="line">    return quick_choice(j+1,r,k-s1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序的基本思想也是分治，但不同于快排的是分界线就是数组的中间位置</p>
<h4 id="1-基本步骤"><a href="#1-基本步骤" class="headerlink" title="1. 基本步骤"></a>1. 基本步骤</h4><p>1.以中间位置为分界线，将数组分成两部分</p>
<p>2.递归两部分，使这两部分都变成有序序列</p>
<p>3.将这两部分有序序列合并成一个有序数组，从而完成排序</p>
<p>在合并的过程中需要使用双指针算法</p>
<p>即对于两个有序序列，分别设置一个指针指向最左侧（即指向最小的数字）</p>
<p>每次都判断两个指针指向的数字，哪边的数字小就把这个数字写进最终数组，并将这个指针移动，另一个指针依然不动</p>
<p>其中含有一种特殊情况是其中一个数组的指针已经指到了右边界，那么这个时候只需将另一个数组的剩余部分全部写入即可</p>
<p>现给出代码部分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void merge_sort(int a[],int l,int r)</span><br><span class="line">&#123;</span><br><span class="line">    if(l&gt;=r) return ;//一样的，是递归最后一次结束的判断</span><br><span class="line">    int mid=(l+r)/2;//以中间为分界线分割</span><br><span class="line">    merge_sort(a,l,mid); merge_sort(a,mid+1,r);//分别递归左右两部分使其有序</span><br><span class="line">    int k=0,i=l,j=mid+1;//k用于储存临时的答案数组的遍历，i为第一部分的指针，j为第二部分的指针</span><br><span class="line">    while(i&lt;=mid&amp;&amp;j&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[i]&lt;=a[j]) temp[k++]=a[i++];</span><br><span class="line">        else temp[k++]=a[j++];</span><br><span class="line">    &#125;//该段与上面排序原理的解释一致</span><br><span class="line"></span><br><span class="line">    while(i&lt;=mid) temp[k++]=a[i++];</span><br><span class="line">    while(j&lt;=r) temp[k++]=a[j++];//这一段代码使得一部分结束循环后，剩余的数组的部分被全部写入答案</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    for(i=l,j=0;i&lt;=r;i++,j++) a[i]=temp[j];</span><br><span class="line">    //将临时答案里的每个数复制到原数组里去 最后结束这个函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>回归头来进一步地看，其实归并排序中最重要的点还是它归并时候的思路即我们使用双指针去遍历两个数组不断比较指针指向的值使得答案数组有序的过程。</p>
<p>在很多关于两个序列合成一个序列的问题中都可以得到应用。</p>
<h4 id="2-归并排序中求逆序对"><a href="#2-归并排序中求逆序对" class="headerlink" title="2.归并排序中求逆序对"></a>2.归并排序中求逆序对</h4><p>假设一个数组中的每个数都与其位置组成一个二元数对&lt;a[i],i&gt;，那么逆序对的定义即是 a[i]&gt;a[j]&amp;&amp;i&lt;j</p>
<p>可以知道，在归并排序的第三步合并数组时，对两个数组进行指针遍历的过程中，判断大小的过程中恰好可以用来判断逆序对。</p>
<p>在归并的过程中，最小的数字先写入，那么当我们在第一个序列里找到了一个 a[i]&gt;a[j]（第二序列中的一个数）时，先写入 a[j]，那么 a[i]后面的所有数都可以与 a[j]构成一个逆序对（因为两个序列已经是有序的了）</p>
<p>所以我们只需要在归并过程中对大于的情况多加一条计算逆序对的即可</p>
<p>具体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int merge_sort(int a[],int l,int r)</span><br><span class="line">&#123;</span><br><span class="line">    if(l&gt;=r) return 0;</span><br><span class="line"></span><br><span class="line">    int mid=(l+r)/2;</span><br><span class="line">    int re=merge_sort(a,l,mid)+merge_sort(a,mid+1,r);//递归到最后得到所有逆序对对数</span><br><span class="line">    int i=l,j=mid+1,k=0;</span><br><span class="line">    int temp[10000];</span><br><span class="line">    while(i&lt;=mid&amp;&amp;j&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[i]&lt;=a[j]) &#123;</span><br><span class="line">            temp[k++]=a[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            temp[k++]=a[j++];</span><br><span class="line">            re+=mid-i+1;//实现上面解释的逆序对查找方法</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while(i&lt;=mid) temp[k++]=a[i++];</span><br><span class="line">    while(j&lt;=r) temp[k++]=a[j++];</span><br><span class="line">    for(i=l,k=0;i&lt;=r;i++,k++) a[i]=temp[k];//注意虽然这里的目的是求逆序对对数，但每次依然要更新a数组因为要递归得到，所以每一次都要递归到正确的数组</span><br><span class="line">    return re;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h3><p>整数二分法的目的是通过不断二分整数所在的范围从而最后得到整数所在的位置。</p>
<p>二分的原理是以中间值将序列分为两部分，然后通过判断 mid 与条件的关系来逐渐缩小需要判断的范围，使得最后范围缩小到整数所在的位置。（同样地最后返回的值为 l 或 r，因为最后它们相等或差别很小）</p>
<h4 id="1-整数二分"><a href="#1-整数二分" class="headerlink" title="1.整数二分"></a>1.整数二分</h4><p>通过对判断条件的选择，二分法的模板分为两种，以一个例子来看，比如我们需要在一段数组中找到 x 的范围，我们先确定 mid（即中间值），如果 mid&gt;&#x3D;x，那么可知 x 的范围一定在 mid 的左侧，那么就把右边界更新为 mid，x 的范围肯定就在 l 到 mid 之间；反之 mid&lt;x 的话，可知一定在 mid 的右侧，所以将左边界更新为 mid+1，x 的范围肯定就在 mid+1 到 r 之间。</p>
<p>故而两种模板就分别是更新左边界和右边界的问题，根据更新的不同中间值的定义也不同，这一点在下面的代码中详细解释</p>
<p>注意二分法的前提是我们需要写一个判断的条件，现在我们假设这个判断条件是</p>
<p>在使用二分法解题时，首先要确定左右边界，然后最重要的一定是 check 判断条件的选择，要根据题意找出这个条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bool check(int x)</span><br><span class="line">&#123;</span><br><span class="line">    if(x&gt;k) return true;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">//此处的k是需要输入的，即需要判断的数</span><br><span class="line">//即这个数大就为真，小就为假</span><br></pre></td></tr></table></figure>

<h5 id="模板-1"><a href="#模板-1" class="headerlink" title="模板 1"></a>模板 1</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int bsearch1(int l,int r)</span><br><span class="line">&#123;</span><br><span class="line">    while(l&lt;r) &#123;</span><br><span class="line">        int mid = (l + r) / 2;//一定要注意mid的计算一定是要在while循环中进行的，才能每次更新</span><br><span class="line">        if (check(a[mid])) r = mid;//这段即是上面判断的中间值比所找值大，所找值一定在左侧</span><br><span class="line">        else l = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="模板-2"><a href="#模板-2" class="headerlink" title="模板 2"></a>模板 2</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int bsearch(int l,int r)</span><br><span class="line">&#123;</span><br><span class="line">	while(l&lt;r)</span><br><span class="line">	&#123;</span><br><span class="line">		int mid=(l+r+1)/2;</span><br><span class="line">		if(check(a[mid])) l=mid;</span><br><span class="line">		else r=mid-1;</span><br><span class="line">	&#125;</span><br><span class="line">	return l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出来，整数二分的 while 条件是 l&lt;r，即这个序列中还含有元素</p>
<p>现在我们来看浮点数二分，最大的区别是我们需要用 while 条件去判断精度，一般地，题目要求保留几位小数我们就在 while 条件中多加两位，譬如说题目要求精度为两位小数，那么我们可以写 r-l&gt;0.0001</p>
<h4 id="2-浮点二分："><a href="#2-浮点二分：" class="headerlink" title="2.浮点二分："></a>2.浮点二分：</h4><p>同时还要注意的是，浮点二分中不存在复杂的边界问题，所以在更新边界的时候不用考虑加一减一的问题，模板如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">double bsearch(double ans)</span><br><span class="line">&#123;</span><br><span class="line">	while(r-l&lt;”精度的位数加2“)</span><br><span class="line">	&#123;</span><br><span class="line">		double mid=(l+r)/2;</span><br><span class="line">		if(check(mid)) l=mid;</span><br><span class="line">		else r=mid;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;//当然具体怎么换边界还是根据check函数以及题意来确定</span><br></pre></td></tr></table></figure>

<p>现给出一道例题来展示浮点二分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">double a,b,c,d;</span><br><span class="line">double hanshu(double x)</span><br><span class="line">&#123;</span><br><span class="line">    return a*pow(x,3)+b*pow(x,2)+c*x+d;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">    int cnt=0;</span><br><span class="line">    for(int  i=-100;i&lt;=100;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        double l=i;</span><br><span class="line">        double r=i+1;//由于两根的差的绝对值大于等于1，故而每个长度为1的区间至多只有一个根，故基准的左右边界就是遍历的i和i+1</span><br><span class="line">        double x1=hanshu(l);</span><br><span class="line">        double x2=hanshu(r);</span><br><span class="line">        if(x1==0) &#123;</span><br><span class="line">            printf(&quot;%.2f &quot;,l);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(x1*x2&lt;0)//零点存在定理</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            while(r-l&gt;=0.001)//通过while条件来控制二分法的精度</span><br><span class="line">            &#123;</span><br><span class="line">                double  mid=(l+r)/2;</span><br><span class="line">                if(hanshu(mid)*hanshu(l)&lt;0) r=mid;</span><br><span class="line">                else l=mid; //依旧是零点存在定理来更新，但注意这里mid的精度，不用+1，直接使用即可</span><br><span class="line">            &#125;</span><br><span class="line">            printf(&quot;%.2f &quot;,r);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(cnt==3) break;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-二分答案"><a href="#3-二分答案" class="headerlink" title="3.二分答案"></a>3.二分答案</h4><p>二分答案即是用二分的方法枚举取得答案，很像是对二分的逆过程，不断对范围的左边界或右边界进行调整，以逐渐找到最满足要求的答案。</p>
<p>二分答案实际上也是一种枚举，但其使用需要条件，即序列必须是单调的闭区间。</p>
<p>二分答案实际上就是一个求最优解的过程，“最优解一定可行，但可行解不一定最优”，每次满足 check 函数就相当于找到了一个可行解，那么由于序列是有序的，所以知道这个可行解的前面（或后面）一定也都是可行解，从而缩小可行解的范围，最终得到那个最优解。</p>
<p>用一道例题说明问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1000100;</span><br><span class="line">int a[N];</span><br><span class="line">int n,k;</span><br><span class="line"></span><br><span class="line">bool find(long long x)</span><br><span class="line">&#123;</span><br><span class="line">    long long ans=0;</span><br><span class="line">    for(int i=0;i&lt;n;i++) &#123;</span><br><span class="line">        ans+=a[i]/x;</span><br><span class="line">    &#125;</span><br><span class="line">    if(ans&gt;=k) return true;</span><br><span class="line">    else return false;</span><br><span class="line">&#125;</span><br><span class="line">//这里是寻找的更新边界的判断条件，即加和每一根木料可以分割多少个，判断最后的总值是否满足条件</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    long long l=0,r=100000001;//此题的数据范围是木材长度的最大值是100000000，所以不妨设一开始的范围是这个最值加1</span><br><span class="line">    这也是二分找答案的初始步骤，即先找出最大的极限位置</span><br><span class="line">    while(l+1&lt;r)//即题目所说的，如果小于1cm则不切割直接输出0（这也是为什么要定义l为0，这样如果不进入循环的话就不用做一个特判，直接能输出0</span><br><span class="line">    &#123;</span><br><span class="line">        long long mid=(l+r)/2;</span><br><span class="line">        if(find(mid)) l=mid;//如果现在的长度已经大于或等于k了，就尝试能不能让长度再大一些，把起始值改成mid</span><br><span class="line">        else r=mid;//如果现在的长度还小于k，则应该减短长度，把最大值改成mid</span><br><span class="line">    &#125;</span><br><span class="line">    //这里实际上就是不断更新不断尝试直到尝试不动（木块的长度越小就能切割越多块，反之越大块数越少）</span><br><span class="line">    cout&lt;&lt; l &lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然其实二分答案法的最大难度还是在于 check 的寻找，一些经验是顾名思义地去枚举答案，再反过来看这个答案会影响什么，从而反推回去看某一个变量是否与题目限制冲突了。</p>
<h3 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h3><p>高精度是针对特别大的数字之间的加法，数字的长度甚至可能是数字的位数小于等于十的九次方。</p>
<p>注意，高精度的四则运算的基本方法就是<strong>让计算机像人一样去计算</strong>！</p>
<p>由于数字可能特别大，所以我们以字符串的形式读入数字，并将每一位都扣出来储存进数组中，由于在进行高精度的运算时可能会有进位的问题出现，所以我们用动态长度的 vector 去储存</p>
<p>为了方便，正好在这里介绍一下<strong>vector 的用法</strong></p>
<p>vector 是一种容器，区别于普通数组，vector 的区别主要有二，一是可以储存管理不限于数的多种类型的数据，二是它的大小是根据需要实时更新，动态更新的，（因而也有人称其为动态数组），所以用 vector 一遍不会有溢出的风险，在使用中更加的灵活易用</p>
<p>1.vector 的定义</p>
<p>首先需要加上一个头文件 #include <vector></p>
<p>vector&lt;储存的类型&gt;容器名 如 vector<double>v;</p>
<p>同时也可以用 vector 储存数组，如 vector<int>v[n];</p>
<p>2.vector 的常用函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//这些都是必会的成员函数</span><br><span class="line">size()//返回返回容器中元素个数</span><br><span class="line">begin()//返回头部迭代器</span><br><span class="line">end()//返回尾部+1迭代器</span><br><span class="line">rbegin()//返回逆首部迭代器</span><br><span class="line">rend()//返回逆尾部-1迭代器</span><br><span class="line">front()//返回首个元素</span><br><span class="line">back()//返回尾部元素</span><br><span class="line">push_back()//在末尾添加一个元素</span><br><span class="line">emplace_back()//和push_back()是一样的作用</span><br><span class="line">pop_back()//弹出最后一个元素</span><br><span class="line">empty()//判断是否为空</span><br><span class="line">insert()//在指定位置插入元素</span><br><span class="line">erase()//在指定位置删除元素</span><br><span class="line">clear()//清空容器</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>size 函数可以用来判断 vector 的长度，不用单独用变量储存同时还可以适配变化的长度</p>
<p>push_back 函数用来给 vector 加上元素（加在最后）</p>
<p>而其余的函数要用再去查吧</p>
<p>遍历 vector 就用与数组一样的方式即可</p>
<h4 id="1-高精度加法"><a href="#1-高精度加法" class="headerlink" title="1.高精度加法"></a>1.高精度加法</h4><p>​ 一，用数组储存大数，用第一位储存个位数然后依此类推，可以便于在后续进位中直接加一位数（因为 vector 加元素是从最后一位开始的。</p>
<p>​ 二，用竖式加法的原理来<br>计算，即每一位相加，然后再判断是否需要进位，最后放在结果位的是加和对 10 取的模，然后进位是加和结果&#x2F;10</p>
<p>所以我们需要三个 vector，分别是第一个数，第二个数，和最终的结果，同时还需要一个变量 t 来记录每次的进位</p>
<p>现在看代码模板</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">//add函数表示c=a+b</span><br><span class="line">vector&lt;int&gt;add(vector&lt;int&gt; &amp;a,vector&lt;int&gt; &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; c;</span><br><span class="line">    int t=0;</span><br><span class="line">    for(int i=0;i&lt;a.size()||i&lt;b.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(i&lt;a.size()) t+=a[i];</span><br><span class="line">        if(i&lt;b.size()) t+=b[i];</span><br><span class="line">        c.push_back(t%10);//取模结果</span><br><span class="line">        t/=10;//记录进位</span><br><span class="line">    &#125;</span><br><span class="line">    if(t!=0) c.push_back(1);//如果最后一位还有进位，就在前面加1</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;//大数用字符串读入</span><br><span class="line">    vector&lt;int&gt;m,n;</span><br><span class="line">    for(int i=a.size()-1;i&gt;=0;i--) m.push_back(a[i]-&#x27;0&#x27;);</span><br><span class="line">    for(int i=b.size()-1;i&gt;=0;i--) n.push_back(b[i]-&#x27;0&#x27;);//逆遍历储存进vector</span><br><span class="line"></span><br><span class="line">    auto c=add(m,n); //auto变量编译器会自动推导属于哪种变量</span><br><span class="line"></span><br><span class="line">    for(int i=c.size()-1;i&gt;=0;i--) cout&lt;&lt;c[i];//逆遍历输出</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-高精度减法"><a href="#2-高精度减法" class="headerlink" title="2.高精度减法"></a>2.高精度减法</h4><p>一，高精度减法的大数储存方式与加法完全相同（可以确保在进行复合运算时的一致性）</p>
<p>二，一样是采用竖式相减，需要注意的就是不够借 1 的问题，那么实际上我们只需要用一个变量来记录借的这个数，在每次相减的时候都减去这个数即可</p>
<p>另外，在相减的过程中，由于可能借 1 可能不借 1（可能够减可能不够减），所以我们用一种写法来统一这两种情况，即(t+10)%10</p>
<p>可以进行一些模拟计算来验证可以发现是全面的</p>
<p>还需要注意的一点是减法中我们需要考虑减数与被减数之间的大小关系，从而来判断最后的结果要不要加负号</p>
<p>现在直接来看代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">bool cmp(vector&lt;int&gt; &amp;a,vector&lt;int&gt; &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">     if(a.size()!=b.size()) return a.size() &gt; b.size(); //如果位数不同就比较位数</span><br><span class="line">     for(int i=a.size();i&gt;=0;i--)</span><br><span class="line">     &#123;</span><br><span class="line">         if(a[i]!=b[i]) return a[i]&gt;b[i]; //如果位数相同，就从最高位开始比起</span><br><span class="line">     &#125;</span><br><span class="line">     return true;</span><br><span class="line">&#125;</span><br><span class="line">//return 后加的条件意为如果这个条件为真则返回true</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; sub(vector &lt;int&gt; &amp;a,vector&lt;int&gt; &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; c;</span><br><span class="line">    for(int i=0,t=0;i&lt;a.size();i++) //t为借的位数</span><br><span class="line">    &#123;</span><br><span class="line">        t = a[i] - t; //首先要减去借位</span><br><span class="line">        if(i&lt;b.size()) t -= b[i];//如果b还有位数则还要减去b的那一位数</span><br><span class="line">        c.push_back((t+10)%10);  //这一步就是综合了数借1与否的情况</span><br><span class="line">        if(t&lt;0) t=1;	//如果t小于0说明是借了位的，所以下一位要减一</span><br><span class="line">        else t=0; //没有借位</span><br><span class="line">    &#125;</span><br><span class="line">    while(c.size()&gt;1 &amp;&amp; c.back() == 0) c.pop_back(); //去掉前导0，让最后的输出结果为数字的形式</span><br><span class="line">    //如果c的长度只有一位且为0那么就不能去掉</span><br><span class="line">    //因为vector中加入的数都在最后面，所以去掉数前面的0应该是从最后一位看起,pop_back用于弹出最后一位数即去掉它，以此可以把数字前所有0去掉</span><br><span class="line">    return  c;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> int main()</span><br><span class="line"> &#123;</span><br><span class="line">    string m,n;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    vector&lt;int&gt;a,b;</span><br><span class="line">    for(int i = m.length()-1;i&gt;=0;i--) a.push_back(m[i]-&#x27;0&#x27;);</span><br><span class="line">    for(int i = n.length()-1;i&gt;=0;i--) b.push_back(n[i]-&#x27;0&#x27;);</span><br><span class="line">    if(cmp(a,b)) &#123;</span><br><span class="line">        auto c=sub(a,b);</span><br><span class="line">        for(int i=c.size()-1;i&gt;=0;i--) printf(&quot;%d&quot;,c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        auto c=sub(b,a);</span><br><span class="line">        cout &lt;&lt; &quot;-&quot;;//如果a&lt;b的话，就算b-a并且在前面加上一个负号</span><br><span class="line">        for(int i=c.size()-1;i&gt;=0;i--) printf(&quot;%d&quot;,c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-高精度乘法"><a href="#3-高精度乘法" class="headerlink" title="3.高精度乘法"></a>3.高精度乘法</h4><p>这里讨论的是一个高精度的特别大的数去乘以一个相对小的数（可以用 int 存下），基本思路是大数的每一位都乘以这个小数，然后放在该位的数是这个乘积被 10 取模的过程，而进位的则是这个乘积除以 10 的结果</p>
<p>代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; mul(vector&lt;int&gt; &amp;a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; c;</span><br><span class="line">    int t=0;</span><br><span class="line">    for(int i=0;i&lt;a.size()||t;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(i&lt;a.size()) t+=a[i]*b;</span><br><span class="line">        c.push_back(t%10);</span><br><span class="line">        t/=10;</span><br><span class="line">    &#125;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line">//可以看出来跟加法的模板挺像的 是不是可以说乘法跟加法是同源的？？</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string m; int b;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; b;</span><br><span class="line">    vector&lt;int&gt;  a;</span><br><span class="line">    for(int i=m.length()-1;i&gt;=0;i--) a.push_back(m[i]-&#x27;0&#x27;);</span><br><span class="line">    auto  c=mul(a,b);</span><br><span class="line">    for(int i=c.size()-1;i&gt;=0;i--) cout&lt;&lt;c[i];</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="大数-×-大数的高精度乘法"><a href="#大数-×-大数的高精度乘法" class="headerlink" title="大数 × 大数的高精度乘法"></a>大数 × 大数的高精度乘法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn=1e6+7;</span><br><span class="line">char a1[maxn],b1[maxn];</span><br><span class="line">int a[maxn],b[maxn],c[maxn*10],lena,lenb,lenc,x;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%s&quot;,a1);</span><br><span class="line">    scanf(&quot;%s&quot;,b1);</span><br><span class="line">    lena=strlen(a1);</span><br><span class="line">    lenb=strlen(b1);</span><br><span class="line">    for(int i=0;i&lt;lena;i++)a[lena-i]=a1[i]-&#x27;0&#x27;;</span><br><span class="line">    for(int i=0;i&lt;lenb;i++)b[lenb-i]=b1[i]-&#x27;0&#x27;;</span><br><span class="line">    for(int i=1;i&lt;=lena;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        x=0;</span><br><span class="line">        for(int j=1;j&lt;=lenb;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            c[i+j-1]=a[i]*b[j]+x+c[i+j-1];</span><br><span class="line">            x=c[i+j-1]/10;</span><br><span class="line">            c[i+j-1]%=10;</span><br><span class="line">        &#125;</span><br><span class="line">        c[i+lenb]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    lenc=lena+lenb;</span><br><span class="line">    while(c[lenc]==0&amp;&amp;lenc&gt;1) lenc--;</span><br><span class="line">    for(int i=lenc;i&gt;=1;i--) cout&lt;&lt;c[i];</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化<br>for (int i &#x3D; 1; i &lt;&#x3D; lena; i++) {：外层循环遍历第一个整数 a 的每一位，从最低有效位（个位）开始，直到最高有效位。<br>x &#x3D; 0;：每次内层循环开始时，将进位 x 重置为 0。<br>内层循环<br>for (int j &#x3D; 1; j &lt;&#x3D; lenb; j++) {：内层循环遍历第二个整数 b 的每一位，同样从最低有效位开始。<br>c[i + j - 1] &#x3D; a[i] _ b[j] + x + c[i + j - 1];：计算当前位的乘积 a[i] _ b[j]，加上之前的进位 x 和已经存在的 c[i + j - 1] 的值。这是因为高精度乘法的结果可能跨越多个位，需要累加之前的结果。<br>x &#x3D; c[i + j - 1] &#x2F; 10;：计算新的进位。如果 c[i + j - 1] 大于或等于 10，那么需要将十位以上的部分进位到更高一位。<br>c[i + j - 1] %&#x3D; 10;：更新当前位，只保留个位上的数字。<br>处理最后的进位<br>c[i + lenb] &#x3D; x;：在内层循环结束后，如果还有进位 x，则将其添加到 c 数组的下一个位置。<br>示例<br>假设 a &#x3D; 123 和 b &#x3D; 89，那么 lena &#x3D; 3 和 lenb &#x3D; ⅔。我们用数组表示这两个数，从最低有效位开始：</p>
<p>a 数组: [3, 2, 1]<br>b 数组: [9, 8]<br>乘法过程如下：</p>
<p>对于 a[1]（即 3）：<br>c[1 + 1 - 1] &#x3D; 3 _ 9 + 0 + 0 &#x3D; 27，x &#x3D; 27 &#x2F; 10 &#x3D; 2，c[1] &#x3D; 27 % 10 &#x3D; 7<br>c[1 + 2 - 1] &#x3D; ¾ _ 8 + 2 + 0 &#x3D; 26，x &#x3D; 26 &#x2F; 10 &#x3D; 2，c[2] &#x3D; 26 % 10 &#x3D; 6<br>c[1 + 2] &#x3D; 2（处理最后的进位）<br>对于 a[2]（即 2）：<br>c[2 + 1 - 1] &#x3D; 2 _ 9 + 0 + 7 &#x3D; 25，x &#x3D; 25 &#x2F; 10 &#x3D; 2，c[2] &#x3D; 25 % 10 &#x3D; 5<br>c[2 + 2 - 1] &#x3D; 2 _ 8 + 2 + 6 &#x3D; 24，x &#x3D; 24 &#x2F; 10 &#x3D; 2，c[3] &#x3D; 24 % 10 &#x3D; 4<br>c[2 + 2] &#x3D; 2（处理最后的进位）<br>对于 a[3]（即 1）：<br>c[3 + 1 - 1] &#x3D; 1 _ 9 + 0 + 5 &#x3D; 14，x &#x3D; 14 &#x2F; 10 &#x3D; 1，c[3] &#x3D; 14 % 10 &#x3D; 4<br>c[3 + 2 - 1] &#x3D; 1 _ 8 + 1 + 4 &#x3D; 13，x &#x3D; 13 &#x2F; 10 &#x3D; 1，c[4] &#x3D; 13 % 10 &#x3D; 3<br>c[3 + 2] &#x3D; 1（处理最后的进位）<br>最终，c 数组为 [7, 6, 4, 3, 1]，倒序输出就是 10947，这是 123 * 89 的结果。</p>
<p>总结<br>这段代码通过模拟手工乘法的方式，逐步计算每一位的结果，并处理进位，最终得到高精度的乘法结果</p>
<h4 id="4-高精度除法"><a href="#4-高精度除法" class="headerlink" title="4.高精度除法"></a>4.高精度除法</h4><p>与乘法类似的，这里讨论的高精度除法中，被除数是高精度的大数，而除数是一个相对小的数，同样可以用 int 去除</p>
<p>还需要说明的是，这里的除法还是整数除法，在此种我们输出商和余数</p>
<p>直接看代码吧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; div(vector&lt;int&gt; &amp;a,int b,int &amp;r)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; c;</span><br><span class="line">    for(int i=a.size()-1;i&gt;=0;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        r=r*10+a[i];</span><br><span class="line">        c.push_back(r/b);</span><br><span class="line">        r=r%b;</span><br><span class="line">    &#125;</span><br><span class="line">    //这一段直接自己拿两个数字模拟一下就可以理解了</span><br><span class="line">    reverse(c.begin(),c.end());//在上面的运行过程中，对于c储存的数，高位的数是储存在第一位的，与高精度运算中储存大数的方式相反，故而我们用reverse将其翻转，以达到统一</span><br><span class="line">    while(c.size()&gt;1 &amp;&amp; c.back()==0) c.pop_back();//去掉前导0</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string m; int b;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; b;</span><br><span class="line">    vector&lt;int&gt;  a;</span><br><span class="line">    for(int i=m.length()-1;i&gt;=0;i--) a.push_back(m[i]-&#x27;0&#x27;);</span><br><span class="line">    int r=0;</span><br><span class="line">    auto  c=div(a,b,r); //这个函数返回的是c，但是也会改变r</span><br><span class="line">    for(int i=c.size()-1;i&gt;=0;i--) cout&lt;&lt;c[i];</span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;r;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>高精度的四则运算就大概如此，需要注意的就是让计算机像人一样处理数据的一种思想，同时要多熟练和理解这几个模板</p>
<h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><h4 id="1-一维前缀和"><a href="#1-一维前缀和" class="headerlink" title="1.一维前缀和"></a>1.<strong>一维前缀和</strong></h4><p>首先我们定义一个数组 a1,a2,a3,…,an，对于这个数组，有对应的前缀和数组 s0,s1,s2,s3,…,sn，其中 sn&#x3D;a1+a2+…+an；</p>
<p>即前 n 个数的和即是 sn</p>
<p>需要注意的是，前缀和对应的数组的下标志必须是从 1 开始数的，且 s0 是自定义的其为 0</p>
<p>前缀和的<strong>求法</strong></p>
<p>​ 一般的，对于 si，si&#x3D;s[i-1]+a[i] （不得不说，就是数列的前 n 项和那一套东西啊）</p>
<p>前缀和的<strong>应用</strong>，</p>
<p>​ 前缀和一般用于快速地得到某一个区间的和 <strong>对于[l,r]的区间和，用 s[r]-s[l-1]求得</strong></p>
<p>这也就解释了为什么数组的下标要从 1 开始，并且需要我们自己去定义 s0&#x3D;0，因为当我们求[1,10]的和时，实际上就是 s10，但为了符合一般规律公式，我们应该写成 s[10]-s[0]，其中 s[o]&#x3D;0，即就为 s10</p>
<p>对前缀和数组的预处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s[0]=0;</span><br><span class="line">for(int i=1;i&lt;=n;i++) s[i]=s[i-1]+a[i];</span><br></pre></td></tr></table></figure>

<p>一维的前缀和十分简单就略过例题吧</p>
<h4 id="2-二维前缀和"><a href="#2-二维前缀和" class="headerlink" title="2.二维前缀和"></a>2.<strong>二维前缀和</strong></h4><p>二维前缀和实际上是在矩阵中求子矩阵的和 对于一个行列都从 1 开始的二维数组 a[i,j]，对应地有 s[i,j]来表示子矩阵的和</p>
<p><img src="C:\Users\Lenovo\Desktop\笔记\第一章基础算法.assets\image-20241030210410949.png" alt="image-20241030210410949"></p>
<p>例如，如图是 s[3,3]所表示的范围，就是所有被标黄的方格内的数字的和，所以可以看出 s[i,j]就是以 11 为左上角，ij 为右下角的矩形</p>
<p>由于矩阵之间可能互相重叠，所以存在多加和多减的问题，需要就情况进行加减</p>
<p><strong>计算前缀和数组</strong></p>
<p><strong><em>s[i,j]&#x3D;s[i-1,j]+s[i,j-1]-s[i-1,j-1]+a[i,j]</em></strong></p>
<p><strong>计算(x1,y1)(x2,y2)这一子矩阵中所有和的值</strong></p>
<p><strong><em>s[x2,y2]-s[x-1,y2]-s[x2,y1-1]+s[x1-1,y1-1]</em></strong></p>
<p>可以画图动态地理解一下，这里太麻烦了就不画了</p>
<h3 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h3><p>差分其实就是前缀和的逆运算</p>
<h4 id="1-一维差分"><a href="#1-一维差分" class="headerlink" title="1.一维差分"></a>1.<strong>一维差分</strong></h4><p>假设有两个数组分别是 a1,a2,a3,…,an 和 b1,b2,b3,…bn，使得 ai&#x3D;b1+b2+b3+…+bi</p>
<p>则称 a 数组是 b 数组的前缀和，b 数组是 a 数组的差分</p>
<h5 id="差分的应用"><a href="#差分的应用" class="headerlink" title="差分的应用"></a>差分的<strong>应用</strong></h5><p>差分可以运用在需要对 a 数组中的一段数同时进行加减操作，比如我们要对 a 数组的 l 到 r 都加上一个 c</p>
<p>由于 a 数组是 b 数组的前缀和，所以，如果我们让 b[l]+c 就会让 a[l]到 a[n]的所有数都加上 c（因为这个阶段的数实际上都加了这个 b[l]），那么为了保证 r 之后的数没有加 c，同理只需要再进行一个操作，即 b[r+1]-c,使得 r+1 到 n 的数最终没有发生变化。</p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void insert(int l,int r,int c)</span><br><span class="line">&#123;</span><br><span class="line">	b[l]+=c;</span><br><span class="line">	b[r+1]-=c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="差分数组的构造"><a href="#差分数组的构造" class="headerlink" title="差分数组的构造"></a>差分数组的<strong>构造</strong></h5><p>在差分中我们不用去考虑具体是怎么构造的，因为我们如果假设 a 数组全部为 0，那么对应的 b 数组也全为 0，当 a 数组的每一位 i 的值发生变化时，就相当于在 i 与 i 之间插入了一个值，所以构造差分数组的方法就是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(int i=1;i&lt;=n;i++) insert(i,i,a[i]);</span><br></pre></td></tr></table></figure>

<p>好不容易弄懂了，啰嗦两句，为什么这样插入就能够构造出差分数组呢</p>
<p>因为实际上差分数组的构造是 b[i]&#x3D;a[i]-[i-1]，相当于对于每一个位数来说都加了一次减了一次，而这个 insert 函数中恰好就是一个先加后减的过程，因为左右边界是一样的，所以这次的 r+1 就会变成下一次的 l，同时插入的数又发生了改变，所以这个过程会完全等价于 b[i]&#x3D;a[i]-[i-1]</p>
<p>在这里补充一点，如何使差分数组变成它对应的前缀和数组，只需要</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(int i=1;i&lt;=n;i++) b[i]+=b[i-1];</span><br></pre></td></tr></table></figure>

<p>当然啦，也可以继续用 a 数组去计算，用前缀和的公式即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(int i=1;i&lt;=n;i++) a[i]=a[i-1]+b[i];</span><br></pre></td></tr></table></figure>

<h4 id="2-二维差分"><a href="#2-二维差分" class="headerlink" title="2.二维差分"></a>2.<strong>二维差分</strong></h4><p>同样的，有两个二维数组即两个矩阵，使得 a 矩阵是 b 矩阵的前缀和矩阵，那么 b 矩阵则是 a 矩阵的差分矩阵</p>
<p>可以与二维前缀和类比，其实就是同样的把运算变成整个矩阵的运算，所以不解释太多</p>
<h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a><strong>应用</strong></h5><p>对于差分矩阵中的 b[i,j]+c 就相当于把 a[[i,j]为左上角的那个矩阵全部加 c，与前缀和一维到二维的转化方式是相同的，不赘述了</p>
<p>让前缀和数组中以 x1，y1 为左上角，x2，y2 为右下角的矩阵中的所有数加上 c</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void insert(int x1,int y1,int x2,int y2,int c)</span><br><span class="line">&#123;</span><br><span class="line">	b[x1,y1]+=c;</span><br><span class="line">	b[x1,y2+1]-=c;</span><br><span class="line">	b[x2+1,y1]-=c;</span><br><span class="line">	b[x2+1,y2+1]+=c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="构造"><a href="#构造" class="headerlink" title="构造"></a><strong>构造</strong></h5><p>同样进行 n，m 次插入操作即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(int i =  1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">	for(int j=1;j&lt;=m;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		insert(i,j,i,j,c);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后计算前缀和数组某点矩阵的和的形式与前面的前缀和数组中方法完全相同，略过</p>
<h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><p>首先清楚什么是离散化，离散化是指将一个连续的区间转化为一系列离散的点的过程</p>
<p>可以理解为一种思想，即我们在处理大量的连续的区间内的问题时，很多时候其实只有其中的一些点是需要的，那么这时我们就可以把这个连续的区间问题转化为求这些点的问题</p>
<p>那么我们如何处理这些离散的点就是此算法的关键，我们的想法是把这些离散的点（或这些点的坐标）映射成从 1 到 n 的有序的区间，从而在这个更小更简单的区间里去分析问题，同时由于其有序性也就可以在这个区间里使用遍历去解决问题</p>
<p>但需要注意的是，映射的过程中，待离散化的元素是可能重复的，比如进行操作的和区间的点重复了，所以每次还需要对这些离散的点进行去重，从而使得映射的值是唯一的。</p>
<p>然后来讨论如何求这个映射的问题，这里的映射实际就是找这些点在区间内的位置，所以可以用二分查找的方法去找到每一个值对应的点的位置</p>
<h4 id="区间和"><a href="#区间和" class="headerlink" title="区间和"></a>区间和</h4><p><img src="C:\Users\Lenovo\Desktop\笔记\第一章基础算法.assets\image-20241105101301168.png" alt="image-20241105101301168"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">typedef pair&lt;int,int&gt; pa; //自定义 pair对 的名称，</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; all;//储存所有需要离散化的值</span><br><span class="line">vector&lt;pa&gt; add,qiu;//储存每次进行的操作，和每一次访问需要求的区间</span><br><span class="line"></span><br><span class="line">const int N = 300010;</span><br><span class="line">int n,m;</span><br><span class="line">int a[N],s[N];</span><br><span class="line">//用于找出需要离散的值的映射</span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">    int l = 0,r = all.size()-1;</span><br><span class="line">    while(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid = l + r &gt;&gt; 1;</span><br><span class="line">        if(all[mid] &gt;= x)  r = mid;</span><br><span class="line">        else l = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return r+1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">//完成读入操作</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for(int i = 0 ; i &lt; n ;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        int x, c;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; c;</span><br><span class="line">        add.push_back(&#123;x,c&#125;);</span><br><span class="line">        all.push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 0 ; i &lt; m ; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        int l,r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        qiu.push_back(&#123;l,r&#125;);</span><br><span class="line">        all.push_back(l);</span><br><span class="line">        all.push_back(r);</span><br><span class="line">    &#125;</span><br><span class="line">//</span><br><span class="line">    sort(all.begin(),all.end());</span><br><span class="line">    all.erase(unique(all.begin(),all.end()),all.end());</span><br><span class="line"></span><br><span class="line">    for(auto item:add)</span><br><span class="line">    &#123;</span><br><span class="line">        int x = find(item.first);</span><br><span class="line">        a[x]+=item.second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i = 1;i &lt;= all.size() ; i ++) s[i]=s[i-1]+a[i];</span><br><span class="line"></span><br><span class="line">    for(auto item : qiu)</span><br><span class="line">    &#123;</span><br><span class="line">        int l = find(item.first);int r = find(item.second);</span><br><span class="line">        cout &lt;&lt; s[r] - s[l-1] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h4><p>区间和并实际上就是一个求并集的过程</p>
<p>即每次当两个区间有交集的时候我们就对这两个区间取并集，把右边界更新成较大的那个</p>
<p><img src="C:\Users\Lenovo\Desktop\笔记\第一章基础算法.assets\image-20241109181504217.png" alt="image-20241109181504217"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef pair&lt;int, int&gt; pp;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">const int N = 400020;  // 这里不需要这么大的常量，可以根据实际情况调整</span><br><span class="line">vector&lt;pp&gt; all;</span><br><span class="line"></span><br><span class="line">// 合并重叠区间</span><br><span class="line">void merge(vector&lt;pp&gt; &amp;all) &#123;</span><br><span class="line">    if (all.empty()) return;</span><br><span class="line"></span><br><span class="line">    // 首先按起点排序</span><br><span class="line">    sort(all.begin(), all.end());</span><br><span class="line"></span><br><span class="line">    vector&lt;pp&gt; res;</span><br><span class="line">    int l = all[0].first, r = all[0].second;</span><br><span class="line"></span><br><span class="line">    for (size_t i = 1; i &lt; all.size(); ++i) &#123;</span><br><span class="line">        if (all[i].first &lt;= r) &#123;</span><br><span class="line">            // 当前区间与之前的区间重叠，更新右端点</span><br><span class="line">            r = max(r, all[i].second);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 当前区间与之前的区间不重叠，将之前的区间加入结果</span><br><span class="line">            res.push_back(&#123;l, r&#125;);</span><br><span class="line">            l = all[i].first;</span><br><span class="line">            r = all[i].second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 加入最后一个区间</span><br><span class="line">    res.push_back(&#123;l, r&#125;);</span><br><span class="line"></span><br><span class="line">    all = res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        int q, p;</span><br><span class="line">        cin &gt;&gt; q &gt;&gt; p;</span><br><span class="line">        all.push_back(&#123;q, p&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 合并重叠区间</span><br><span class="line">    merge(all);</span><br><span class="line"></span><br><span class="line">    // 计算所有燃烧位置的总长度</span><br><span class="line">    int total_length = 0;</span><br><span class="line">    for (const auto &amp;interval : all) &#123;</span><br><span class="line">        total_length += interval.second - interval.first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 输出总长度</span><br><span class="line">    cout &lt;&lt; total_length &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然有些时候我们合并区间后还会添加前缀和等使用，视情况而定即可</p>
<h2 id="第二章数据结构"><a href="#第二章数据结构" class="headerlink" title="第二章数据结构"></a>第二章数据结构</h2><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p>栈和队列都是一种容器。其不同点在于存放的顺序和取用顺序的不同</p>
<p><img src="/%E7%AE%97%E6%B3%95.assets/image-20241112112018641.png" alt="image-20241112112018641"></p>
<p>栈如图 1，其元素只能从上口取出，所以先进去的元素会在最后才出来</p>
<p>队列如图 2，其元素是从下端掉出的，所以先进去的元素会最先掉出来</p>
<p><strong>用数组模拟栈和队列</strong></p>
<h3 id="1-栈"><a href="#1-栈" class="headerlink" title="1.栈"></a><em>1.栈</em></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//栈的定义</span><br><span class="line">int skt[N];//数组定义栈    int tt; //tt充当记录栈底的指针</span><br><span class="line">//往栈中插入元素</span><br><span class="line">skt[++tt] = x;      //因为元素是从下面涨到上面的</span><br><span class="line">//弹出元素</span><br><span class="line">tt --;</span><br><span class="line">//判断栈是否为空</span><br><span class="line">if(tt&gt;0) not empty</span><br><span class="line">else empty            //即当栈顶还存在时就不为空</span><br><span class="line">//栈顶</span><br><span class="line">skt[tt];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/%E7%AE%97%E6%B3%95.assets/image-20241112164657033.png" alt="image-20241112164657033"></p>
<h3 id="2-队列"><a href="#2-队列" class="headerlink" title="2.队列"></a><em>2.队列</em></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//队列的定义</span><br><span class="line">int q[N]//数组定义队列      int hh,tt//分别表示头和尾，（就是习惯定义上的上和下哦，结合上面的图）,注意队列实在队尾插入其元素，在队头弹出元素</span><br><span class="line">//插入</span><br><span class="line">qq[++tt] = x //队尾，故而指针向下变大</span><br><span class="line">//弹出元素</span><br><span class="line">hh++  //指针右移，前面的元素就被弹出</span><br><span class="line">//判断队列是否为空</span><br><span class="line">if(hh&lt;=tt) not empty</span><br><span class="line">else empty</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/%E7%AE%97%E6%B3%95.assets/image-20241112164440317.png" alt="image-20241112164440317"></p>
<h3 id="3-使用场景的总结"><a href="#3-使用场景的总结" class="headerlink" title="3.使用场景的总结"></a>3.使用场景的总结</h3><p><strong><em>如何在题目背景中抽离出栈和队列的背景？</em></strong></p>
<p>​ 着重关注题目中元素的剔除方式：如果是先进先出则用队列储存，如果先进后出则用栈储存。</p>
<h3 id="4-单调栈和单调队列"><a href="#4-单调栈和单调队列" class="headerlink" title="4.单调栈和单调队列"></a><strong>4.单调栈和单调队列</strong></h3><h4 id="1-单调栈"><a href="#1-单调栈" class="headerlink" title="1.单调栈"></a><em>1.单调栈</em></h4><p>单调栈适用的模型是求出数轴上左侧小于 x 且离 x 最近的数（右侧同理），<img src="/%E7%AE%97%E6%B3%95.assets/image-20241113154629298.png" alt="image-20241113154629298"></p>
<p>栈元素从顶端弹出，所以我们每次判断顶元素是否大于 x，如果大于 x 就直接弹出，这样可以简便地使整个栈中地元素都是单调递增的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 100020;</span><br><span class="line">int skt[N], tt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for (int i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        while (tt != 0 &amp;&amp; skt[tt] &gt;= x)</span><br><span class="line">            tt--;</span><br><span class="line">        if (tt != 0)</span><br><span class="line">            cout &lt;&lt; skt[tt] &lt;&lt; &quot; &quot;;</span><br><span class="line">        else</span><br><span class="line">            cout &lt;&lt; -1 &lt;&lt; &quot; &quot;;</span><br><span class="line">        skt[++tt] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-单调队列"><a href="#2-单调队列" class="headerlink" title="2.单调队列"></a><em>2.单调队列</em></h4><p><img src="/%E7%AE%97%E6%B3%95.assets/Pig.png"></p>
<h2 id="Trie-树"><a href="#Trie-树" class="headerlink" title="Trie 树"></a>Trie 树</h2><p>Trie 树是一种高效存储和查找字符串集合的数据结构，其用类似树枝的方式来储存字符串元素，即每一个节点后可能有若干个子节点，（最初的一个节点称为根节点），最后每一条路径就代表一个储存的字符串，同时，对于每一个字符串结束的节点可以做一个标记方便进行查询操作</p>
<p>大概的图示如下</p>
<p><img src="/%E7%AE%97%E6%B3%95.assets/image-20241118102053450.png" alt="image-20241118102053450"></p>
<p>一道应用的例题，维护一个字符串集合，支持插入字符串 x 和查询字符串出现次数的操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//对于一个字母组成的字符串，可以考虑将字母a~z映射成数字的0~25</span><br><span class="line">//我们用p来记录当前节点，son数组来记录这个节点上的元素，idx用来记录当前使用的下标，下标是0的点既是根节点又是空节点</span><br><span class="line">const int N = 100010;</span><br><span class="line">int son[N][26], cnt[N], idx;</span><br><span class="line"></span><br><span class="line">//插入操作</span><br><span class="line">void insert(char str[])</span><br><span class="line">&#123;</span><br><span class="line">    int p = 0;//从根节点开始</span><br><span class="line">    for (int i = 0; str[i];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int u = str[i] - &#x27;a&#x27;;//映射过程</span><br><span class="line">        if(!son[p][u])//如果不存在这个子节点</span><br><span class="line">            son[p][u] = ++idx;//那么就创造一个子节点，++idx让它有儿子</span><br><span class="line">        p = son[p][u];//遍历到下一个字母节点的下标去</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]++;//最后结束循环时的终点就是出现了一次，打上一个标记</span><br><span class="line">&#125;</span><br><span class="line">//查询操作</span><br><span class="line">int  query(char str[])</span><br><span class="line">&#123;</span><br><span class="line">    int p = 0;</span><br><span class="line">    for (int i = 0; str[i];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int u = str[i] - &#x27;a&#x27;;</span><br><span class="line">        if(!son[p][u])</span><br><span class="line">            return 0;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这里可以看出 trie 树高效的原因在于其让前缀相同的字符串共用前缀从而提高了效率</p>
<p>在这里介绍一个有意思的地方，根据树的性质会发现它在储存二进制数字时有优势（相当于只由 01 构成的字符串）所以从某种程度上来讲，树能够用来储存计算机中的一切信息</p>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>trie 树的另一个重要的操作是并查集，即两种操作，一是将编号为 a 和 b 的两个数所在的集合合并到有个集合中，二是查询编号为 a，b 的两个数是否在同一个集合中</p>
<p><img src="/%E7%AE%97%E6%B3%95.assets/image-20241118171513171.png" alt="image-20241118171513171"></p>
<p><strong>问题 4：针对问题 2 的路径压缩优化 ：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">	if(p[x]!=x) p[x] = find(p[x]);</span><br><span class="line">	return p[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上可以看出树中元素的关系是相互的，对于任意一个元素，我们既可以去寻找它的子节点也可以寻找它的父节点，区别是一个是创造路径，一个是对已有的树集合进行查找。–&gt;<em>见并查集操作</em></p>
<p>trie 树可以用来作为集合来便于研究，一般地我们用根节点来做它的编号–&gt;<em>见合并集合</em></p>
<h3 id="种类并查集"><a href="#种类并查集" class="headerlink" title="种类并查集"></a>种类并查集</h3><p>当题目中的元素之间有不同的关系时（如敌人和朋友），我们可以将原始的并查集扩大 n 倍（如果有 n 种关系），那么每一种并查集的含义都不一样，最后我们通过对每一个节点的父节点的比较来确定它们是什么关系。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//假设有n个元素,关系分为本身，猎物，天敌</span><br><span class="line">for(int i = 1 ;i &lt;= 3*n;i++)</span><br><span class="line">&#123;</span><br><span class="line">	p[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">//假设这里的三种关系分别是本身，猎物与天敌，那么x为本身，x+n为猎物，x+2*n即为天敌</span><br></pre></td></tr></table></figure>

<h4 id="注意对关系之间的处理"><a href="#注意对关系之间的处理" class="headerlink" title="注意对关系之间的处理"></a>注意对关系之间的处理</h4><p>关系一般是相互的，当我们确定了两种元素的关系之后，就要去合并对应的两棵树从而满足关系</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//比如我们已知了x吃y，那么需要合并的关系如下</span><br><span class="line">merge(x,y+2*n);//x是y的天敌</span><br><span class="line">merge(x+n,y);//x的猎物是y</span><br><span class="line">merge(x+2*n,y+n);//x的天敌是y的猎物（环形关系）</span><br></pre></td></tr></table></figure>

<h3 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h3><h4 id="Q1-定义"><a href="#Q1-定义" class="headerlink" title="Q1 定义"></a>Q1 定义</h4><p>在对并查集进行路径压缩和合并操作时，这些权值具有一定属性，即可将他们与父节点的关系，变化为与所在树的根结点关系。</p>
<p>也就是说。权值代表着当前节点和父节点之前的关系（即使经过了路径压缩），所以我们可以通过该节点与父节点这几件的关系来表示同一棵树下两个节点的关系。</p>
<h4 id="Q3-权值到底代表了什么"><a href="#Q3-权值到底代表了什么" class="headerlink" title="Q3 权值到底代表了什么"></a>Q3 权值到底代表了什么</h4><p>在题目对元素进行了种类的划分后，我们可以用权值的不同来区分种类的不同从而完成对种类的分辨。</p>
<p>故而这也是对种类并查集的一种处理方法。</p>
<h4 id="Q2-权值的转移"><a href="#Q2-权值的转移" class="headerlink" title="Q2 权值的转移"></a>Q2 权值的转移</h4><p>在合并操作中不能把权值直接进行赋值，而应该先推出需合并的两个节点 a，b 各自与根之间的关系才能实现树权值的连接</p>
<p><img src="/%E7%AE%97%E6%B3%95.assets/image-20241130142002673.png" alt="image-20241130142002673"></p>
<p>而权值应该根据题目的要求而确定。</p>
<blockquote>
<p>是的</p>
<p>好无聊</p>
<p>现在只能看你的笔记了</p>
<p>还可以帮你改改错</p>
</blockquote>
<h4 id="详见洛谷-P2024-食物链"><a href="#详见洛谷-P2024-食物链" class="headerlink" title="详见洛谷 P2024 食物链"></a>详见洛谷 P2024 食物链</h4><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="1-堆的定义"><a href="#1-堆的定义" class="headerlink" title="1.堆的定义"></a>1.堆的定义</h3><p>堆实际上是一个完全二叉树，完全二叉树的意思是除了最后一排节点之外，每一个节点都不为空并且每一个节点都含有两个子节点，并且最后一排节点从左到右顺序排列</p>
<p>堆分为小根堆和大根堆，小根堆的含义为根节点为整个堆中的最小值，并且从上到下元素逐渐变大；大根堆的含义是根节点为整个堆中的最大值，并且从上到下元素逐渐变小</p>
<h3 id="2-根的存储"><a href="#2-根的存储" class="headerlink" title="2.根的存储"></a>2.根的存储</h3><p>根是用一维数组储存的，存储规则如下</p>
<p><img src="/%E7%AE%97%E6%B3%95.assets/image-20241119112637430.png" alt="image-20241119112637430"></p>
<p>故对于每一个堆我们用一维数组 h[n]来定义，用 size 来记录这个堆或者说这个数组的长度</p>
<p>这种特殊的存储方式决定了堆的更改，添加，删除操作，即在数组的末尾进行元素的更改即可，详见下</p>
<h3 id="3-堆的操作"><a href="#3-堆的操作" class="headerlink" title="3.堆的操作"></a>3.堆的操作</h3><p>​ 首先介绍实现堆的各种操作的<em>两个基本操作</em>，up 和 down ，up 即是让某个元素（或节点）向上调整，down 即是让某个元素（或节点）向下调整</p>
<p><strong>Q1 如何实现 down 操作：</strong></p>
<p>为了维护小根堆的从上到下元素从小到大的性质，我们在每一次 down 之前先找到该节点和它的两个子节点之间的最小值，再把这个最小值和这个元素交换，一直到无法操作即最小值就是这个元素为止</p>
<p>需要注意的是每次 down 操作的索引是脚标而不是元素的值哦</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void down(int u)</span><br><span class="line">&#123;</span><br><span class="line">	int t = u;</span><br><span class="line">	if(u*2&lt;=size&amp;&amp;h[u*2]&lt;h[t]) t = u*2;</span><br><span class="line">	if(u*2+1&lt;=size&amp;&amp;h[u*2+1]&lt;h[t]) t = u*2 + 1;</span><br><span class="line">	if(u != t)</span><br><span class="line">	&#123;</span><br><span class="line">		swap(h[u],h[t]);</span><br><span class="line">		down(t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Q2 如何实现 up 操作</strong>：</p>
<p>基本逻辑原理同上，唯一不同的是，我们要让小的数往上走，需要判断往上走到什么时候</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void up(int u)</span><br><span class="line">&#123;</span><br><span class="line">	while(u / 2 &amp;&amp; h[u / 2]&gt;h[u])</span><br><span class="line">	&#123;</span><br><span class="line">		swap(h[u/2],h[u]);</span><br><span class="line">		u/=2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-堆中的一些元素处理"><a href="#4-堆中的一些元素处理" class="headerlink" title="4.堆中的一些元素处理"></a>4.堆中的一些元素处理</h3><p>Q1 插入一个数</p>
<p>由于在数组中储存，所以加在末位最方便</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">heap[++size] = x;</span><br><span class="line">up(size);</span><br></pre></td></tr></table></figure>

<p>Q2 求集合中的最小值</p>
<p>对于小根堆当然最小值就是根节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heap[1];</span><br></pre></td></tr></table></figure>

<p>Q3 删除最小值</p>
<p>这里的删除其实是用覆盖来实现的，即我们让最后一个值覆盖第一个值，然后再把原来的最后一个值删去，就达到了删除最小值的要求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">heap[1] = h[size];</span><br><span class="line">size -- ;</span><br><span class="line">down(1);</span><br></pre></td></tr></table></figure>

<p>Q4 删除任意一个元素</p>
<p>同理用覆盖法实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">heap[k] = heap[size];</span><br><span class="line">size -- ;</span><br><span class="line">down(k);</span><br></pre></td></tr></table></figure>

<p>Q5 修改任意一个元素</p>
<p>与前面不同的点在于，前面的点用最后一个值覆盖，故一定比原数大，为维护堆的性质只需要 down 一遍就可以了</p>
<p>而这里任意的修改大小不一定，所以我们选择 down 一遍再 up 一遍，其二只会执行一个，这样不管如何都会维持堆的性质</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">heap[k] = x;</span><br><span class="line">dowm(k);</span><br><span class="line">up(k);</span><br></pre></td></tr></table></figure>

<p>特殊情况是当我们需要对第 k 个插入的元素进行处理时，需要额外维护两个数组，第一个数组用来记录插入顺序 k 指向的堆中的位置（即元素的下标），第二个数组用来记录堆中的元素的值对应的插入顺序</p>
<p>必须用两个相互的数组记录的原因是为了让堆在进行 down 和 up 操作的时候不会扰乱插入顺序与元素之间的关系</p>
<p>因此，在这样的情况下需要自己定义一个 swap 来进行交换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void heap_swap(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">	swap(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">	swap(hp[a],hp[b]);</span><br><span class="line">	swap(h[a],h[b]);</span><br><span class="line">&#125;</span><br><span class="line">//在上述的各种操作中将swap转化为heap_swap即可</span><br></pre></td></tr></table></figure>

<p>还需要补充一下在插入过程中怎么维护这几个数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int size,m = 0;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">ph[m] = size; hp[size] = m;</span><br><span class="line">h[size] = x;</span><br><span class="line">up(size);</span><br></pre></td></tr></table></figure>

<h3 id="对顶堆"><a href="#对顶堆" class="headerlink" title="对顶堆"></a>对顶堆</h3><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>顾名思义，链表就像一条链子一样排布，故特点是每一个节点与前后的关系，并且可以单独分析每一个节点</p>
<h3 id="链表的主要作用"><a href="#链表的主要作用" class="headerlink" title="链表的主要作用"></a>链表的主要作用</h3><h4 id="1-单链表-邻接表-用来储存树和图"><a href="#1-单链表-邻接表-用来储存树和图" class="headerlink" title="1.单链表-&gt;邻接表-&gt;用来储存树和图"></a>1.单链表-&gt;邻接表-&gt;用来储存树和图</h4><h4 id="2-双链表-用来优化某些问题"><a href="#2-双链表-用来优化某些问题" class="headerlink" title="2.双链表-&gt;用来优化某些问题"></a>2.双链表-&gt;用来优化某些问题</h4><p>链表上给的数据存储结构单元就是<strong>节点</strong>，类似于数组中的位置。</p>
<p>每一个节点会包含：</p>
<p>1.它自身储存的数据</p>
<p>2.一个或两个用来指向下一个或上一个节点位置的链接</p>
<p>（在单向链表中，节点只记录后一节点的链接，而双向链表则前后都有）</p>
<h3 id="用指针实现的链表"><a href="#用指针实现的链表" class="headerlink" title="用指针实现的链表"></a>用指针实现的链表</h3><p>我们一般用 struct 结构体 来存储链表节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node&#123;</span><br><span class="line">	int value;</span><br><span class="line">	Node *next;//指针来记录链接</span><br><span class="line">	//如果是双向链表的话</span><br><span class="line">	Node *prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="一，单向链表"><a href="#一，单向链表" class="headerlink" title="一，单向链表"></a><strong>一，单向链表</strong></h4><h4 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h4><p>头节点指针赋值为空</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node *head = NULL;//NULL指针表示空节点，时标准库中值为0的一个常量</span><br></pre></td></tr></table></figure>

<h4 id="2-单向链表的方式"><a href="#2-单向链表的方式" class="headerlink" title="2.单向链表的方式"></a>2.单向链表的方式</h4><p>是从 head 节点开始到 NULL 指针结束，每个节点记录下一个节点是谁的数据结构</p>
<h4 id="3-单向链表的插入"><a href="#3-单向链表的插入" class="headerlink" title="3.单向链表的插入"></a>3.单向链表的插入</h4><p>Q1 如何在某个节点后添加一个节点</p>
<p>与上面说的同理，其实就是在两个链接间重建新的链接给它们搭一个桥，由于是单向的故我们只需要改变 next 指针即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void Insert(Node *p.Node *now)//在p节点后插入now节点</span><br><span class="line">&#123;</span><br><span class="line">	now-&gt;next = p-&gt;next;</span><br><span class="line">	p-&gt;next = now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Q2 如何在头节点前插入节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void Insert(Node *now)</span><br><span class="line">&#123;</span><br><span class="line">	now-&gt;next = head;</span><br><span class="line">	head = now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-单链表的删除"><a href="#4-单链表的删除" class="headerlink" title="4.单链表的删除"></a>4.单链表的删除</h4><p>Q1 在 p 节点之后删除 now 节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void Delete(Node *p.Node *now)</span><br><span class="line">&#123;</span><br><span class="line">	p-&gt;next = now-&gt;next;</span><br><span class="line">	now-&gt;next = NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Q2 删除第一个节点（头节点）</p>
<p>直接改变头指针即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void Delete()</span><br><span class="line">&#123;</span><br><span class="line">		head = head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-链表的构建"><a href="#5-链表的构建" class="headerlink" title="5.链表的构建"></a><strong>5.链表的构建</strong></h4><p>现在以按顺序排列几个数字为例子来用链表解决问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Node&#123;</span><br><span class="line">    int value;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125; a[81], *head;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for (int i = 0; i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i].value;</span><br><span class="line">        if(head == NULL || a[i].value &lt; head-&gt;value)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i].next = head;</span><br><span class="line">            head = &amp;a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            for (Node *p = head; p; p = p-&gt;next)</span><br><span class="line">            &#123;</span><br><span class="line">                if(p-&gt;value&lt;a[i].value&amp;&amp;(p-&gt;next == NULL || p-&gt;next-&gt;value&gt;a[i].value))</span><br><span class="line">                &#123;</span><br><span class="line">                    a[i].next = p-&gt;next;</span><br><span class="line">                    p-&gt;next = &amp;a[i];</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (Node *p = head; p;p = p-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; p-&gt;value &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在用指针实现链表的时候重要的还是厘清指针与数值之间的关系以及指向，并且恰当地表示</p>
<h3 id="二，双向链表"><a href="#二，双向链表" class="headerlink" title="二，双向链表"></a>二，双向链表</h3><p>与单向链表最大的区别就是它会记录指向后面的指针和指向前面的指针</p>
<p>双向链表的所有操作中与单项联编不同的点就是需要额外去维护这个节点指向前面的 prev 指针，其他是完全同理的操作</p>
<h4 id="1-初始化-1"><a href="#1-初始化-1" class="headerlink" title="1.初始化"></a>1.<strong>初始化</strong></h4><p>除了头节点指针赋值为空外，也需要维护尾节点指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node *head = NULL,*tail = NULL;</span><br></pre></td></tr></table></figure>

<h4 id="2-在-p-节点后插入-now-节点"><a href="#2-在-p-节点后插入-now-节点" class="headerlink" title="2.在 p 节点后插入 now 节点"></a><strong>2.在 p 节点后插入 now 节点</strong></h4><p>与单链表插入的区别只在于要重新维护一个 prev 指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void Insert(Node *p,Node *now)</span><br><span class="line">&#123;</span><br><span class="line">	Node *q = p-&gt;next;</span><br><span class="line">	p-&gt;next = now; now-&gt;prev = p;</span><br><span class="line">	now-&gt;next = q;q-&gt;prev = now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在头节点前插入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void Insert(Node *now)</span><br><span class="line">&#123;</span><br><span class="line">	now-&gt;next = head;</span><br><span class="line">    head-&gt;prev = now;</span><br><span class="line">    head = now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在尾节点后插入也是完全同理的操作，只是维护的顺序不一样而已（一个插在前面一个插在后面）</p>
<h4 id="3-删除一个-now-节点"><a href="#3-删除一个-now-节点" class="headerlink" title="3.删除一个 now 节点"></a>3.删除一个 now 节点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void Delete(Node *now)</span><br><span class="line">&#123;</span><br><span class="line">	Node *p = now-&gt;prev,*q = now-&gt;next;</span><br><span class="line">	p-&gt;next = q;</span><br><span class="line">	q-&gt;prev = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除尾节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void Delete(Node *now)</span><br><span class="line">&#123;</span><br><span class="line">	tail = now-&gt;prev;</span><br><span class="line">	tail-&gt;next = NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除头节点也完全同理，只是改变的是它的 next 指针而已</p>
<h3 id="三，循环链表"><a href="#三，循环链表" class="headerlink" title="三，循环链表"></a>三，循环链表</h3><p>即在单向链表的基础上将最后一个节点的 next 指针指向头节点，如果是双向链表的话就再将头节点的 prev 指向最后一个节点，从而行成的一个环状结构</p>
<p>循环链表正如其形状，最适用在环形问题上，如约瑟夫环</p>
<h3 id="用数组模拟实现的链表"><a href="#用数组模拟实现的链表" class="headerlink" title="用数组模拟实现的链表"></a>用数组模拟实现的链表</h3><h4 id="一，单向链表-1"><a href="#一，单向链表-1" class="headerlink" title="一，单向链表"></a>一，单向链表</h4><h5 id="1-模拟方式"><a href="#1-模拟方式" class="headerlink" title="1.模拟方式"></a>1.模拟方式</h5><p>同样地需要定义头节点，每个节点的 value，和指向下一项的指针，但不同的是 value 和指针我们都分别用数组来实现，它们之间的联系用下标来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const int N = 100010;</span><br><span class="line">int head,e[N],ne[N],idx;</span><br><span class="line">//head表示链表的头节点，数组e用来储存每个点的值，数组ne用来记录每个节点的next指针，idx作为一个索引指针，表示现在用到了哪一个点</span><br></pre></td></tr></table></figure>

<p>从 head 指向的第一个节点开始，从 0 开始计数，这个计数就是这个节点的下标。最后一个节点指向的空节点令为-1.</p>
<p>对于头节点 head 来说，它的值即是它指向的节点的下标，所以初始化为-1 是因为此时指向的是空节点。在对 head 进行赋值时，一般使用的是索引指针 idx。</p>
<h5 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2.初始化"></a>2.初始化</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void chu()</span><br><span class="line">&#123;</span><br><span class="line">	head = -1;</span><br><span class="line">	idx = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-插入操作"><a href="#3-插入操作" class="headerlink" title="3.插入操作"></a>3.插入操作</h5><p><strong>在头节点后插入一个节点</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void addtohead(int x)</span><br><span class="line">&#123;</span><br><span class="line">	e[idx] = x;</span><br><span class="line">	ne[idx] = head;</span><br><span class="line">	head = idx;</span><br><span class="line">	idx ++;//表示当前节点已经使用过了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​ <strong>在下标为 k 的点后插入一个点</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void add(int k,int x)</span><br><span class="line">&#123;</span><br><span class="line">	e[idx] = x;</span><br><span class="line">	ne[idx] = ne[k];</span><br><span class="line">	ne[k] = idx;</span><br><span class="line">	idx ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-删除操作"><a href="#4-删除操作" class="headerlink" title="4.删除操作"></a>4.删除操作</h5><p>​ <strong>在下标为 k 的点后删除节点</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void delete(int k)</span><br><span class="line">&#123;</span><br><span class="line">	ne[k] = ne[ne[k]];//让它直接指向下下个就行了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二，双向链表-1"><a href="#二，双向链表-1" class="headerlink" title="二，双向链表"></a>二，双向链表</h4><p>同样地，双向链表与单向链表的差别就是会同时维护左指针和右指针，我们只需要多开一个数组来表示左指针（前指针即可）</p>
<h5 id="1-模拟方式-1"><a href="#1-模拟方式-1" class="headerlink" title="1.模拟方式"></a>1.模拟方式</h5><p>在这里为了方便，就不单独定义头节点和尾节点，而是用下标为 0 和 1 的两个点来表示边界即头节点和尾节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const int N = 100010;</span><br><span class="line">int e[N],l[N],r[N],idx;</span><br><span class="line">//数组e用来储存每个点的值，数组r用来记录每个节点的next指针，数组l用来记录每个节点的prev指针，idx作为一个索引指针，表示现在用到了哪一个点</span><br></pre></td></tr></table></figure>

<h5 id="2-初始化-1"><a href="#2-初始化-1" class="headerlink" title="2.初始化"></a>2.初始化</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void chu()</span><br><span class="line">&#123;</span><br><span class="line">	//0表示左端点，1表示右端点</span><br><span class="line">	r[0] = 1,l[1] = 0;</span><br><span class="line">	idx = 2;//01已经被占用了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于在这里没有单独去令头尾节点，所以后面的几种操作我们都只介绍在下标为 k 的点左右进行操作进行即可。</p>
<h5 id="3-插入操作-1"><a href="#3-插入操作-1" class="headerlink" title="3.插入操作"></a>3.插入操作</h5><p>​ <strong>在下标为 k 的点右边插入一个点</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void add(int k,int x)</span><br><span class="line">&#123;</span><br><span class="line">	e[idx] = x;</span><br><span class="line">	r[idx] = r[k];</span><br><span class="line">	l[idx] = k;</span><br><span class="line">	l[r[k]] = idx;</span><br><span class="line">	r[k] = idx;</span><br><span class="line">//一定要注意改变的顺序</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们只需要调用这个函数就可以实现<strong>在这个节点 的左边插入一个点</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void add(l[k],int x);</span><br></pre></td></tr></table></figure>

<h5 id="4-删除操作-1"><a href="#4-删除操作-1" class="headerlink" title="4.删除操作"></a>4.删除操作</h5><p>​ <strong>在下标为 k 的点后删除节点</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void delete(int k)</span><br><span class="line">&#123;</span><br><span class="line">	r[l[k]] = r[k];</span><br><span class="line">	l[r[k]] = l[k];</span><br><span class="line">	//同样地，只需要忽略被删除的点即可</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在做链表相关的问题中，我们画出链表的图，就能理解以上这些操作的逻辑，也能便于自己写出来这些操作了。</p>
<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>哈希函数实际上就是把一些想要查询的东西映射成一些更便于查找（一般就是数字）的函数</p>
<p>可以将想要查询的那个大集合映射到一个小集合中，这个小集合储存到数组中，就称为哈希表</p>
<h3 id="2-值冲突解决方法"><a href="#2-值冲突解决方法" class="headerlink" title="2.值冲突解决方法"></a>2.值冲突解决方法</h3><p>由于哈希是用某种关系让值映射到一个数组，故而有可能不同的数字会映射到同一个结果上去，故而需要处理这样的值冲突</p>
<h4 id="Plan-A-跳过法"><a href="#Plan-A-跳过法" class="headerlink" title="Plan A 跳过法"></a>Plan A 跳过法</h4><p>发生冲突后往后找到第一个空位置插入值。可以定义这样的函数没让每次插入的位置往后＋任意的固定值</p>
<p>但这样的方法在面对一个很满的哈希表时，会耗费大量的时间复杂度在搜素空值上，这也就失去了哈希表的意义，所以一般我们不采用这样的方法</p>
<h4 id="Plan-B-容器法"><a href="#Plan-B-容器法" class="headerlink" title="Plan B 容器法"></a>Plan B 容器法</h4><p>为了让哈希表里的每个位置都能储存多个值，可以在每个位置都开一个容器来使得位置上可以储存多个值，这里可以开一张链表，更好地，可以开一个 vector 简单地处理这种动态储存空间</p>
<h3 id="3-哈希函数的设计"><a href="#3-哈希函数的设计" class="headerlink" title="3.哈希函数的设计"></a>3.哈希函数的设计</h3><p>（偏理论，看看得了）</p>
<p><img src="/%E7%AE%97%E6%B3%95.assets/image-20241125201633226.png" alt="image-20241125201633226"></p>
<h3 id="4-字符串哈希"><a href="#4-字符串哈希" class="headerlink" title="4.字符串哈希"></a>4.字符串哈希</h3><h4 id="1-用哈希函数将字符串转化为数字"><a href="#1-用哈希函数将字符串转化为数字" class="headerlink" title="1.用哈希函数将字符串转化为数字"></a>1.用哈希函数将字符串转化为数字</h4><p>对于字符串<img src="/%E7%AE%97%E6%B3%95.assets/image-20241125203146729.png" alt="image-20241125203146729"></p>
<p>哈希函数如下</p>
<p><img src="/%E7%AE%97%E6%B3%95.assets/image-20241125203118362.png" alt="image-20241125203118362"></p>
<p>代码实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int Hash(char s[],int n)</span><br><span class="line">&#123;</span><br><span class="line">	int res = 0;</span><br><span class="line">	for(int i = 1;i&lt;=n;i++) res = (res * base + (s[i]-&#x27;a&#x27;+1))%p;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-函数的解释"><a href="#2-函数的解释" class="headerlink" title="2.函数的解释"></a>2.函数的解释</h4><p>ci 跟字符串每个位置上字母有关的数字，一般地我们可以把 a 到 z 地数字映射到 1~26（这也就是为什么上面会(s[i]-‘a’+1)）</p>
<p>base 是指定的数 1，一般是一个大于字符串中字符数量（大于 ci 的最大值）的素数，一般可以取 101，137 等等</p>
<p>p 也是一个自己指定的数，一般是一个比较大的数，如可以取 9999954</p>
<p>一般地，当两个字符串的哈希值相同的时候，我们可以认为这两个字符串相同，不用一位一位地进行比较，可以节省时间</p>
<h4 id="3-求任意片段子串的哈希值"><a href="#3-求任意片段子串的哈希值" class="headerlink" title="3.求任意片段子串的哈希值"></a>3.求任意片段子串的哈希值</h4><p>以上哈希函数的定义的好处是我们可以使用类似于前缀和的思想快速地得到任意子串的哈希值</p>
<p>First</p>
<p>用 a 数组记录下计算 Hash（c）的中间过程。即</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i] = 	Hash(s1s2...si);</span><br></pre></td></tr></table></figure>

<p>那么对于任意子串 s[l,r] &#x3D; s[l] s[l+1]…s[r] 的哈希值为</p>
<p><img src="/%E7%AE%97%E6%B3%95.assets/image-20241125205712064.png" alt="image-20241125205712064"></p>
<p>代码实现如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int Hash(char s[],int n)</span><br><span class="line">&#123;</span><br><span class="line">	int res = 0;</span><br><span class="line">	for(int i = 0;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		res = (res * base + (s[i]-&#x27;a&#x27;+1))%p;</span><br><span class="line">		a[i] = res;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int partHash(int l ,int r)</span><br><span class="line">&#123;</span><br><span class="line">	int t = a[l-1] * pow(base,r-l+1)%p;</span><br><span class="line">	return (a[r]-t+p)%p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-stl-库中的-hash"><a href="#5-stl-库中的-hash" class="headerlink" title="5.stl 库中的 hash"></a>5.stl 库中的 hash</h3><p>在 cpp 的 stl 库中有一个数据结构 unordered_map 可以用来实现大多数的哈希表操作，主要原因是它可以很方便的在两个不同类型的元素之间建立起映射关系</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;K.V&gt; hash//这里是自定义的名称</span><br></pre></td></tr></table></figure>

<p>其中 K 为要储存的关键字信息的类型，V 为与它相关联的一些信息的类型（即映射到的）</p>
<p>比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;string,int&gt; hash;</span><br><span class="line"></span><br><span class="line">int query(string name)&#123; //查询被查找人的映射值</span><br><span class="line">	if(hash.find(name) == hash.end) ...//这说明在hash表中没有这个人</span><br><span class="line">	return hash[name]; //会返回映射值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	hash[&quot;ningning&quot;] = 22;</span><br><span class="line">	hash[&quot;tutu&quot;] = 33;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>unordered_map 中的 key 值默认支持 int double char string key vector 等类型。（其他的类型可以自己先写一些函数来处理，在这里不做扩展了）</p>
<h2 id="stl-库中的数据结构"><a href="#stl-库中的数据结构" class="headerlink" title="stl 库中的数据结构"></a>stl 库中的数据结构</h2><h2 id="第三章搜索与图论"><a href="#第三章搜索与图论" class="headerlink" title="第三章搜索与图论"></a>第三章搜索与图论</h2><h2 id="树和图的存储（邻接表）"><a href="#树和图的存储（邻接表）" class="headerlink" title="树和图的存储（邻接表）"></a>树和图的存储（邻接表）</h2><p>这里不多说</p>
<p>主要就是在一个数组中存储多个链表</p>
<p>后面题目会涉及到存储</p>
<p><strong>存储方式主要是头插法</strong></p>
<p>#include <iostream><br> #include <cstring><br> ​<br> using namespace std;<br> ​<br> const int N &#x3D; 100010;<br> ​<br> int h[N], e[N], ne[N], idx;&#x2F;&#x2F; h 为头指针，因为有多个链表所以有多个头<br> &#x2F;&#x2F; 这个链表表示某个数可以直接到哪个数<br> &#x2F;&#x2F;比如 1 可以直接到 3，4 在链表表示 1-&gt;3-&gt;4<br> void add(int a, int b){&#x2F;&#x2F; a 为头，b 为存的值<br>  e[idx] &#x3D; b;<br>  ne[idx] &#x3D; h[a];<br>  h[a] &#x3D; idx++;<br> }<br> ​<br> int main()<br> {<br>  memset(h, -1, sizeof h);<br>  }</p>
<h2 id="1-DFS"><a href="#1-DFS" class="headerlink" title="1.DFS"></a>1.DFS</h2><p>什么是 DFS？</p>
<p>DFS 通常指的是深度优先搜索（Depth-First Search），这是一种用于遍历或搜索树或图的算法。这种算法从根节点（在图的情况下，可以从任意一个顶点开始）开始，尽可能深地探索每个分支，直到达到无法继续深入为止，然后回溯到上一个节点并探索新的路径。这个过程会一直重复，直到所有的节点都被访问过。</p>
<p>有点递归的感觉</p>
<p>将过程想象成一棵树，每种情况都是一个分支</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/844/">842. 排列数字 - AcWing 题库</a></p>
<p>#include<iostream><br> using namespace std;<br> const int N&#x3D;10;<br> int n;<br> int path[N];<br> bool st[N];<br> void dfs(int u)<br> {<br>     &#x2F;&#x2F;输出<br>  if(u&#x3D;&#x3D;n)<br>  {<br>  for(int i&#x3D;0;i&lt;n;i++)printf(“%d”,path[i]);<br>  puts(“”);<br>  return ;<br>  }</p>
<p>&#x2F;&#x2F;多分枝搜索<br>  for(int i&#x3D;1;i&lt;&#x3D;n;i++)<br>  {<br>  if(!st[i])<br>  {<br>  path[u]&#x3D;i;<br>  st[i]&#x3D;true;<br>             &#x2F;&#x2F;往下递归<br>  dfs(u+1);<br>             &#x2F;&#x2F;恢复现场<br>  st[i]&#x3D;false;<br>  }<br>  }<br> }<br> ​<br> int main()<br> {<br>  cin&gt;&gt;n;<br>  dfs(0);<br>  return 0;<br> }</p>
<h2 id="2-BFS"><a href="#2-BFS" class="headerlink" title="2.BFS"></a>2.BFS</h2><p>BFS 是广度优先搜索（Breadth-First Search）的缩写，它是一种用于遍历或搜索树或图的算法。这种算法从根节点（在图的情况下，可以是从任意一个顶点开始）开始，然后探索所有与之相邻的节点，之后再对这些节点中未被访问过的邻居进行同样的操作，直到遍历完所有可达的节点。</p>
<p>也就是说对一个点相邻的未被访问过的点进同样的操作，直到遍历完所有点</p>
<p>bfs 有一个队列的性质</p>
<p>把每个点存进去然后找这个点的相邻未访问过的点存到队列里然后把队头出队 如此反复</p>
<p>可以看看 b 站视频演示<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1uCH1eoEYP?t=119.9">https://www.bilibili.com/video/BV1uCH1eoEYP?t=119.9</a></p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/846/">844. 走迷宫 - AcWing 题库</a></p>
<p>#include <iostream><br> #include <algorithm><br> #include <cstring><br> ​<br> using namespace std;<br> typedef pair&lt;int, int&gt; PII;<br> ​<br> const int N&#x3D;110;<br> ​<br> int n, m;<br> int g[N][N];&#x2F;&#x2F; g 是给的地图<br> int d[N][N];&#x2F;&#x2F; d 表示到初始位置的“距离”<br> PII q[N*N];&#x2F;&#x2F; q 存的是点的位置的一个队列<br> int bfs(){<br>  int hh &#x3D; 0, tt &#x3D; 0;<br>  q[0]&#x3D;{0, 0};<br>  memset(d, -1, sizeof d);<br>  d[0][0]&#x3D;0;&#x2F;&#x2F; 初始位置（0，0）的距离是 0<br>  int dx[4] &#x3D; {-1, 0, 1, 0}, dy[4] &#x3D; {0, 1, 0, -1};&#x2F;&#x2F; 走迷宫走的四个方向的 x， y 变化的所有可能性<br>  while (hh&lt;&#x3D;tt)<br>  {<br>  auto t &#x3D; q[hh++];<br>  for (int i &#x3D; 0; i &lt; 4; i ++)<br>  {<br>  int x &#x3D; t.first + dx[i], y &#x3D; t.second + dy[i];&#x2F;&#x2F; 求出下一个点的坐标<br>  if (x &gt;&#x3D; 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;&#x3D; 0 &amp;&amp; y &lt; m &amp;&amp; g[x][y] &#x3D;&#x3D; 0 &amp;&amp; d[x][y] &#x3D;&#x3D; -1)<br>                 &#x2F;&#x2F; d[x][y] &#x3D;&#x3D; -1 表示当前点未被访问过<br>  {<br>  d[x][y] &#x3D; d[t.first][t.second] + 1;<br>  q[++tt] &#x3D; {x, y};<br>  }<br>  }<br>  }<br>  return d[n-1][m-1];<br> }<br> int main()<br> {<br>  cin &gt;&gt; n &gt;&gt; m;<br>  for (int i &#x3D; 0; i &lt; n; i ++) {<br>  for (int j &#x3D; 0; j &lt; m; j ++)cin &gt;&gt; g[i][j]; &#x2F;&#x2F; 读入<br>  }<br>  cout &lt;&lt; bfs();<br>  return 0;<br> }</p>
<h2 id="3-拓扑排序"><a href="#3-拓扑排序" class="headerlink" title="3.拓扑排序"></a>3.拓扑排序</h2><p>每条边起点在终点的前面的序列就是拓扑序列</p>
<p>此时 1 2 3 就是拓扑序列</p>
<p><strong>有向无环图（也叫做拓扑图）一定存在拓扑序列</strong></p>
<p>度数的概念：</p>
<p><strong>入度就是一个点有多少条边指向自己，出度就是一个点有几条边出去</strong></p>
<p>本题就是求出其中的拓扑序列</p>
<p>这里主要用 BFS 实现</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/850/">848. 有向图的拓扑序列 - AcWing 题库</a></p>
<p>#include <iostream><br> #include <cstring><br> using namespace std;<br> const int N &#x3D; 100010;<br> int n, m;<br> int h[N], e[N], ne[N], idx;&#x2F;&#x2F; 这里跟下面的 add 函数就是邻接表用于存储一个图<br> int q[N], d[N];&#x2F;&#x2F; d 表示每个点入度的个数<br> ​<br> void add(int a, int b)<br> {<br>  e[idx] &#x3D; b;<br>  ne[idx] &#x3D; h[a];<br>  h[a] &#x3D; idx++;<br>  }</p>
<p>bool topsort ()<br> {<br>  int hh &#x3D; 0, tt &#x3D; 0;<br>  for (int i &#x3D; 1; i &lt;&#x3D; n; i ++){<br>  if(!d[i])q[tt++] &#x3D; i;&#x2F;&#x2F; 将每一个入度为 0 的点存进来从入度为零的点开始找，相当于头<br>  }<br>  while(hh &lt;&#x3D; tt)<br>  {<br>  int t &#x3D; q[hh++];<br>  for (int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i]){&#x2F;&#x2F; 邻接表的遍历<br>  int j &#x3D; e[i];<br>  d[j] –;&#x2F;&#x2F; 删去一个入度因为 int t &#x3D; q[hh++];<br>  if (d[j] &#x3D;&#x3D; 0)q[tt++] &#x3D; j;&#x2F;&#x2F; 如果入度为 0，相当于 q 队列的用法，存进来<br>  }<br>  }<br>  return tt &#x3D;&#x3D; n;<br> }<br> int main()<br> {<br>  cin &gt;&gt; n &gt;&gt; m;<br>  memset(h, -1, sizeof h);<br>     &#x2F;&#x2F; while 循环里先用头插将点存进来点从 a 指向 b，因此存进来的点入度加一<br>  while(m –){<br>  int a, b;<br>  cin &gt;&gt; a &gt;&gt; b;<br>  add(a, b);<br>  d[b] ++;<br>  }<br>  if(topsort())<br>  {<br>  for (int i &#x3D; 0; i &lt; n; i ++)cout &lt;&lt; q[i] &lt;&lt; “ “;<br>  }else puts(“-1”);</p>
<p>return 0;<br>  }</p>
<h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><h3 id="√4-Dijkstra"><a href="#√4-Dijkstra" class="headerlink" title="√4.Dijkstra"></a>√4.Dijkstra</h3><p><strong>题目一定不能存在负权边！！</strong></p>
<p>就是一个一个往下递推</p>
<p>0x3f3f3f3f 大约是 1x10^9 用来定义一个很大的数</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/852/">850. Dijkstra 求最短路 II - AcWing 题库</a></p>
<p>#include <iostream><br> #include <cstring><br> ​<br> using namespace std;<br> ​<br> const int N &#x3D; 510;<br> ​<br> int n, m;<br> int g[N][N];&#x2F;&#x2F; g 为邻接矩阵<br> int dist[N];&#x2F;&#x2F; dist 为某点到该点的距离<br> bool st[N];&#x2F;&#x2F; st 为该点是否已经被确定最短路<br> ​<br> int dijkstra()<br> {<br>  memset(dist, 0x3f, sizeof(dist));&#x2F;&#x2F; memset 按单字节填充 int 每个字节被设置为 0x3f 则每个整数被定为 0x3f3f3f3f<br>  dist[1] &#x3D; 0;&#x2F;&#x2F; 1 到自己距离为 0</p>
<p>for(int i &#x3D; 0; i &lt; n; i ++)&#x2F;&#x2F; 遍历每一个点求出所有可能<br>  {<br>  int t &#x3D; -1;<br>  for(int j &#x3D; 1; j &lt;&#x3D; n; j ++)<br>  {<br>  if(!st[j] &amp;&amp; (t &#x3D;&#x3D; -1 || dist[t] &gt; dist[j]))&#x2F;&#x2F; 找到未被确定的距离 1 最小的点(依据贪心，其实也好理解)<br>  {<br>  t &#x3D; j;<br>  }<br>  }<br>  st[t] &#x3D; true;&#x2F;&#x2F; 这点最短距离确定<br>         &#x2F;&#x2F; 以这点为基准判断其他点的最短路<br>  for(int j &#x3D; 1; j &lt;&#x3D; n; j ++)<br>  {<br>  dist[j] &#x3D; min(dist[j], dist[t] + g[t][j]);<br>  }<br>  }<br>  if(dist[n] &#x3D;&#x3D; 0x3f3f3f3f)return -1;&#x2F;&#x2F; dist[n] &#x3D;&#x3D; 0x3f3f3f3f 表示该点未被确定也就是没有路从 1 到该点<br>  return dist[n];&#x2F;&#x2F; 返回最短路<br> }<br> int main()<br> {<br>  scanf(“%d%d”, &amp;n, &amp;m);<br>  memset(g, 0x3f, sizeof(g));<br>  while (m –)<br>  {<br>  int x, y, z;<br>  scanf(“%d%d%d”, &amp;x, &amp;y, &amp;z);<br>  g[x][y] &#x3D; min(g[x][y], z);&#x2F;&#x2F; 如果遇到重边选择最短的那个(依据题意)<br>  }<br>  int t &#x3D; dijkstra();</p>
<p>printf(“%d”, t);</p>
<p>return 0;<br>  }</p>
<p>而当数据量很大的时候用邻接矩阵 N*N 会报错</p>
<p>这时候我们可以优化使用邻接表和优先队列的形式</p>
<p>#include <iostream><br> #include <cstring><br> #include <queue><br> ​<br> using namespace std;<br> ​<br> typedef pair&lt;int, int &gt; PII;<br> const int N &#x3D; 1e5 + 10;<br> ​<br> int n, m;<br> int h[N], e[N], w[N], ne[N], idx;&#x2F;&#x2F; h 为每个头，e 为值，w 为每个权重<br> int dist[N];&#x2F;&#x2F; dist 为某点到该点的距离<br> bool st[N];&#x2F;&#x2F; st 为该点是否已经被确定最短路<br> ​<br> void add(int a, int b, int c)&#x2F;&#x2F; 邻接表的头插<br> {<br>  e[idx] &#x3D; b;<br>  w[idx] &#x3D; c;<br>  ne[idx] &#x3D; h[a];<br>  h[a] &#x3D; idx++;<br> }<br> int dijkstra()<br> {<br>  memset(dist, 0x3f, sizeof(dist));&#x2F;&#x2F; memset 按单字节填充 int 每个字节被设置为 0x3f 则每个整数被定为 0x3f3f3f3f<br>  dist[1] &#x3D; 0;&#x2F;&#x2F; 1 到自己距离为 0</p>
<p>priority_queue&lt;PII, vector<PII>,greater<PII>&gt;heap;&#x2F;&#x2F; 创建一个升序的优先队列<br>  heap.push({0, 1});&#x2F;&#x2F; 插入第一个元素,fist 为距离 second 为编号</p>
<p>while(heap.size()){&#x2F;&#x2F; 若非空<br>  auto t &#x3D; heap.top();<br>  heap.pop();</p>
<p>int ver &#x3D; t.second, distance &#x3D; t.first;&#x2F;&#x2F; ver 是该点，distance 是到起始点的距离</p>
<p>if(st[ver]) continue;&#x2F;&#x2F; 如果该点已经得出最短路<br>  st[ver] &#x3D; true;</p>
<p>for(int i &#x3D; h[ver]; i !&#x3D; -1; i &#x3D; ne[i])&#x2F;&#x2F; 以这点为基准判断其他点的最短路<br>  {<br>  int j &#x3D; e[i];<br>  if(dist[j] &gt; distance + w[i])<br>  {<br>  dist[j] &#x3D; distance + w[i];<br>  heap.push({dist[j],j});<br>  }<br>  }<br>  }<br>  if(dist[n] &#x3D;&#x3D; 0x3f3f3f3f)return -1;&#x2F;&#x2F; dist[n] &#x3D;&#x3D; 0x3f3f3f3f 表示该点未被确定也就是没有路从 1 到该点<br>  return dist[n];&#x2F;&#x2F; 返回最短路<br> }<br> int main()<br> {<br>  scanf(“%d%d”, &amp;n, &amp;m);</p>
<p>memset(h, -1, sizeof(h));&#x2F;&#x2F; 邻接表的初始化</p>
<p>while (m –)<br>  {<br>  int x, y, z;<br>  scanf(“%d%d%d”, &amp;x, &amp;y, &amp;z);<br>  add(x, y, z);<br>  }<br>  int t &#x3D; dijkstra();</p>
<p>printf(“%d”, t);</p>
<p>return 0;<br>  }</p>
<h3 id="√5-bellman-ford"><a href="#√5-bellman-ford" class="headerlink" title="√5.bellman-ford"></a>√5.bellman-ford</h3><p><strong>当存在负权边时可以使用</strong></p>
<p><strong>有边数限制的时候可以用</strong></p>
<p>#include <iostream><br> #include <cstring><br> ​<br> using namespace std;<br> ​<br> const int N &#x3D; 510, M &#x3D; 10010;<br> ​<br> struct Edge{<br>  int a, b, w;<br> }edges[M];<br> ​<br> int n, m, k;<br> int dist[N], backcup[N];<br> ​<br> int bellman_ford()<br> {<br>  memset(dist, 0x3f, sizeof dist);<br>  dist[1] &#x3D; 0;</p>
<p>for(int i &#x3D; 0; i &lt; k; i ++)&#x2F;&#x2F; 处理最多走 k 条边时的最短路<br>  {<br>  memcpy(backcup, dist, sizeof dist);&#x2F;&#x2F; 备份，因为这里走的边有限所以 mei 走一条边要用上一次的距离来计算下面的<br>  for(int j &#x3D; 0; j &lt; m; j ++)<br>  {<br>  int a &#x3D; edges[j].a, b &#x3D; edges[j].b, w &#x3D; edges[j].w;<br>  dist[b] &#x3D; min(dist[b], backcup[a] + w);<br>  }<br>  }</p>
<p>if(dist[n] &gt; 0x3f3f3f3f &#x2F; 2)return -1;<br>  return dist[n];<br> }<br> ​<br> int main()<br> {<br>  scanf(“%d%d%d”, &amp;n, &amp;m, &amp;k);</p>
<p>for(int i &#x3D; 0; i &lt; m; i ++)<br>  {<br>  int a, b, w;<br>  scanf(“%d%d%d”, &amp;a, &amp;b, &amp;w);<br>  edges[i] &#x3D; {a, b, w};<br>  }</p>
<p>int t &#x3D; bellman_ford();</p>
<p>if(t &#x3D;&#x3D; -1)printf(“impossible”);<br>  else printf(“%d”, t);</p>
<p>return 0;<br>  }</p>
<h3 id="6-spfa"><a href="#6-spfa" class="headerlink" title="6.spfa"></a>6.spfa</h3><ul>
<li><h4 id="判断最短路"><a href="#判断最短路" class="headerlink" title="判断最短路"></a>判断最短路</h4>主要是对 bellman-ford 一个优化<br>dist[b] &#x3D; min(dist[b], dist[a] + w); 当 dist[a]不变时 dist[b]就不会变小<br>spfa 就是用队列对这一部分进行优化<br>#include <iostream><br>  #include <cstring><br>  #include <queue><br>  ​<br>  using namespace std;<br>  ​<br>  typedef pair&lt;int, int &gt; PII;<br>  const int N &#x3D; 1e5 + 10;<br>  ​<br>  int n, m;<br>  int h[N], e[N], w[N], ne[N], idx;&#x2F;&#x2F; h 为每个头，e 为值，w 为每个权重<br>  int dist[N];&#x2F;&#x2F; dist 为某点到该点的距离<br>  bool st[N];&#x2F;&#x2F; st 为该点是否在队列中<br>  ​<br>  void add(int a, int b, int c)&#x2F;&#x2F; 邻接表的头插<br>  {<br>   e[idx] &#x3D; b;<br>   w[idx] &#x3D; c;<br>   ne[idx] &#x3D; h[a];<br>   h[a] &#x3D; idx++;<br>  }<br>  int spfa()<br>  {<br>      memset(dist, 0x3f, sizeof dist);<br>      dist[1] &#x3D; 0;<br>queue<int> q;&#x2F;&#x2F; q 队列存储改变的那个点，因为这个点改变才会导致后面的点变化<br>q.push(1);<br>      st[1] &#x3D; true;<br>while(q.size())<br>     {<br>          int t &#x3D; q.front();<br>          q.pop();<br>          st[t] &#x3D; false;<br>for(int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i])<br>         {<br>              int j &#x3D; e[i];<br>              if(dist[j] &gt; dist[t] + w[i])<br>             {<br>                  dist[j] &#x3D; dist[t] + w[i];<br>                  if(!st[j])<br>                 {<br>                      q.push(j);<br>                      st[j] &#x3D; true;<br>                 }<br>             }<br>         }<br>     }<br>if(dist[n] &#x3D;&#x3D; 0x3f3f3f3f)return -1;&#x2F;&#x2F; -1 依据题目<br>      return dist[n];<br>  }<br>  int main()<br>  {<br>   scanf(“%d%d”, &amp;n, &amp;m);<br>memset(h, -1, sizeof(h));&#x2F;&#x2F; 邻接表的初始化<br>while (m –)<br>   {<br>   int x, y, z;<br>   scanf(“%d%d%d”, &amp;x, &amp;y, &amp;z);<br>   add(x, y, z);<br>   }<br>   int t &#x3D; spfa();<br>if(t &#x3D;&#x3D; -1)printf(“impossible”);<br>      else printf(“%d”, t);<br>return 0;<br>   }</li>
<li><h4 id="spfa-判断负环"><a href="#spfa-判断负环" class="headerlink" title="spfa 判断负环"></a>spfa 判断负环</h4>创建一个 cnt 数组来记录边数<br>当 cnt 数组&gt;&#x3D;n 就代表当前边存在自环且一定是负环（只有负环才会往下更新）<br>#include <iostream><br>  #include <cstring><br>  #include <queue><br>  ​<br>  using namespace std;<br>  ​<br>  typedef pair&lt;int, int &gt; PII;<br>  const int N &#x3D; 1e5 + 10;<br>  ​<br>  int n, m;<br>  int h[N], e[N], w[N], ne[N], idx;&#x2F;&#x2F; h 为每个头，e 为值，w 为每个权重<br>  int dist[N], cnt[N];&#x2F;&#x2F; dist 为某点到该点的距离，cnt 记录边数<br>  bool st[N];&#x2F;&#x2F; st 为该点是否在队列中<br>  ​<br>  void add(int a, int b, int c)&#x2F;&#x2F; 邻接表的头插<br>  {<br>   e[idx] &#x3D; b;<br>   w[idx] &#x3D; c;<br>   ne[idx] &#x3D; h[a];<br>   h[a] &#x3D; idx++;<br>  }<br>  bool spfa()<br>  {<br>      queue<int> q;&#x2F;&#x2F; q 队列存储改变的那个点，因为这个点改变才会导致后面的点变化<br>&#x2F;&#x2F; 将所以点都入队，防止第一个点与后面不相连<br>     for(int i &#x3D; 1; i &lt;&#x3D; n; i ++)<br>     {<br>         st[i] &#x3D; true;<br>         q.push(i);<br>     }<br>while(q.size())<br>     {<br>          int t &#x3D; q.front();<br>          q.pop();<br>          st[t] &#x3D; false;<br>for(int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i])<br>         {<br>              int j &#x3D; e[i];<br>              if(dist[j] &gt; dist[t] + w[i])<br>             {<br>                  dist[j] &#x3D; dist[t] + w[i];<br>                  cnt[j] &#x3D; cnt[t] + 1;<br>if(cnt[j] &gt;&#x3D; n)return true;<br>                  if(!st[j])<br>                 {<br>                      q.push(j);<br>                      st[j] &#x3D; true;<br>                 }<br>             }<br>         }<br>     }<br>return false;<br>  }<br>  int main()<br>  {<br>   scanf(“%d%d”, &amp;n, &amp;m);<br>memset(h, -1, sizeof(h));&#x2F;&#x2F; 邻接表的初始化<br>while (m –)<br>   {<br>   int x, y, z;<br>   scanf(“%d%d%d”, &amp;x, &amp;y, &amp;z);<br>   add(x, y, z);<br>   }<br>if(spfa())puts(“Yes”);<br>   else puts(“No”);<br>return 0;<br>   }</li>
</ul>
<h3 id="√7-Floyd"><a href="#√7-Floyd" class="headerlink" title="√7.Floyd"></a>√7.Floyd</h3><p>一个比较简单的算法</p>
<p>可以想象成向量相加的形式</p>
<p><strong>floyd 里面三个 for 循环循序不能变！！！ 否则可能会把没有求出最短路的边拿来用导致出错</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/856/">854. Floyd 求最短路 - AcWing 题库</a></p>
<p>#include <iostream><br> ​<br> using namespace std;<br> ​<br> const int N &#x3D; 210, INF &#x3D; 1e9;<br> ​<br> int n, m, Q;<br> int d[N][N];<br> ​<br> void Floyd()<br> {<br>  for(int k &#x3D; 1; k &lt;&#x3D; n; k ++)<br>  for(int i &#x3D; 1; i &lt;&#x3D; n; i ++)<br>  for (int j &#x3D; 1; j &lt;&#x3D; n; j ++)<br>  d[i][j] &#x3D; min(d[i][j], d[i][k] + d[k][j]);&#x2F;&#x2F; d[i][k] + d[k][j]“向量相加”</p>
<p>}<br> ​<br> int main()<br> {<br>  cin &gt;&gt; n &gt;&gt; m &gt;&gt; Q;<br>  for(int i &#x3D; 1; i &lt;&#x3D; n; i ++)<br>  for(int j &#x3D; 1; j &lt;&#x3D; n; j ++)<br>  if(i &#x3D;&#x3D; j)d[i][j] &#x3D; 0;<br>  else d[i][j] &#x3D; INF;</p>
<p>while(m –)<br>  {<br>  int x, y, z;<br>  cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;<br>  d[x][y] &#x3D; min(d[x][y], z);<br>  }</p>
<p>Floyd();</p>
<p>while(Q –)<br>  {<br>  int x, y;<br>  cin &gt;&gt; x &gt;&gt; y;</p>
<p>if(d[x][y] &gt; INF &#x2F; 2)puts(“impossible”);<br>  else cout &lt;&lt; d[x][y] &lt;&lt; endl;<br>  }</p>
<p>return 0;<br>  }</p>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="8-Prim"><a href="#8-Prim" class="headerlink" title="8.Prim"></a>8.Prim</h3><p>主要解决最小生成树的问题</p>
<p>跟 Dijkstra 类似但此时求的是到集合的距离</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/860/">858. Prim 算法求最小生成树 - AcWing 题库</a></p>
<p>#include <iostream><br> #include <cstring><br> ​<br> using namespace std;<br> ​<br> const int N &#x3D; 510, INF &#x3D; 0x3f3f3f3f;</p>
<p>int n, m;<br> int g[N][N];<br> int dist[N];&#x2F;&#x2F; dist 存到集合的最短距离<br> bool st[N];<br> ​<br> int prim()<br> {<br>  memset(dist, 0x3f, sizeof dist);</p>
<p>int res &#x3D; 0;</p>
<p>for(int i &#x3D; 0; i &lt; n; i ++)<br>  {<br>  int t &#x3D; -1;<br>         &#x2F;&#x2F;在集合外找到到集合距离最小的点<br>  for(int j &#x3D; 1; j &lt;&#x3D; n; j ++)<br>  {<br>  if(!st[j] &amp;&amp; (t &#x3D;&#x3D; -1 || dist[t] &gt; dist[j]))t &#x3D; j;<br>  }</p>
<p>if(i &amp;&amp; dist[t] &#x3D;&#x3D; INF)return INF;&#x2F;&#x2F; 如果这个最下的点为 INF 则表明没有线到集合就是与集合不相连</p>
<p>if(i)res +&#x3D; dist[t];</p>
<p>for(int j &#x3D; 1; j &lt;&#x3D; n; j ++)dist[j] &#x3D; min(dist[j], g[t][j]);</p>
<p>st[t] &#x3D; true;</p>
<p>}</p>
<p>return res;<br> }<br> ​<br> int main()<br> {<br>  scanf(“%d%d”, &amp;n, &amp;m);</p>
<p>memset(g, 0x3f, sizeof g);</p>
<p>while(m –)<br>  {<br>  int a, b, c;<br>  scanf(“%d%d%d”, &amp;a, &amp;b, &amp;c);<br>  g[a][b] &#x3D; g[b][a] &#x3D; min(g[a][b], c);&#x2F;&#x2F; 无向图的存储<br>  }</p>
<p>int t &#x3D; prim();</p>
<p>if(t &#x3D;&#x3D; INF)puts(“impossible”);<br>  else printf(“%d\n”,t);</p>
<p>return 0;<br> }</p>
<h3 id="√9-Kruskal"><a href="#√9-Kruskal" class="headerlink" title="√9.Kruskal"></a>√9.Kruskal</h3><p>这个方法线将权重 w 排序使得每次循环都用的最短的那条路，这样就可以使得求出来的权值最小</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/861/">859. Kruskal 算法求最小生成树 - AcWing 题库</a></p>
<p>#include <iostream><br> #include <algorithm><br> ​<br> using namespace std;<br> ​<br> const int N &#x3D; 200010;<br> ​<br> int n, m;<br> int p[N];<br> ​<br> struct Edge{<br>  int a, b, w;<br>  &#x2F;&#x2F; 自定义排序，按边的权重 w 从小到大排<br>  bool operator&lt; (const Edge &amp;W)const<br>  {<br>  return w &lt; W.w;<br>  }<br> }edges[N];<br> &#x2F;&#x2F; 并查集寻找祖宗节点<br> int find(int x)<br> {<br>  if(p[x] !&#x3D; x)p[x] &#x3D; find(p[x]);<br>  return p[x];<br> }<br> ​<br> int main()<br> {<br>  scanf(“%d%d”, &amp;n, &amp;m);</p>
<p>for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) p[i] &#x3D; i;  &#x2F;&#x2F;并查集初始化<br>  &#x2F;&#x2F;读入数据<br>  for(int i &#x3D; 0; i &lt; m; i ++)<br>  {<br>  int a, b, w;<br>  scanf(“%d%d%d”, &amp;a, &amp;b, &amp;w);<br>  edges[i] &#x3D; {a, b, w};<br>  }</p>
<p>sort(edges, edges + m);</p>
<p>int res &#x3D; 0, cnt &#x3D; 0;&#x2F;&#x2F; res 存权重之和，cnt 存有多少条边可以来判断是否有生成树</p>
<p>for(int i &#x3D; 0; i &lt; m; i ++)<br>  {<br>  int a &#x3D; edges[i].a, b &#x3D; edges[i].b, w &#x3D; edges[i].w;</p>
<p>a &#x3D; find(a), b &#x3D; find(b);<br>  if(a !&#x3D; b)<br>  {<br>  p[a] &#x3D; b;<br>  res +&#x3D; w;<br>  cnt ++;<br>  }<br>  }</p>
<p>if(cnt &lt; n - 1)puts(“impossible”);<br>  else printf(“%d”,res);</p>
<p>return 0;<br>  }</p>
<h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><h3 id="10-染色法判定二分图"><a href="#10-染色法判定二分图" class="headerlink" title="10.染色法判定二分图"></a>10.染色法判定二分图</h3><p>什么是二分图？</p>
<p>就是可以形成点在左右两个集合里边在中间的图</p>
<p>二分图当且仅当图中不含奇数环</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/862/">860. 染色法判定二分图 - AcWing 题库</a></p>
<p>#include <iostream><br> #include <cstring><br> ​<br> using namespace std;<br> ​<br> const int N &#x3D; 100010, M &#x3D; 200010;<br> ​<br> int n, m;<br> int h[N], e[M], ne[M], idx;<br> int color[N];&#x2F;&#x2F; 1 和 2 为不同颜色<br> ​<br> void add(int a, int b)<br> {<br>  e[idx] &#x3D; b, ne[idx] &#x3D; h[a], h[a] &#x3D; idx ++;<br> }<br> ​<br> &#x2F;&#x2F; dfs 用于给点当前点染色并判断与之相连的点是否符合条件即颜色不同<br> bool dfs(int u, int c)<br> {<br>  color[u] &#x3D; c;</p>
<p>for(int i &#x3D; h[u]; i !&#x3D; -1; i &#x3D; ne[i])<br>  {<br>  int j &#x3D; e[i];<br>  if(!color[j])<br>  {<br>  if(!dfs(j, 3 - c))return false;<br>  }<br>  else if(color[j] &#x3D;&#x3D; c)return false;<br>  }<br>  return true;<br> }<br> ​<br> int main()<br> {<br>  scanf(“%d%d”, &amp;n, &amp;m);</p>
<p>memset(h, -1, sizeof h);</p>
<p>while(m –)<br>  {<br>  int a, b;<br>  scanf(“%d%d”, &amp;a, &amp;b);<br>  add(a, b), add(b, a);&#x2F;&#x2F; 无向图的添加<br>  }</p>
<p>bool flag &#x3D; true;<br>  for(int i &#x3D; 1; i &lt;&#x3D; n; i ++)<br>  {<br>  if(!color[i])&#x2F;&#x2F; 如果为染色<br>  {<br>  if(!dfs(i, 1))&#x2F;&#x2F; 如果染色后不满足二分图的条件<br>  {<br>  flag &#x3D; false;<br>  break;<br>  }<br>  }<br>  }</p>
<p>if(flag)puts(“Yes”);<br>  else puts(“No”);</p>
<p>return 0;<br> }</p>
<h3 id="11-匈牙利算法"><a href="#11-匈牙利算法" class="headerlink" title="11.匈牙利算法"></a>11.匈牙利算法</h3><p>怎么说呢</p>
<p>就是左右两个集合匹配问题，如果 a 想匹配 b 而 b 已被匹配但 b 有别的匹配方案那么 b 匹配另一个的 a 匹配 b</p>
<p>具体可以看看 Acwing 上的视频这一课我认为是讲的最好的</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/video/290/">AcWing 861. 二分图的最大匹配 - AcWing</a>看他举的例子</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/863/">861. 二分图的最大匹配 - AcWing 题库</a></p>
<p>#include <iostream><br> #include <cstring><br> ​<br> using namespace std;<br> ​<br> const int N &#x3D; 510, M &#x3D; 100010;<br> ​<br> int n1, n2, m;<br> int h[N], e[M], ne[M], idx;<br> int math[N];&#x2F;&#x2F; math 存储匹配的对象<br> bool st[N];&#x2F;&#x2F; st 存储当前点是否被考虑过<br> ​<br> void add(int a, int b)<br> {<br>  e[idx] &#x3D; b, ne[idx] &#x3D; h[a], h[a] &#x3D; idx ++;<br> }<br> &#x2F;&#x2F; 匹配算法 成功返回 true 失败返回 false<br> bool find(int x)<br> {<br>  for(int i &#x3D; h[x]; i !&#x3D; -1; i &#x3D; ne[i])<br>  {<br>  int j &#x3D; e[i];<br>  if(!st[j])<br>  {<br>  st[j] &#x3D; true;<br>  if(math[j] &#x3D;&#x3D; 0 || find(math[j]))&#x2F;&#x2F; 如过当前点未匹配或者他可以匹配其他的点<br>  {<br>  math[j] &#x3D; x;<br>  return true;<br>  }<br>  }<br>  }<br>  return false;<br> }<br> ​<br> int main()<br> {<br>  scanf(“%d%d%d”, &amp;n1, &amp;n2, &amp;m);<br>  memset(h, -1, sizeof h);</p>
<p>while(m –)<br>  {<br>  int a, b;<br>  scanf(“%d%d”, &amp;a, &amp;b);<br>  add(a, b);<br>  }</p>
<p>int res &#x3D; 0;<br>  for(int i &#x3D; 1; i &lt;&#x3D; n1; i ++)<br>  {<br>  memset(st, false, sizeof st);</p>
<p>if(find(i))res ++;<br>  }</p>
<p>printf(“%d”, res);</p>
<p>return 0;<br> }</p>
<p><img src="/%E7%AE%97%E6%B3%95.assets/image-20241130162439962.png" alt="image-20241130162439962"></p>
<h2 id="第四章数学知识"><a href="#第四章数学知识" class="headerlink" title="第四章数学知识"></a>第四章数学知识</h2><h2 id="1-质数"><a href="#1-质数" class="headerlink" title="1.质数"></a>1.质数</h2><h3 id="①-试除法判断质数"><a href="#①-试除法判断质数" class="headerlink" title="① 试除法判断质数"></a>① 试除法判断质数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//只强调写循环条件的时候</span><br><span class="line"> for9int i = 2;i &lt;= n/i;i ++)</span><br><span class="line"> //其他照旧</span><br></pre></td></tr></table></figure>

<h3 id="②-试除法分解质因数"><a href="#②-试除法分解质因数" class="headerlink" title="② 试除法分解质因数"></a>② 试除法分解质因数</h3><p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250126153901302.png" alt="image-20250126153901302"></p>
<h3 id="③-筛质数"><a href="#③-筛质数" class="headerlink" title="③ 筛质数"></a>③ 筛质数</h3><p>这里介绍线性算法，即用质数筛掉所有以该质数为因子的合数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int cnt,primes[N];</span><br><span class="line">bool st[N];</span><br><span class="line"></span><br><span class="line">void get_primes(int n)&#123;</span><br><span class="line">	for(int i = 2;i &lt;= n;i ++)&#123;</span><br><span class="line">		if(!st[i]) primes[cnt ++] = i;</span><br><span class="line">		else &#123;</span><br><span class="line">			for(int j = 0;primes[j] &lt;= n/i;j ++) &#123;</span><br><span class="line">			st[i * primes[j]] = true;</span><br><span class="line">			if(i % primes[j] == 0) break; // primes[j]一定是i的最小质因子</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int n; cin &gt;&gt; n;</span><br><span class="line">	get_primes(n);</span><br><span class="line">	cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-约数"><a href="#2-约数" class="headerlink" title="2.约数"></a>2.约数</h2><h3 id="①-试除法求约数"><a href="#①-试除法求约数" class="headerlink" title="① 试除法求约数"></a>① 试除法求约数</h3><p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250126164736991.png" alt="image-20250126164736991"></p>
<h3 id="②-求约数个数"><a href="#②-求约数个数" class="headerlink" title="② 求约数个数"></a>② 求约数个数</h3><p>约数个数公式</p>
<p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250126165536547.png" alt="image-20250126165536547"></p>
<p>所以我们需要先分界质因数然后再求指数，用 hash 表来存就好</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line">const int N = 1e7;</span><br><span class="line">const int mod = 1e9 + 7;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n; cin &gt;&gt; n;</span><br><span class="line">    unordered_map&lt;int,int&gt;primes; //用来存质因数和它的指数</span><br><span class="line">    while(n --)&#123;</span><br><span class="line">        int x; cin &gt;&gt; x;</span><br><span class="line">        for(int i = 2;i &lt;= n;i ++)&#123;</span><br><span class="line">            while(x % i == 0)&#123;</span><br><span class="line">                x /= i;</span><br><span class="line">                primes[i] ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll res = 0;</span><br><span class="line">    for(auto prime : primes) res = res * (prime.second + 1) % mod;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="③-求约数之和"><a href="#③-求约数之和" class="headerlink" title="③ 求约数之和"></a>③ 求约数之和</h3><p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250126174914523.png" alt="image-20250126174914523"></p>
<p>一样的，我们分解质因数然后按照公式计算即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line">const int N = 1e7;</span><br><span class="line">const int mod = 1e9 + 7;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n; cin &gt;&gt; n;</span><br><span class="line">    unordered_map&lt;int,int&gt;primes; //用来存质因数和它的指数</span><br><span class="line">    while(n --)&#123;</span><br><span class="line">        int x; cin &gt;&gt; x;</span><br><span class="line">        for(int i = 2;i &lt;= n;i ++)&#123;</span><br><span class="line">            while(x % i == 0)&#123;</span><br><span class="line">                x /= i;</span><br><span class="line">                primes[i] ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll res = 0;</span><br><span class="line">    for(auto prime : primes) res = res * (prime.second + 1) % mod;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="③-最大公约数"><a href="#③-最大公约数" class="headerlink" title="③ 最大公约数"></a>③ 最大公约数</h3><p>辗转相除法 欧几里得算法 gcd</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int gcd(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">	return b ? gcd(b,a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="④-扩展欧几里得算法"><a href="#④-扩展欧几里得算法" class="headerlink" title="④ 扩展欧几里得算法"></a>④ 扩展欧几里得算法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 求x, y，使得ax + by = gcd(a, b)</span><br><span class="line">int exgcd(int a, int b, int &amp;x, int &amp;y)</span><br><span class="line">&#123;</span><br><span class="line">    if (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = 1; y = 0;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">    int d = exgcd(b, a % b, y, x);</span><br><span class="line">    y -= (a/b) * x;</span><br><span class="line">    return d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-欧拉函数"><a href="#3-欧拉函数" class="headerlink" title="3.欧拉函数"></a>3.欧拉函数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250218212753454.png" alt="image-20250218212753454"></p>
<h3 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h3><h4 id="1、公式求欧拉函数"><a href="#1、公式求欧拉函数" class="headerlink" title="1、公式求欧拉函数"></a>1、公式求欧拉函数</h4><p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250218213643606.png" alt="image-20250218213643606"></p>
<p>其中第一行是对 N 进行分解质因数的结果</p>
<p>第二行是求欧拉函数的公式</p>
<p>代码实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int a; cin &gt;&gt; a;</span><br><span class="line">    int res = a;</span><br><span class="line">    for(int i = 2;i &lt;= a / i;i ++)&#123;</span><br><span class="line">        if(a % i == 0) &#123;</span><br><span class="line">            res = res / i * (i - 1);</span><br><span class="line">            while(a % i == 0) a /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(a &gt; 1) res = res / a * (a - 1);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h4 id="2、筛法求欧拉函数"><a href="#2、筛法求欧拉函数" class="headerlink" title="2、筛法求欧拉函数"></a>2、筛法求欧拉函数</h4><p>注意，这里是求 1~N 每一个数的欧拉函数</p>
<p>这里以求 1~N 的每个数的欧拉函数之和为例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line">const int N = 1e6 + 10;</span><br><span class="line">int primes[N],cnt;</span><br><span class="line">int phi[N];</span><br><span class="line">bool st[N];</span><br><span class="line"></span><br><span class="line">ll get_eulers(int n)</span><br><span class="line">&#123;</span><br><span class="line">    phi[1] = 1;</span><br><span class="line">    for(int i = 2;i &lt;= n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!st[i]) &#123;</span><br><span class="line">            primes[cnt ++] = i;</span><br><span class="line">            phi[i] = i - 1; // 质数的欧拉函数</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j = 0; primes[j] &lt;= n / i; j ++)&#123;</span><br><span class="line">            st[primes[j] * i] = true;</span><br><span class="line">            if(i % primes[j] == 0) &#123;</span><br><span class="line">                phi[primes[j] * i] = primes[j] * phi[i];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            phi[primes[j] * i] = phi[i] * (primes[j] - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll res = 0;</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++) res += phi[i];</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n; cin &gt;&gt; n;</span><br><span class="line">    get_eulers(n);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-快速幂"><a href="#4-快速幂" class="headerlink" title="4.快速幂"></a>4.快速幂</h2><p>用于快速求出 a 的 k 次方 % p 的结果</p>
<p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250218224555876.png" alt="image-20250218224555876"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 返回a ^ k % p</span><br><span class="line">ll qmi(int a,int k,int p)</span><br><span class="line">&#123;</span><br><span class="line">    int res = 1;</span><br><span class="line">    while(k) &#123;</span><br><span class="line">        if(k &amp; 1) res = (ll)res * a % p;</span><br><span class="line">        k &gt;&gt;= 1;</span><br><span class="line">        a = (ll)a * a % p;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速幂求逆元"><a href="#快速幂求逆元" class="headerlink" title="快速幂求逆元"></a>快速幂求逆元</h3><p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250218224846741.png" alt="image-20250218224846741"></p>
<h2 id="5-高斯消元求线性方程组"><a href="#5-高斯消元求线性方程组" class="headerlink" title="5.高斯消元求线性方程组"></a>5.高斯消元求线性方程组</h2><p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250218230839753.png" alt="image-20250218230839753"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// a[N][N]是增广矩阵</span><br><span class="line">int gauss()</span><br><span class="line">&#123;</span><br><span class="line">    int c, r;</span><br><span class="line">    for (c = 0, r = 0; c &lt; n; c ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        int t = r;</span><br><span class="line">        for (int i = r; i &lt; n; i ++ )   // 找到绝对值最大的行</span><br><span class="line">            if (fabs(a[i][c]) &gt; fabs(a[t][c]))</span><br><span class="line">                t = i;</span><br><span class="line"></span><br><span class="line">        if (fabs(a[t][c]) &lt; eps) continue;</span><br><span class="line"></span><br><span class="line">        for (int i = c; i &lt;= n; i ++ ) swap(a[t][i], a[r][i]);      // 将绝对值最大的行换到最顶端</span><br><span class="line">        for (int i = n; i &gt;= c; i -- ) a[r][i] /= a[r][c];      // 将当前行的首位变成1</span><br><span class="line">        for (int i = r + 1; i &lt; n; i ++ )       // 用当前行将下面所有的列消成0</span><br><span class="line">            if (fabs(a[i][c]) &gt; eps)</span><br><span class="line">                for (int j = n; j &gt;= c; j -- )</span><br><span class="line">                    a[i][j] -= a[r][j] * a[i][c];</span><br><span class="line"></span><br><span class="line">        r ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (r &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = r; i &lt; n; i ++ )</span><br><span class="line">            if (fabs(a[i][n]) &gt; eps)</span><br><span class="line">                return 2; // 无解</span><br><span class="line">        return 1; // 有无穷多组解</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = n - 1; i &gt;= 0; i -- )</span><br><span class="line">        for (int j = i + 1; j &lt; n; j ++ )</span><br><span class="line">            a[i][n] -= a[i][j] * a[j][n];</span><br><span class="line"></span><br><span class="line">    return 0; // 有唯一解</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第五章动态规划"><a href="#第五章动态规划" class="headerlink" title="第五章动态规划"></a>第五章动态规划</h2><h2 id="√-背包问题"><a href="#√-背包问题" class="headerlink" title="√ 背包问题"></a>√ 背包问题</h2><h3 id="1-01-背包问题"><a href="#1-01-背包问题" class="headerlink" title="1.01 背包问题"></a>1.01 背包问题</h3><p>f[i] [j]数组表示前 i 个物品不超过 j 体积的价值数</p>
<p>那么我们可以将 f[i] [j]分为包含第 i 个物品和不包含 i 两种再求一个 max</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/2/">2. 01 背包问题 - AcWing 题库</a></p>
<p>#include <iostream><br> ​<br> using namespace std;<br> ​<br> const int N &#x3D; 1010;<br> ​<br> int n, m;<br> int v[N], w[N];<br> int f[N][N];<br> ​<br> int main()<br> {<br>     cin &gt;&gt; n &gt;&gt; m;</p>
<p>for(int i &#x3D; 1; i &lt;&#x3D; n; i ++)cin &gt;&gt; v[i] &gt;&gt; w[i];</p>
<p>for(int i &#x3D; 1; i &lt;&#x3D; n; i ++)<br>         for(int j &#x3D; 0; j &lt;&#x3D; m; j ++)<br>        {<br>             f[i][j] &#x3D; f[i - 1][j];<br>             if(j &gt;&#x3D; v[i])f[i][j] &#x3D; max(f[i][j], f[i - 1]j - v[i]] + w[i]);<br>        }</p>
<p>cout &lt;&lt; f[n][m];</p>
<p>return 0;<br> }</p>
<p>优化:</p>
<p>我们可以将二维优化成一维</p>
<p>将 j 从大到小这样就保证每个 i 只被选一次</p>
<p>#include <iostream><br> ​<br> using namespace std;<br> ​<br> const int N &#x3D; 1010;<br> ​<br> int n, m;<br> int v[N], w[N];<br> int f[N];<br> ​<br> int main()<br> {<br>     cin &gt;&gt; n &gt;&gt; m;</p>
<p>for(int i &#x3D; 1; i &lt;&#x3D; n; i ++)cin &gt;&gt; v[i] &gt;&gt; w[i];</p>
<p>for(int i &#x3D; 1; i &lt;&#x3D; n; i ++)<br>         for(int j &#x3D; m; j &gt;&#x3D; v[i]; j –)<br>             f[j] &#x3D; max(f[j], f[j - v[i]] + w[i]);</p>
<p>cout &lt;&lt; f[m];</p>
<p>return 0;<br> }</p>
<h3 id="2-完全背包问题"><a href="#2-完全背包问题" class="headerlink" title="2.完全背包问题"></a>2.完全背包问题</h3><p>跟上面的思路差不多</p>
<p>但是此时我们将 f [i] [j]分为包含 0 个 i，1 个 i， 2 个 i……</p>
<p>所以 max 里面应该包含 0 个 i 项， 1 个 i 项……</p>
<p>再进行整理</p>
<p>#include <iostream><br> ​<br> using namespace std;<br> ​<br> const int N &#x3D; 1010;<br> ​<br> int n, m;<br> int v[N], w[N];<br> int f[N][N];<br> ​<br> int main()<br> {<br>  cin &gt;&gt; n &gt;&gt; m;</p>
<p>for(int i &#x3D; 1; i &lt;&#x3D; n; i ++)cin &gt;&gt; v[i] &gt;&gt; w[i];</p>
<p>for(int i &#x3D; 1; i &lt;&#x3D; n; i ++)<br>     for(int j &#x3D; 1; j &lt;&#x3D; m; j ++)<br>    {<br>    f[i][j] &#x3D; f[i - 1][j];<br>    if(j &gt;&#x3D; v[i])f[i][j] &#x3D; max(f[i][j], f[i]j - v[i]] + w[i]);<br>  }</p>
<p>cout &lt;&lt; f[n][m];</p>
<p>return 0;<br>  }</p>
<p>优化：</p>
<p>#include <iostream><br> ​<br> using namespace std;<br> ​<br> const int N &#x3D; 1010;<br> ​<br> int n, m;<br> int v[N], w[N];<br> int f[N];<br> ​<br> int main()<br> {<br>  cin &gt;&gt; n &gt;&gt; m;</p>
<p>for(int i &#x3D; 1; i &lt;&#x3D; n; i ++)cin &gt;&gt; v[i] &gt;&gt; w[i];</p>
<p>for(int i &#x3D; 1; i &lt;&#x3D; n; i ++)<br>     for(int j &#x3D; v[i]; j &lt;&#x3D; m; j ++)<br>    f[j] &#x3D; max(f[j], f[j - v[i]] + w[i]);</p>
<p>cout &lt;&lt; f[m];</p>
<p>return 0;<br>  }</p>
<h3 id="3-多重背包问题（数据小的时候）"><a href="#3-多重背包问题（数据小的时候）" class="headerlink" title="3.多重背包问题（数据小的时候）"></a>3.多重背包问题（数据小的时候）</h3><p>直接暴力枚举</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/4/">4. 多重背包问题 I - AcWing 题库</a></p>
<p>#include <iostream><br> ​<br> using namespace std;<br> ​<br> const int N &#x3D; 110;<br> ​<br> int n, m;<br> int f[N];<br> ​<br> int main()<br> {<br>     cin &gt;&gt; n &gt;&gt; m;<br>     for(int i &#x3D; 0; i &lt; n; i ++)<br>    {<br>         int v, w, s;<br>         cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;<br>         for(int j &#x3D; m; j &gt;&#x3D; 0; j – )<br>             for(int k &#x3D; 1; k &lt;&#x3D; s &amp;&amp; k _ v &lt;&#x3D; j; k ++)<br>                 f[j] &#x3D; max(f[j], f[j - k _ v] + k * w);<br>    }</p>
<p>cout &lt;&lt; f[m];</p>
<p>return 0;<br> }</p>
<h3 id="4-多重背包问题（数据大的时候）"><a href="#4-多重背包问题（数据大的时候）" class="headerlink" title="4.多重背包问题（数据大的时候）"></a>4.多重背包问题（数据大的时候）</h3><p>我们可以将每个数量拆出来变成 01 背包问题</p>
<p>怎么拆使得拆出来的数字个数最小呢？</p>
<p>用二进制的方式拆</p>
<p>#include <iostream><br> #include <vector><br> ​<br> using namespace std;<br> ​<br> const int N &#x3D; 2010;<br> ​<br> int n, m;<br> int f[N];<br> ​<br> struct Good{<br>   int v, w;  <br> };<br> int main()<br> {<br>     vector<Good> goods;<br>     cin &gt;&gt; n &gt;&gt; m;<br>     for(int i &#x3D; 0; i &lt; n; i ++)<br>    {<br>         int v, w, s;<br>         cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;<br>         for(int k &#x3D; 1; k &lt;&#x3D; s; k _&#x3D; 2)<br>        {<br>             s -&#x3D; k;<br>             goods.push_back({v _ k, w _ k}); &#x2F;&#x2F; 二进制的方式拆<br>        }<br>         if(s &gt; 0) goods.push_back({v _ s, w * s}); &#x2F;&#x2F; 将剩下的数放进去<br>    }</p>
<p>&#x2F;&#x2F; 01 背包问题模板<br>     for(auto good : goods)<br>         for(int j &#x3D; m; j &gt;&#x3D; good.v; j –)<br>             f[j] &#x3D; max(f[j], f[j - good.v] + good.w);</p>
<p>cout &lt;&lt; f[m];</p>
<p>return 0;<br> }<br> ​</p>
<h3 id="5-分组背包问题"><a href="#5-分组背包问题" class="headerlink" title="5.分组背包问题"></a>5.分组背包问题</h3><p>多重背包问题是这个的特殊情况</p>
<p>代码思路差不多</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/9/">9. 分组背包问题 - AcWing 题库</a></p>
<p>#include <iostream><br> ​<br> using namespace std;<br> ​<br> const int N &#x3D; 110;<br> ​<br> int n, m;<br> int f[N], v[N], w[N];<br> ​<br> ​<br> int main()<br> {<br>     cin &gt;&gt; n &gt;&gt; m;</p>
<p>for(int i &#x3D; 0; i &lt; n; i ++)<br>    {<br>         int s;<br>         cin &gt;&gt; s;<br>         for(int j &#x3D; 0; j &lt; s; j ++)cin &gt;&gt; v[j] &gt;&gt; w[j];<br>         for(int j &#x3D; m; j &gt;&#x3D; 0; j –)<br>             for(int k &#x3D; 0; k &lt; s; k ++)<br>                 if(j &gt;&#x3D; v[k])<br>                     f[j] &#x3D; max(f[j], f[j - v[k]] + w[k]);<br>    }</p>
<p>cout &lt;&lt; f[m];</p>
<p>return 0;<br> }</p>
<h2 id="线性-DP"><a href="#线性-DP" class="headerlink" title="线性 DP"></a>线性 DP</h2><h3 id="√6-数字三角形"><a href="#√6-数字三角形" class="headerlink" title="√6.数字三角形"></a>√6.数字三角形</h3><p>状态表示+计算</p>
<p>f[i] [j]表示到 i 行 j 列最大值</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/900/">898. 数字三角形 - AcWing 题库</a></p>
<p>#include <iostream><br> ​<br> using namespace std;<br> ​<br> const int N &#x3D; 510, INF&#x3D; 1e9;<br> ​<br> int n;<br> int a[N][N];<br> int f[N][N];<br> ​<br> int main()<br> {<br>     cin &gt;&gt; n;<br>     for(int i &#x3D; 1; i &lt;&#x3D; n; i ++)<br>         for(int j &#x3D; 1;j &lt;&#x3D; i; j ++)<br>             cin &gt;&gt; a[i][j];</p>
<p>for(int i &#x3D; 0; i &lt;&#x3D; n; i ++)<br>         for(int j &#x3D; 0; j &lt;&#x3D; i + 1; j ++)<br>             f[i][j] &#x3D; -INF;</p>
<p>f[1][1] &#x3D; a[1][1];<br>     for(int i &#x3D; 2; i &lt;&#x3D; n; i ++)<br>         for(int j &#x3D; 1; j &lt;&#x3D; i ; j ++)<br>             f[i][j] &#x3D; max(f[i - 1][j - 1] + a[i][j], f[i - 1][j] + a[i][j]);</p>
<p>int res &#x3D; -INF;        <br>     for(int i &#x3D; 1; i &lt;&#x3D; n; i ++)res &#x3D; max(res, f[n][i]);</p>
<p>cout &lt;&lt; res;</p>
<p>return 0;<br> }</p>
<h3 id="√7-最长上升子序列（数据小时）"><a href="#√7-最长上升子序列（数据小时）" class="headerlink" title="√7.最长上升子序列（数据小时）"></a>√7.最长上升子序列（数据小时）</h3><p>f[i] 为以 i 为结尾的最长的长度</p>
<p>那么就可以得到他的最长长度等于 0 …i - 1 中比 a[i]小的数的 f 值加 1 再跟 i 取 max</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/897/">895. 最长上升子序列 - AcWing 题库</a></p>
<p>#include <iostream><br> ​<br> using namespace std;<br> ​<br> const int N &#x3D; 1010;<br> ​<br> int n;<br> int a[N], f[N];<br> ​<br> int main()<br> {<br>     cin &gt;&gt; n;</p>
<p>for(int i &#x3D; 1; i &lt;&#x3D; n; i ++) cin &gt;&gt; a[i];</p>
<p>for(int i &#x3D; 1; i &lt;&#x3D; n; i ++)<br>    {<br>         f[i] &#x3D; 1;<br>         for(int j &#x3D; 1; j &lt; i; j ++)<br>             if(a[j] &lt; a[i])<br>                 f[i] &#x3D; max(f[i], f[j] + 1);<br>    }</p>
<p>int res &#x3D; 0;</p>
<p>for(int i &#x3D; 1; i &lt;&#x3D; n ; i ++) res &#x3D; max(res, f[i]);</p>
<p>cout &lt;&lt; res;</p>
<p>return 0;<br> }</p>
<h3 id="√8-最长上升子序列（数据大时）"><a href="#√8-最长上升子序列（数据大时）" class="headerlink" title="√8.最长上升子序列（数据大时）"></a>√8.最长上升子序列（数据大时）</h3><p>先弄出每个长度子序列的最小值</p>
<p>枚举每个数把他接到小于他的最长的子序列这样就使得出来的子序列最长</p>
<p>用二分的方法找到小于他的最长的子序列</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/898/">896. 最长上升子序列 II - AcWing 题库</a></p>
<p>#include <iostream><br> ​<br> using namespace std;<br> ​<br> const int N &#x3D; 100010;<br> ​<br> int n;<br> int a[N];<br> int q[N]; &#x2F;&#x2F; q 存储每个上升子序列长度结尾的数的最小值<br> ​<br> int main()<br> {<br>     cin &gt;&gt; n;</p>
<p>for(int i &#x3D; 0; i &lt; n; i ++) cin &gt;&gt; a[i];</p>
<p>int len &#x3D; 0; &#x2F;&#x2F; 最大长度（也是当前最长的子序列长度）<br>     q[0] &#x3D; -2e9;</p>
<p>for(int i &#x3D; 0; i &lt; n; i ++)<br>    {<br>         int l &#x3D; 0, r &#x3D; len;<br>         while(l &lt; r)<br>        {<br>             int mid &#x3D; l + r + 1&gt;&gt; 1;<br>             if(q[mid] &lt; a[i]) l &#x3D; mid;<br>             else r &#x3D; mid - 1;<br>        }<br>         len &#x3D; max(len, r + 1);<br>         q[r + 1] &#x3D; a[i];<br>    }</p>
<p>cout &lt;&lt; len;</p>
<p>return 0;</p>
<p>}</p>
<h3 id="9-最长公共子序列"><a href="#9-最长公共子序列" class="headerlink" title="9.最长公共子序列"></a>9.最长公共子序列</h3><p>f[i] [j]表示所有 a[1….i]和 b[1….i]中公共子序列的集合的最大值</p>
<p>那么可以分为包含 a[i]不包含 b[j]包含 a[i]包含 b[j]等等四个</p>
<p>四个发现可以整合成三个</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/899/">897. 最长公共子序列 - AcWing 题库</a></p>
<p>#include <iostream><br> ​<br> using namespace std;<br> ​<br> const int N &#x3D; 1010;<br> ​<br> int n, m;<br> char a[N], b[N];<br> int f[N][N];<br> ​<br> int main()<br> {<br>     cin &gt;&gt; n &gt;&gt; m &gt;&gt; a + 1 &gt;&gt; b + 1;</p>
<p>for(int i &#x3D; 1; i &lt;&#x3D; n; i ++)<br>         for(int j &#x3D; 1; j &lt;&#x3D; m; j ++)<br>        {<br>             f[i][j] &#x3D; max(f[i - 1][j], f[i][j - 1]);<br>             if(a[i] &#x3D;&#x3D; b[j]) f[i][j] &#x3D; max(f[i][j], f[i - 1][j - 1] + 1);<br>        }</p>
<p>cout &lt;&lt; f[n][m];</p>
<p>return 0;</p>
<p>}</p>
<h3 id="10-最短编辑距离"><a href="#10-最短编辑距离" class="headerlink" title="10.最短编辑距离"></a>10.最短编辑距离</h3><p>f[i] [j]表示将 a[i…i]变成 b[1…j]的所有方式的最小值</p>
<p>根据题意分三步</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/904/">902. 最短编辑距离 - AcWing 题库</a></p>
<p>#include <iostream><br> ​<br> using namespace std;<br> ​<br> const int N &#x3D; 1010;<br> ​<br> int n, m;<br> char a[N], b[N];<br> int f[N][N];<br> ​<br> int main()<br> {<br>     cin &gt;&gt; n &gt;&gt; a + 1;<br>     cin &gt;&gt; m &gt;&gt; b + 1;</p>
<p>for(int i &#x3D; 0; i &lt;&#x3D; m; i ++) f[0][i] &#x3D; i;<br>     for(int i &#x3D; 0; i &lt;&#x3D; n; i ++) f[i][0] &#x3D; i;</p>
<p>for(int i &#x3D; 1; i &lt;&#x3D; n; i ++)<br>         for(int j &#x3D; 1; j &lt;&#x3D; m; j ++)<br>        {<br>             f[i][j] &#x3D; min(f[i - 1][j] + 1, f[i][j - 1] + 1);<br>             if(a[i] &#x3D;&#x3D; b[j]) f[i][j] &#x3D; min(f[i][j], f[i - 1][j - 1]);<br>             else f[i][j] &#x3D; min(f[i][j], f[i - 1][j - 1] + 1);<br>        }</p>
<p>cout &lt;&lt; f[n][m];</p>
<p>return 0;</p>
<p>}</p>
<h2 id="区间-DP"><a href="#区间-DP" class="headerlink" title="区间 DP"></a>区间 DP</h2><h3 id="11-石子合并"><a href="#11-石子合并" class="headerlink" title="11.石子合并"></a>11.石子合并</h3><p>f[i] [j]表示合并第 i 到 j 堆石子的代价最小值</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/284/">282. 石子合并 - AcWing 题库</a></p>
<p>#include <iostream><br> ​<br> using namespace std;<br> ​<br> const int N &#x3D; 310;<br> ​<br> int n;<br> int s[N];<br> int f[N][N];<br> ​<br> int main()<br> {</p>
<p>cin &gt;&gt; n;<br>  for(int i  &#x3D; 1; i &lt;&#x3D; n; i ++) cin &gt;&gt; s[i], s[i] +&#x3D; s[i - 1];</p>
<p>for(int len &#x3D; 2; len &lt;&#x3D; n; len ++)<br>     for(int i &#x3D; 1; i + len - 1 &lt;&#x3D; n; i ++)<br>    {<br>    int j &#x3D; i + len - 1;<br>    f[i][j] &#x3D; 1e8;<br>    for(int k &#x3D; i; k &lt; j; k ++)<br>       f[i][j] &#x3D; min(f[i][j], f[i][k] + f[k + 1][j] + s[j] - s[i - 1]);<br>  }</p>
<p>cout &lt;&lt; f[1][n];</p>
<p>return 0;<br> }</p>
<h2 id="计数类-DP"><a href="#计数类-DP" class="headerlink" title="计数类 DP"></a>计数类 DP</h2><h3 id="12-整数划分"><a href="#12-整数划分" class="headerlink" title="12.整数划分"></a>12.整数划分</h3><p>可以发现他就是一个完全背包问题</p>
<p>f[i] [j]表示 1…i 中选总数恰好是 j</p>
<p>而 f[i] [j]恰好可以优化成跟 f[i] [j - 1]有关</p>
<p>再进行优化</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/902/">900. 整数划分 - AcWing 题库</a></p>
<p>#include <iostream><br> ​<br> using namespace std;<br> ​<br> const int N &#x3D; 1010, mod &#x3D; 1e9 + 7;<br> ​<br> int n;<br> int f[N];<br> ​<br> int main()<br> {<br>  cin &gt;&gt; n;</p>
<p>f[0] &#x3D; 1;<br>  for(int i &#x3D; 1; i &lt;&#x3D; n; i ++)<br>     for(int j &#x3D; i; j &lt;&#x3D; n; j ++)<br>         f[j] &#x3D; (f[j]  +f[j - i]) % mod;</p>
<p>cout &lt;&lt; f[n];</p>
<p>return 0;<br> }</p>
<h2 id="数位统计-DP"><a href="#数位统计-DP" class="headerlink" title="数位统计 DP"></a>数位统计 DP</h2><h3 id="13-计数问题"><a href="#13-计数问题" class="headerlink" title="13.计数问题"></a>13.计数问题</h3><p>分类讨论</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/340/">338. 计数问题 - AcWing 题库</a></p>
<p>#include <iostream><br> #include <vector><br> ​<br> using namespace std;<br> ​<br> int get(vector<int> num, int l, int r) &#x2F;&#x2F; num 数组中 r 到 l 的数<br> {<br>     int res &#x3D; 0;<br>     for(int i &#x3D; l; i &gt;&#x3D; r; i –)<br>         res &#x3D; res _ 10 + num[i];<br>     return res;<br> }<br> ​<br> int power10(int x) &#x2F;&#x2F; 求 10 的 x 次方<br> {<br>     int res &#x3D; 1;<br>     while(x –) res _&#x3D; 10;<br>     return res;<br> }<br> ​<br> int count(int n, int x) &#x2F;&#x2F; 表示前 n 个数中 x 在每一位出现的次数<br> {<br>     if(!n) return 0;</p>
<p>vector<int> num;<br>     while(n)<br>    {<br>         num.push_back(n % 10);<br>         n &#x2F;&#x3D; 10;<br>    }</p>
<p>n &#x3D; num.size();</p>
<p>int res &#x3D; 0;<br>     for(int i &#x3D; n - 1 - !x; i &gt;&#x3D; 0; i –)<br>    {<br>         if(i &lt; n - 1)<br>        {<br>             res +&#x3D; get(num, n - 1, i + 1) * power10(i);<br>             if(!x) res -&#x3D; power10(i);<br>        }</p>
<p>if(num[i] &#x3D;&#x3D; x) res +&#x3D; get(num, i - 1, 0) + 1;<br>          else if(num[i] &gt; x) res +&#x3D; power10(i);<br>    }</p>
<p>return res;<br> }<br> ​<br> int main()<br> {<br>     int a, b;<br>     while(cin &gt;&gt; a &gt;&gt; b, a || b)<br>    {<br>         if(a &gt; b) swap(a, b);</p>
<p>for(int i &#x3D; 0; i &lt; 10; i ++)<br>             cout &lt;&lt; count(b, i) - count (a - 1, i) &lt;&lt; ‘ ‘;<br>         cout &lt;&lt; endl;<br>    }</p>
<p>return 0;<br> }</p>
<h2 id="状态压缩-DP"><a href="#状态压缩-DP" class="headerlink" title="状态压缩 DP"></a>状态压缩 DP</h2><h3 id="14-蒙德里安的梦想"><a href="#14-蒙德里安的梦想" class="headerlink" title="14.蒙德里安的梦想"></a>14.蒙德里安的梦想</h3><p>​</p>
<h3 id="15-最短-Hamilton-路径"><a href="#15-最短-Hamilton-路径" class="headerlink" title="15.最短 Hamilton 路径"></a>15.最短 Hamilton 路径</h3><p>f[i] [j]表示经过了 i 里面的点现在在 j 点（i 表示一个数组用二进制表示 1 为经过 0 表示不经过）</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/93/">91. 最短 Hamilton 路径 - AcWing 题库</a></p>
<p>#include <iostream><br> #include <cstring><br> ​<br> using namespace std;<br> ​<br> const int N &#x3D; 20, M &#x3D; 1 &lt;&lt; 20;<br> ​<br> int n;<br> int f[M][N], weight[N][N];<br> ​<br> int main()<br> {<br>     &#x2F;&#x2F; 读入数据<br>     cin &gt;&gt; n;<br>     for(int i &#x3D; 0; i &lt; n; i ++)<br>         for(int j &#x3D; 0; j &lt; n; j ++)<br>             cin &gt;&gt; weight[i][j];</p>
<p>memset(f, 0x3f, sizeof f);<br>     f[1][0] &#x3D; 0;</p>
<p>for(int i &#x3D; 0; i &lt; 1 &lt;&lt; n; i ++)<br>         for(int j &#x3D; 0; j &lt; n; j ++)<br>             if(i &gt;&gt; j &amp; 1) &#x2F;&#x2F; 判断 j 这个点是否经过<br>                 for(int k &#x3D; 0; k &lt; n; k ++) &#x2F;&#x2F; DP<br>                     if(i - (1 &lt;&lt; j) &gt;&gt; k &amp; 1) &#x2F;&#x2F; 这里（1 &lt;&lt; j）没有也行主要是一个内在原理见上图<br>                         f[i][j] &#x3D; min(f[i][j], f[i - (1 &lt;&lt; j)][k] + weight[k][j]);</p>
<p>cout &lt;&lt; f[(1 &lt;&lt; n) - 1][n - 1] &lt;&lt; endl;<br>     return 0;<br> }</p>
<h2 id="树形-DP"><a href="#树形-DP" class="headerlink" title="树形 DP"></a>树形 DP</h2><h3 id="16-没有上司的舞会"><a href="#16-没有上司的舞会" class="headerlink" title="16.没有上司的舞会"></a>16.没有上司的舞会</h3><p>两个状态 f[u] [0]表示从 u 为根的子树中选，不选 u 这个方案的值 f[u] [1]表示从 u 为根的子树中选，选择 u 这个点的方案</p>
<p>将两个取 max 则为答案</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/287/">285. 没有上司的舞会 - AcWing 题库</a></p>
<p>#include <iostream><br> #include <cstring><br> ​<br> using namespace std;<br> ​<br> const int N &#x3D; 6010;<br> ​<br> int n;<br> int happy[N];<br> int h[N], e[N], ne[N], idx;<br> int f[N][2];<br> bool has_father[N];<br> ​<br> void add(int a, int b)<br> {<br>     e[idx] &#x3D; b, ne[idx] &#x3D; h[a], h[a] &#x3D; idx ++;<br> }<br> ​<br> void dfs(int u)<br> {<br>     f[u][1] &#x3D; happy[u];</p>
<p>for(int i &#x3D; h[u]; i !&#x3D; -1; i &#x3D; ne[i])<br>    {<br>         int j &#x3D; e[i];<br>         dfs(j);</p>
<p>f[u][0] +&#x3D; max(f[j][0], f[j][1]);<br>         f[u][1] +&#x3D; f[j][0];<br>    }<br> }<br> ​<br> int main()<br> {<br>     cin &gt;&gt; n;<br>     for(int i &#x3D; 1; i &lt;&#x3D; n; i ++) cin &gt;&gt; happy[i];</p>
<p>memset(h, -1, sizeof h);<br>     for(int i &#x3D; 0; i &lt; n - 1; i ++)<br>    {<br>         int a, b;<br>         cin &gt;&gt; a &gt;&gt; b;<br>         has_father[a] &#x3D; true;<br>         add(b, a);<br>    }</p>
<p>int root &#x3D; 1;<br>     while(has_father[root]) root ++;</p>
<p>dfs(root);</p>
<p>cout &lt;&lt;  max(f[root][0], f[root][1]);</p>
<p>return 0;<br> }</p>
<h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><h3 id="17-滑雪"><a href="#17-滑雪" class="headerlink" title="17.滑雪"></a>17.滑雪</h3><p>f[i] [j] 表示从当前位置滑经过路径的最大值</p>
<p>显然 f[i] [j] 等于下一个路径的 f 值加一</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/903/">901. 滑雪 - AcWing 题库</a></p>
<p>#include <iostream><br> #include <cstring><br> ​<br> using namespace std;<br> ​<br> const int N &#x3D; 310;<br> ​<br> int n, m;<br> int h[N][N];<br> int f[N][N];<br> ​<br> int dx[4] &#x3D; {-1, 0, 1, 0}, dy[4] &#x3D; {0, 1, 0, -1};<br> ​<br> int dp(int x, int y)<br> {<br>     int &amp;v &#x3D; f[x][y];<br>     if(v !&#x3D; -1) return v;</p>
<p>v &#x3D; 1;<br>     for(int i &#x3D; 0; i &lt; 4; i ++)<br>    {<br>         int a &#x3D; x + dx[i], b &#x3D; y + dy[i];<br>         if(a &gt;&#x3D; 1 &amp;&amp; a &lt;&#x3D; n &amp;&amp; b &gt;&#x3D; 1 &amp;&amp; b &lt;&#x3D; m &amp;&amp; h[a][b] &lt; h[x][y])<br>             v &#x3D; max(v, dp(a, b) + 1);<br>    }</p>
<p>return v;<br> }<br> ​<br> int main()<br> {<br>     cin &gt;&gt; n &gt;&gt; m;</p>
<p>for(int i &#x3D; 1; i &lt;&#x3D; n; i ++)<br>         for(int j &#x3D; 1; j &lt;&#x3D; m; j ++)<br>             cin &gt;&gt; h[i][j];</p>
<p>memset(f, -1, sizeof f);</p>
<p>int res &#x3D; 0;<br>     for(int i &#x3D; 1; i &lt;&#x3D; n; i ++)<br>         for(int j &#x3D; 1; j &lt;&#x3D; m; j ++)<br>             res &#x3D; max(res, dp(i, j));</p>
<p>cout &lt;&lt; res;</p>
<p>return 0;<br> }</p>
<h1 id="第六章贪心"><a href="#第六章贪心" class="headerlink" title="第六章贪心"></a>第六章贪心</h1><h2 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h2><h3 id="1-区间选点"><a href="#1-区间选点" class="headerlink" title="1.区间选点"></a>1.区间选点</h3><p>主要思路：</p>
<p>1.是将每个区间按右端点排序</p>
<p>2.枚举每个区间若当前区间已包含点则下一个 若没有则右端点为一个点</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/907/">905. 区间选点 - AcWing 题库</a></p>
<p>#include <iostream><br> #include <algorithm><br> ​<br> using namespace std;<br> ​<br> const int N &#x3D; 100010;<br> ​<br> int n;<br> struct Range<br> {<br>     int l, r;<br>     bool operator&lt; (const Range &amp;W)const<br>    {<br>         return r &lt; W.r;<br>    }<br> }range[N];<br> ​<br> int main()<br> {</p>
<p>cin &gt;&gt; n;<br>     for(int i &#x3D; 0; i &lt; n; i ++)<br>    {<br>         int l, r;<br>         cin &gt;&gt; l &gt;&gt; r;<br>         range[i] &#x3D; {l, r};<br>    }</p>
<p>sort(range, range + n);</p>
<p>int res &#x3D; 0, ed &#x3D; -2e9;<br>     for(int i &#x3D; 0; i &lt; n; i ++)<br>         if(range[i].l &gt; ed)<br>        {<br>             res ++;<br>             ed &#x3D; range[i].r;<br>        }</p>
<p>cout &lt;&lt; res;</p>
<p>return 0;<br> }</p>
<h3 id="2-区间分组"><a href="#2-区间分组" class="headerlink" title="2.区间分组"></a>2.区间分组</h3><p>将区间按左端点排序</p>
<p>如果当前区间的左端点大于已有组区间的右端点则放在组里</p>
<p>否则开个新组</p>
<p>因此当前区间的左端点拿去跟组里面的最小右端点比就行了</p>
<p>所以就可以用小根堆</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/908/">906. 区间分组 - AcWing 题库</a></p>
<p>#include <iostream><br> #include <algorithm><br> #include <queue><br> ​<br> using namespace std;<br> ​<br> const int N &#x3D; 100010;<br> ​<br> int n;<br> struct Range<br> {<br>     int l, r;<br>     bool operator&lt; (const Range &amp;W)const<br>    {<br>         return l &lt; W.l;<br>    }<br> }range[N];<br> ​<br> int main()<br> {<br>     cin &gt;&gt; n;<br>     for(int i &#x3D; 0; i &lt; n; i ++)<br>    {<br>         int l, r;<br>         cin &gt;&gt; l &gt;&gt; r;<br>         range[i] &#x3D; {l, r};<br>    }</p>
<p>sort(range, range + n);</p>
<p>priority_queue&lt;int, vector<int>, greater<int>&gt; heap;<br>     for(int i &#x3D; 0; i &lt; n; i ++)<br>    {<br>         auto r &#x3D; range[i];<br>         if(heap.empty() || heap.top() &gt;&#x3D; r.l) heap.push(r. r);<br>         else<br>        {<br>             int t &#x3D; heap.top();<br>             heap.pop();<br>             heap.push(r.r);<br>        }<br>    }</p>
<p>cout &lt;&lt; heap.size();</p>
<p>return 0;<br> }</p>
<h3 id="3-区间覆盖"><a href="#3-区间覆盖" class="headerlink" title="3.区间覆盖"></a>3.区间覆盖</h3><p>1.将左端点进行排序</p>
<p>2.找到覆盖线段左端点最长的区间</p>
<p>3.将区间右端点变成一个新的线段左端点重复上面第二步</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/909/">907. 区间覆盖 - AcWing 题库</a></p>
<p>#include <iostream><br> #include <algorithm><br> ​<br> using namespace std;<br> ​<br> const int N &#x3D; 100010;<br> ​<br> int n;<br> struct Range<br> {<br>     int l, r;<br>     bool operator&lt; (const Range &amp;W)const<br>    {<br>         return l &lt; W.l;<br>    }<br> }range[N];<br> ​<br> int main()<br> {<br>     int st, ed;<br>     cin &gt;&gt; st &gt;&gt; ed;<br> ​<br>     cin &gt;&gt; n;<br>     for(int i &#x3D; 0; i &lt; n; i ++)<br>    {<br>         int l, r;<br>         cin &gt;&gt; l &gt;&gt; r;<br>         range[i] &#x3D; {l, r};<br>    }</p>
<p>sort(range, range + n);</p>
<p>int res &#x3D; 0;<br>     bool success &#x3D; false;<br>     for(int i &#x3D; 0; i &lt; n; i ++)<br>    {<br>         int j &#x3D; i, r &#x3D; -2e9;<br>         while(j &lt; n &amp;&amp; range[j].l &lt;&#x3D; st)<br>        {<br>             r &#x3D; max(r, range[j].r);<br>             j ++;<br>        }</p>
<p>if(r &lt; st)<br>        {<br>             res &#x3D; -1;<br>             break;<br>        }</p>
<p>res ++;<br>         if(r &gt;&#x3D; ed)<br>        {<br>             success &#x3D; true;<br>             break;<br>        }</p>
<p>st &#x3D; r;<br>         i &#x3D; j - 1;<br>    }</p>
<p>if(!success)res &#x3D; -1;<br>     cout &lt;&lt; res;</p>
<p>return 0;<br> }</p>
<h2 id="Huffman-树"><a href="#Huffman-树" class="headerlink" title="Huffman 树"></a>Huffman 树</h2><h3 id="4-合并果子"><a href="#4-合并果子" class="headerlink" title="4.合并果子"></a>4.合并果子</h3><p>每次合并最小的果子</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/150/">148. 合并果子 - AcWing 题库</a></p>
<p>#include <iostream><br> #include <queue><br> ​<br> using namespace std;<br> ​<br> int main()<br> {<br>     int n;</p>
<p>cin &gt;&gt; n;<br>     priority_queue&lt;int, vector<int>, greater<int> &gt; heap;</p>
<p>for(int i &#x3D; 0; i &lt; n; i ++)<br>    {<br>         int x;<br>         cin &gt;&gt; x;<br>         heap.push(x);<br>    }</p>
<p>int res &#x3D; 0;<br>     while(heap.size() &gt; 1)<br>    {<br>         int a &#x3D; heap.top(); heap.pop();<br>         int b &#x3D; heap.top(); heap.pop();<br>         res +&#x3D; a + b;<br>         heap.push(a + b);<br>    }<br>     cout &lt;&lt; res;<br> }</p>
<h2 id="排序不等式"><a href="#排序不等式" class="headerlink" title="排序不等式"></a>排序不等式</h2><h3 id="5-打水问题"><a href="#5-打水问题" class="headerlink" title="5.打水问题"></a>5.打水问题</h3><p>从小到大排序</p>
<p>让花费时间最少的先打</p>
<p>代码就不写了</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/915/">913. 排队打水 - AcWing 题库</a></p>
<h2 id="绝对值不等式"><a href="#绝对值不等式" class="headerlink" title="绝对值不等式"></a>绝对值不等式</h2><h3 id="6-货仓选址"><a href="#6-货仓选址" class="headerlink" title="6.货仓选址"></a>6.货仓选址</h3><p>就选中间就行了</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/106/">104. 货仓选址 - AcWing 题库</a></p>
<p>#include <iostream><br> #include <algorithm><br> ​<br> using namespace std;<br> ​<br> const int N &#x3D; 100010;<br> ​<br> int n;<br> int a[N];<br> ​<br> int main()<br> {<br>     cin &gt;&gt; n;<br>     for(int i &#x3D; 0; i &lt; n; i ++) cin &gt;&gt; a[i];</p>
<p>sort(a, a + n);<br>     int res &#x3D; 0;<br>     for(int i &#x3D; 0; i &lt; n; i ++) res +&#x3D; abs(a[i] - a[n &#x2F; 2]);<br>     cout &lt;&lt; res;</p>
<p>return 0;<br> }</p>
<h2 id="推公式"><a href="#推公式" class="headerlink" title="推公式"></a>推公式</h2><h3 id="7-耍杂技的牛"><a href="#7-耍杂技的牛" class="headerlink" title="7.耍杂技的牛"></a>7.耍杂技的牛</h3><p>我们先随便排序</p>
<p>发现将第 i 个和第 i + 1 个交换后 如果 Wi + Si &gt; Wi+1 + Si+1 那么就会使这两个交换后风险值变小</p>
<p>由局部推导全局</p>
<p>则这个顺序是升序的</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/127/">125. 耍杂技的牛 - AcWing 题库</a></p>
<p>#include &lt;limits.h&gt;<br> #include <iostream><br> #include <algorithm><br> ​<br> using namespace std;<br> ​<br> typedef pair&lt;int, int&gt; PII;<br> ​<br> const int N &#x3D; 50010;<br> ​<br> int n;<br> PII cows[N];<br> ​<br> int main()<br> {<br>     cin &gt;&gt; n;<br>     for(int i &#x3D; 0; i &lt; n; i ++)<br>    {<br>         int w, s;<br>         cin &gt;&gt; w &gt;&gt; s;<br>         cows[i] &#x3D; {w + s, w};<br>    }</p>
<p>sort(cows, cows + n);</p>
<p>int sum &#x3D; 0, res &#x3D; INT_MIN;<br>     for(int i &#x3D; 0; i &lt; n; i ++)<br>    {<br>         int w &#x3D; cows[i].second, s &#x3D; cows[i].first - w;<br>         res &#x3D; max(res, sum - s);<br>         sum +&#x3D; w;<br>    }</p>
<p>cout &lt;&lt; res;</p>
<p>return 0;<br> }</p>
<h2 id="刷题总结"><a href="#刷题总结" class="headerlink" title="刷题总结"></a>刷题总结</h2><h2 id="方法技巧总结"><a href="#方法技巧总结" class="headerlink" title="方法技巧总结"></a>方法技巧总结</h2><h3 id="在句子字符串中对单词的处理"><a href="#在句子字符串中对单词的处理" class="headerlink" title="在句子字符串中对单词的处理"></a>在句子字符串中对单词的处理</h3><p>（句子字符串代指所有其中含有空格或换行符的字符串）</p>
<h4 id="读入问题"><a href="#读入问题" class="headerlink" title="读入问题"></a>读入问题</h4><ol>
<li><p>对 char a[N]类型的字符数组的读入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fgets(a,sizeof a,stdin);</span><br><span class="line">//stdin表示从键盘中读入</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 c++中对 string a 的读入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getline(cin,a);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在已知单词数目的情况下直接逐个读入单词</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">	string a;</span><br><span class="line">	cin &gt;&gt; a;</span><br><span class="line">&#125;</span><br><span class="line">//n是字符串中单词的数目，每次读入的a就是其中的单个的单词</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="逐个分析单词"><a href="#逐个分析单词" class="headerlink" title="逐个分析单词"></a>逐个分析单词</h4><p>使用字符串流来分割句子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sstream&gt;</span><br><span class="line">istringstream iss(a);</span><br><span class="line">string word;</span><br><span class="line">while(iss &gt;&gt; word)</span><br><span class="line">&#123;</span><br><span class="line">	//在这个循环中可以对每一个单词进行处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方法三读入可以直接在循环中逐个分析单词</p>
<h3 id="string-中-find-函数的使用"><a href="#string-中-find-函数的使用" class="headerlink" title="string 中 find 函数的使用"></a>string 中 find 函数的使用</h3><p>find 的原型如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size_t find(const string&amp; str, size_t pos = 0) const noexcept;</span><br></pre></td></tr></table></figure>

<p>其中 str 是要查找的子字符串，pos 是开始查找的位置，默认为 0(pos 在 find 函数中可以省略)</p>
<p>返回值：如果找到子字符串，返回子字符串的第一个字符在原字符串中的位置；如果没有找到，返回 npos（一个常数）</p>
<p>一般的用法如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//比如我们要查找的子字符串是lec</span><br><span class="line">string sentence;</span><br><span class="line">string temp = &quot;lec&quot;;</span><br><span class="line">auto weizhi = sentence.find(temp,0);</span><br></pre></td></tr></table></figure>

<h3 id="方格图小技巧"><a href="#方格图小技巧" class="headerlink" title="方格图小技巧"></a>方格图小技巧</h3><h4 id="1-分析上下左右"><a href="#1-分析上下左右" class="headerlink" title="1.分析上下左右"></a>1.分析上下左右</h4><p>在分析一个点上下左右的坐标时，我们可以先写出上下左右的四个向量，在需要分析时直接循环加上即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int D[4][2] = &#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;.&#123;0,1&#125;&#125;;</span><br><span class="line">int x,y;//假设x，y即为现在节点的横纵坐标</span><br><span class="line"></span><br><span class="line">for(int i = 0;i &lt; 4;i ++)</span><br><span class="line">&#123;</span><br><span class="line">	int xx = x + D[i][0]; int yy = y + D[i][1];</span><br><span class="line">	//后续直接对点（xx，yy）进行分析即可</span><br><span class="line">	//这样就可以在一个循环中处理上下左右四个点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-对角线的表示"><a href="#2-对角线的表示" class="headerlink" title="2.对角线的表示"></a>2.对角线的表示</h4><p>对于一个 n*n 的矩形方格图，我们用每条对角线的纵截距 b 来作为它的编号，则</p>
<p>对于点（u，i），它所在的对角线分别是 d[u+i]和 d[i-u+n]</p>
<p>这里加上 n 是给它一个偏移量让数组的下标始终是大于 0 的</p>
<h4 id="3-方格图中信息变字符串"><a href="#3-方格图中信息变字符串" class="headerlink" title="3.方格图中信息变字符串"></a>3.方格图中信息变字符串</h4><p>把一个 n*m 的矩形方格图中的量按顺序写进字符串中，那么方格图中的某个元素（x，y）和其在字符串中的位置 k 存在这样的关系</p>
<p>$ x &#x3D; \left\lfloor \frac{k}{n} \right\rfloor $ &#x2F;&#x2F;代表向下取整</p>
<p>$ y &#x3D; k % n $</p>
<p>注意这里的矩形必须是从行到列遍历的</p>
<h3 id="货仓选址小结论"><a href="#货仓选址小结论" class="headerlink" title="货仓选址小结论"></a>货仓选址小结论</h3><p>在一条数轴上有 n 个商店坐标分别为 a[0]~a[n-1]，当且仅当货仓建在这个数组的中位数的位置上时，货仓到每家店的距离之和最小。</p>
<h3 id="什么时候用-DFS"><a href="#什么时候用-DFS" class="headerlink" title="什么时候用 DFS"></a>什么时候用 DFS</h3><p>那什么时候可以用到 DFS 呢？总结来说，当问题需要枚举所有可能的解，并且问题的结构适合逐步构建解的时候，可以考虑 DFS。例如排列问题、组合问题、路径问题等。在这种情况下，DFS 通过递归或者栈的方式，尝试每一种可能的选择，并回溯到上一步尝试其他选择，直到找到解或者遍历完所有可能性。</p>
<p>即如果我们想要枚举一下答案的某一种情况然后对于每一种情况判断其合法性的话我们就可以用 dfs</p>
<p>虽然是一种暴力搜索 但是面对数据量较小的时候还是能很好地解决问题</p>
<p>当我们有想法想要把所有的方案都枚举出来找合法解的时候 就可以想想能不能 dfs</p>
<h3 id="统计出现次数"><a href="#统计出现次数" class="headerlink" title="统计出现次数"></a>统计出现次数</h3><p>当需要统计某些元素的出现次数时，可以用以下几种数据结构</p>
<p><strong>map set 哈希</strong></p>
<p>map 可以通过键对关系储存每一种元素的出现次数 可以避免重复的情况 好处是可以直接通过键对值得到元素的出现次数</p>
<p>set 可以直接把元素塞进去 不用考虑是否重复 因为最后只会留下不同的元素 好处是插入后的元素是默认从小到大排序的</p>
<p>但坏处是如果要记录次数的话 还需要另外开一个 map 来记载一下出现次数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set&lt;int&gt; a;</span><br><span class="line">a.insert(); a.size(); a.empty(); a.clear(); a.find(); //find函数跟其他地方一样 如果没有找到还是返回end()迭代器</span><br><span class="line">//可以用for循环遍历set</span><br><span class="line">for(int num : a)</span><br></pre></td></tr></table></figure>

<p>哈希我不太常用 先略去</p>
<h3 id="关于倍数问题的小结论"><a href="#关于倍数问题的小结论" class="headerlink" title="关于倍数问题的小结论"></a>关于倍数问题的小结论</h3><p><strong>两个数 a,b，如果(a - b) % c &#x3D;&#x3D; 0 那么一定有 a % c &#x3D;&#x3D; b % c</strong></p>
<p>依靠这个结论 可以避免全部枚举 只需要记录余数相同的位置即可 具体可以看下面的题 （P3131）</p>
<h3 id="DFS-的两种应用"><a href="#DFS-的两种应用" class="headerlink" title="DFS 的两种应用"></a>DFS 的两种应用</h3><h4 id="DFS-求连通块"><a href="#DFS-求连通块" class="headerlink" title="DFS 求连通块"></a>DFS 求连通块</h4><p>可以理解为 洪水从外到内渗透 统计渗透不到的点 可以用染色法解决 即我们把所有可以搜索到的点都进行染色 最后没有被染色的点就是需要求的点 下面是两道例题</p>
<p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250408110315030.png" alt="image-20250408110315030"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> a[<span class="number">510</span>][<span class="number">510</span>];</span><br><span class="line"><span class="type">int</span> m,n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    a[x][y] = <span class="number">1</span>; <span class="comment">// 能被搜索到的地方进行染色</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i ++)&#123; <span class="comment">//向四周蔓延</span></span><br><span class="line">        <span class="type">int</span> x0 = x + dx[i]; <span class="type">int</span> y0 = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span>(x0 &gt;= <span class="number">0</span> &amp;&amp; x0 &lt; n &amp;&amp; y0 &gt;= <span class="number">0</span> &amp;&amp; y0 &lt; m &amp;&amp; a[x0][y0] == <span class="number">0</span> ) <span class="built_in">dfs</span>(x0,y0); <span class="comment">// 起点变为下一个可以搜到的地方</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;j ++) &#123;</span><br><span class="line">            <span class="type">char</span> c; cin &gt;&gt; c;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;*&#x27;</span>) a[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;0&#x27;</span>) a[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意一定是从边界往里搜的  所以只需要搜索第一列 最后一列 第一排 最后一排</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>][i] == <span class="number">0</span>) <span class="built_in">dfs</span>(<span class="number">0</span>,i);</span><br><span class="line">        <span class="keyword">if</span>(a[n - <span class="number">1</span>][i] == <span class="number">0</span>) <span class="built_in">dfs</span>(n - <span class="number">1</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i][<span class="number">0</span>] == <span class="number">0</span>) <span class="built_in">dfs</span>(i,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(a[i][m - <span class="number">1</span>] == <span class="number">0</span>) <span class="built_in">dfs</span>(i,m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j] == <span class="number">0</span>) cnt ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250408110917640.png" alt="image-20250408110917640"></p>
<p>这道题不一样的地方在于 搜索过的染色应该用其他数字标记 才能在最后复原矩阵 （当然开两个数组也可以 但是有点麻烦）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int dx[] = &#123;1,0,-1,0&#125;;</span><br><span class="line">int dy[] = &#123;0,1,0,-1&#125;;</span><br><span class="line">int n,a[35][35];</span><br><span class="line"></span><br><span class="line">void dfs(int x,int y) &#123;</span><br><span class="line">    a[x][y] = 3;</span><br><span class="line">    for(int i = 0;i &lt; 4;i ++) &#123;</span><br><span class="line">        int x0 = x + dx[i];</span><br><span class="line">        int y0 = y + dy[i];</span><br><span class="line">        if(x0 &gt;= 0 &amp;&amp; x0 &lt; n &amp;&amp; y0 &gt;=0 &amp;&amp; y0 &lt; n &amp;&amp; a[x0][y0] == 0) dfs(x0,y0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for(int i = 0;i &lt; n;i ++) &#123;</span><br><span class="line">        for(int j = 0;j &lt; n;j ++) cin &gt;&gt; a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i = 0;i &lt; n;i ++) &#123;</span><br><span class="line">        if(a[0][i] == 0) dfs(0,i);</span><br><span class="line">        if(a[n - 1][i] == 0) dfs(n - 1,i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i = 0;i &lt; n;i ++) &#123;</span><br><span class="line">        if(a[i][0] == 0) dfs(i,0);</span><br><span class="line">        if(a[i][n - 1] == 0) dfs(i,n - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int cnt = 0;</span><br><span class="line">    for(int i = 0;i &lt; n;i ++) &#123;</span><br><span class="line">        for(int j = 0;j &lt; n;j ++) &#123;</span><br><span class="line">            if(a[i][j] == 0) a[i][j] = 2;</span><br><span class="line">            if(a[i][j] == 3) a[i][j] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i = 0;i &lt; n;i ++) &#123;</span><br><span class="line">        for(int j = 0;j &lt; n;j ++) cout &lt;&lt; a[i][j] &lt;&lt; &quot; &quot;;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DFS-求所有排列"><a href="#DFS-求所有排列" class="headerlink" title="DFS 求所有排列"></a>DFS 求所有排列</h4><p>即爆搜出所有的可能排列 然后判断是否存在满足条件的排列或者从中选出最优解 一般的 会在搜索过程中进行剪枝 可以看 <strong>飞机降落</strong></p>
<p>和 <strong>接龙数列</strong> 这两道题</p>
<h4 id="是否需要回溯"><a href="#是否需要回溯" class="headerlink" title="是否需要回溯"></a>是否需要回溯</h4><p>考虑是否回溯其实就是考虑 dfs 会不会对后续的搜索造成影响 如果会造成影响的话 就应该在搜索后回溯 否则的话就不用回溯</p>
<p>比如在求所有的排列时 某个数是否应用是在搜索过程中改变了的 所以需要在搜索后进行回溯</p>
<p>但在染色法求连通块 或者遍历树这些不改变元素性质 不会重复访问的问题里 就不需要回溯 比如说<strong>P2036</strong></p>
<p>在 DFS 中，是否需要显式地在函数开头添加<strong>结束条件判断</strong>（如<code>if (搜索完) return;</code>），取决于<strong>问题的性质</strong>和<strong>解的生成方式</strong>。以下是关键区分点：</p>
<hr>
<h5 id="1-何时需要显式结束条件？"><a href="#1-何时需要显式结束条件？" class="headerlink" title="1. 何时需要显式结束条件？"></a><strong>1. 何时需要显式结束条件？</strong></h5><p>当 <strong>“解的完整性”</strong> 必须在递归的某一层被明确判断时，需要在 DFS 开头检查结束条件。常见场景包括：</p>
<ul>
<li><strong>组合&#x2F;排列问题</strong>：只有选满特定数量的元素才算有效解（如全排列、组合数问题）。</li>
<li><strong>路径终点问题</strong>：必须到达某个特定节点才算解（如迷宫出口、二叉树叶子节点）。</li>
<li><strong>约束满足问题</strong>：必须满足所有约束条件才能形成有效解（如数独填满且合法）。</li>
</ul>
<h6 id="示例：全排列问题"><a href="#示例：全排列问题" class="headerlink" title="示例：全排列问题"></a><strong>示例：全排列问题</strong></h6><p>cpp</p>
<p>复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void dfs(vector&lt;int&gt;&amp; path) &#123;</span><br><span class="line">    if (path.size() == n) &#123; // 显式判断是否完成排列</span><br><span class="line">        print(path);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        if (!used[i]) &#123;</span><br><span class="line">            used[i] = true;</span><br><span class="line">            path.push_back(i);</span><br><span class="line">            dfs(path);</span><br><span class="line">            path.pop_back();</span><br><span class="line">            used[i] = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：必须显式判断<code>path.size() == n</code>，因为只有选满 n 个数才是一个有效排列。</p>
<hr>
<h5 id="2-何时不需要显式结束条件？"><a href="#2-何时不需要显式结束条件？" class="headerlink" title="2. 何时不需要显式结束条件？"></a><strong>2. 何时不需要显式结束条件？</strong></h5><p>当 <strong>“解的局部状态”</strong> 可以随时更新答案，且递归的终止由无法继续搜索隐式触发时，无需显式结束判断。常见场景包括：</p>
<ul>
<li><strong>最长&#x2F;最短路径问题</strong>：每一步都可能更新当前最优解（如字符串拼接最长长度）。</li>
<li><strong>连通性&#x2F;遍历问题</strong>：递归自然终止于无法继续扩展的节点（如岛屿数量、图的遍历）。</li>
</ul>
<h6 id="示例：字符串拼接问题"><a href="#示例：字符串拼接问题" class="headerlink" title="示例：字符串拼接问题"></a><strong>示例：字符串拼接问题</strong></h6><p>cpp</p>
<p>复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void dfs(string current) &#123;</span><br><span class="line">    ans = max(ans, current.length()); // 随时更新答案</span><br><span class="line">    for (auto&amp; s : candidates) &#123;</span><br><span class="line">        if (can_append(current, s)) &#123;</span><br><span class="line">            dfs(append(current, s)); // 隐式终止于无法拼接</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：每次递归都尝试延长当前字符串，并更新最大长度。当无法继续拼接时，循环自然结束，无需显式判断终止。</p>
<hr>
<h4 id="3-关键区分原则"><a href="#3-关键区分原则" class="headerlink" title="3. 关键区分原则"></a><strong>3. 关键区分原则</strong></h4><table>
<thead>
<tr>
<th align="left"><strong>特征</strong></th>
<th align="left">需要显式结束条件</th>
<th align="left">不需要显式结束条件</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>解的形式</strong></td>
<td align="left">必须完整（如全排列）</td>
<td align="left">局部状态即可更新（如最长路径）</td>
</tr>
<tr>
<td align="left"><strong>递归终止触发方式</strong></td>
<td align="left">显式判断完整性后返回</td>
<td align="left">无法继续搜索时自然返回</td>
</tr>
<tr>
<td align="left"><strong>答案更新时机</strong></td>
<td align="left">仅在完整解时更新</td>
<td align="left">每一步都可能更新</td>
</tr>
</tbody></table>
<h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>BFS 具有最短路性质 即它是贪心的 每一步都选择了最优解 因为每次搜索都选择的是距离最近的点（队列实现）</p>
<p>模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;类型&gt;Q;</span><br><span class="line">Q.<span class="built_in">push</span>(最初状态);</span><br><span class="line"><span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">	类型 u=Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>(); <span class="comment">//每次处理的下一步就是这里的u</span></span><br><span class="line">	<span class="keyword">for</span>(枚举所有可扩展到的状态)&#123;</span><br><span class="line">		<span class="keyword">if</span>(满足入队条件)&#123;</span><br><span class="line">			Q.<span class="built_in">push</span>(状态); <span class="comment">//维护某些必要信息</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例题</p>
<p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250408163244410.png" alt="image-20250408163244410"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pp;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1005</span>;</span><br><span class="line"><span class="type">int</span> vi[N],k[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,a,b; cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) cin &gt;&gt; k[i];</span><br><span class="line">    <span class="keyword">if</span>(a == b) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;pp&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,a&#125;); <span class="comment">//初始状态 pair里fi代表现在按了几次键 se代表现在的楼层（id）</span></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        pp u = q.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">if</span>(u.se == b) &#123;</span><br><span class="line">            cout &lt;&lt; u.fi &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(u.se + k[u.se] &lt;= n &amp;&amp; vi[u.se + k[u.se]] == <span class="number">0</span>) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;u.fi + <span class="number">1</span>,u.se + k[u.se]&#125;);</span><br><span class="line">            vi[u.se + k[u.se]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u.se - k[u.se] &gt;= <span class="number">1</span> &amp;&amp; vi[u.se - k[u.se]] == <span class="number">0</span>) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;u.fi + <span class="number">1</span>,u.se - k[u.se]&#125;);</span><br><span class="line">            vi[u.se - k[u.se]] = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="comment">//注意这里不要用else if 因为这两种情况是有可能同时成立的 所以要直接用两个if</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="选数问题"><a href="#选数问题" class="headerlink" title="选数问题"></a>选数问题</h3><p>从 n 个数中选择 k 个数 要想没有遗漏地枚举出所有的选择情况 就必须遵循 <strong>不降原则</strong></p>
<p>即每次选择的时候不选择比上次选择的数小的数字</p>
<p>比如说要从 n 个数中选择 3 个数 那么最暴力的枚举就应该是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++) &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>;j &lt; n;j ++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k = j + <span class="number">1</span>;k &lt; n;k ++) &#123;</span><br><span class="line">			<span class="comment">//选出的三个数即为i j k</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一道例题</p>
<p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250408193853045.png" alt="image-20250408193853045"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">22</span>;</span><br><span class="line"><span class="type">int</span> n,k,cnt;</span><br><span class="line"><span class="type">int</span> x[N],vi[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= u / i;i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(u % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> sum,<span class="type">int</span> now)</span> </span>&#123; <span class="comment">// 用now来记录上次选择的数的下一个 从而遵循不降原则</span></span><br><span class="line">    <span class="keyword">if</span>(u == k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(sum)) cnt ++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过不降原则实现dfs</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = now;i &lt; n;i ++) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(u + <span class="number">1</span>,sum + x[i],i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++) cin &gt;&gt; x[i];</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="洛谷刷题小记"><a href="#洛谷刷题小记" class="headerlink" title="洛谷刷题小记"></a>洛谷刷题小记</h2><h3 id="P1083-借教室"><a href="#P1083-借教室" class="headerlink" title="P1083 借教室"></a>P1083 借教室</h3><p>像题目中这样，有一天不满足其后的每一天都不满足的情况就完全满足二分答案的单调性特征。</p>
<p>当题目中的数据范围能恰好达到 1e9 时，不妨在作运算的量上开 longlong 防止加和后超过 2e9 爆 int</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代码见https://www.luogu.com.cn/problem/P1083#submit</span><br></pre></td></tr></table></figure>

<h3 id="P1030-求先序排列"><a href="#P1030-求先序排列" class="headerlink" title="P1030 求先序排列"></a>P1030 求先序排列</h3><h4 id="1-先序遍历（Pre-order-Traversal）"><a href="#1-先序遍历（Pre-order-Traversal）" class="headerlink" title="1. 先序遍历（Pre-order Traversal）"></a>1. 先序遍历（Pre-order Traversal）</h4><p><strong>定义</strong>：先序遍历按照以下顺序访问二叉树的节点：</p>
<ul>
<li>访问根节点。</li>
<li>先序遍历左子树。</li>
<li>先序遍历右子树。</li>
</ul>
<p><strong>特点</strong>：先访问根节点，然后依次访问左右子树。对于每个子树，也遵循同样的规则。</p>
<p><strong>应用</strong>：常用于创建树的复制或输出树的结构信息，因为它首先处理根节点。</p>
<p><strong>示例</strong>： 假设有一棵如下所示的二叉树：</p>
<p>深色版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    A</span><br><span class="line">   / \</span><br><span class="line">  B   C</span><br><span class="line"> / \   \</span><br><span class="line">D   E   F</span><br></pre></td></tr></table></figure>

<p>先序遍历的顺序为：<code>A -&gt; B -&gt; D -&gt; E -&gt; C -&gt; F</code></p>
<h4 id="2-中序遍历（In-order-Traversal）"><a href="#2-中序遍历（In-order-Traversal）" class="headerlink" title="2. 中序遍历（In-order Traversal）"></a>2. 中序遍历（In-order Traversal）</h4><p><strong>定义</strong>：中序遍历按照以下顺序访问二叉树的节点：</p>
<ul>
<li>中序遍历左子树。</li>
<li>访问根节点。</li>
<li>中序遍历右子树。</li>
</ul>
<p><strong>特点</strong>：先访问左子树，再访问根节点，最后访问右子树。对于每个子树，也遵循同样的规则。</p>
<p><strong>应用</strong>：广泛应用于二叉搜索树（BST），因为中序遍历会以升序访问节点值，适用于排序和查找操作。</p>
<p><strong>示例</strong>： 对于上述相同的二叉树，中序遍历的顺序为：<code>D -&gt; B -&gt; E -&gt; A -&gt; C -&gt; F</code></p>
<p><strong>注意这里是递归的先访问子树再访问这个子树的根，不断向上寻找</strong></p>
<h4 id="3-后序遍历（Post-order-Traversal）"><a href="#3-后序遍历（Post-order-Traversal）" class="headerlink" title="3. 后序遍历（Post-order Traversal）"></a>3. 后序遍历（Post-order Traversal）</h4><p><strong>定义</strong>：后序遍历按照以下顺序访问二叉树的节点：</p>
<ul>
<li>后序遍历左子树。</li>
<li>后序遍历右子树。</li>
<li>访问根节点。</li>
</ul>
<p><strong>特点</strong>：先访问左右子树，最后访问根节点。对于每个子树，也遵循同样的规则。</p>
<p><strong>应用</strong>：常用于释放树占用的内存或计算表达式的值，因为在删除或计算时通常需要先处理子节点再处理父节点。</p>
<p><strong>示例</strong>： 对于上述相同的二叉树，后序遍历的顺序为：<code>D -&gt; E -&gt; B -&gt; F -&gt; C -&gt; A</code></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><strong>先序遍历</strong>：根 -&gt; 左 -&gt; 右</li>
<li><strong>中序遍历</strong>：左 -&gt; 根 -&gt; 右</li>
<li><strong>后序遍历</strong>：左 -&gt; 右 -&gt; 根</li>
</ul>
<h4 id="示例图解"><a href="#示例图解" class="headerlink" title="示例图解"></a>示例图解</h4><p>为了更直观地理解，我们可以通过一个简单的二叉树来展示这三种遍历的结果：</p>
<p>深色版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>先序遍历</strong>：<code>1 -&gt; 2 -&gt; 4 -&gt; 5 -&gt; 3</code></li>
<li><strong>中序遍历</strong>：<code>4 -&gt; 2 -&gt; 5 -&gt; 1 -&gt; 3</code></li>
<li><strong>后序遍历</strong>：<code>4 -&gt; 5 -&gt; 2 -&gt; 3 -&gt; 1</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">如果当前子树范围无效（即 ml &gt; mr 或 al &gt; ar），直接返回。</span><br><span class="line">输出后序遍历中的最后一个元素 aft[ar]，这是当前子树的根节点。</span><br><span class="line">查找这个根节点在中序遍历中的位置 k。</span><br><span class="line"></span><br><span class="line">根据找到的位置 k，递归处理左子树和右子树：</span><br><span class="line"></span><br><span class="line">左子树：中序遍历 [ml, k-1] 和后序遍历 [al, al+k-ml-1]。</span><br><span class="line">已知后序遍历序列的起始位置是 al，由于后序遍历的顺序是先左子树，再右子树，最后根节点，所以左子树在后序遍历中的结束位置可以通过以下方式计算：</span><br><span class="line">假设 n 是当前子树的节点数量，对于左子树，其节点数量为 k - ml。</span><br><span class="line">我们从后序遍历序列的起始位置 al 开始，由于左子树有 k - ml 个节点，所以左子树在后序遍历中的结束位置是 al + (k - ml) - 1，也就是 al + k - ml - 1。</span><br><span class="line"></span><br><span class="line">右子树：中序遍历 [k+1, mr] 和后序遍历 [al+k-ml, ar-1]。</span><br><span class="line">我们知道左子树的节点数量是 k - ml，所以右子树在后序遍历中的起始位置是 al + (k - ml)，即 al + k - ml。因为左子树在后序遍历中占据了 k - ml 个位置，所以右子树的起始位置是从左子树结束的下一个位置开始。</span><br><span class="line">ar 是整个子树后序遍历的结束位置，由于根节点是最后一个元素，右子树的结束位置是根节点的前一个位置，所以是 ar - 1。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这样每次输出子树的根节点最后就能得出先序排列的结果</span><br><span class="line">代码见https://www.luogu.com.cn/problem/P1030#submit</span><br></pre></td></tr></table></figure>

<h3 id="P10905-蓝桥杯-2024-省-C-回文字符串"><a href="#P10905-蓝桥杯-2024-省-C-回文字符串" class="headerlink" title="P10905 [蓝桥杯 2024 省 C] 回文字符串"></a>P10905 [蓝桥杯 2024 省 C] 回文字符串</h3><p>一开始的想法是直接把字符串右端由 lqb 这三个字符组成的字符串给去掉 如果剩下的字符串回文那么久可以使它变得回文</p>
<p>但是这样做只能过百分之五十，因为没有考虑像 <strong>qwq</strong>这样的情况</p>
<h3 id="P1044-栈"><a href="#P1044-栈" class="headerlink" title="P1044 栈"></a>P1044 栈</h3><p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250328084606790.png" alt="image-20250328084606790"></p>
<p>可以用一个 dp 来做</p>
<p>1.考虑状态 我们设置这样一个函数<strong>C(i,j)</strong> 其中 i 表示输入序列中待处理的数字 j 表示目前栈中的数字个数</p>
<p>所以我们要求的就是<strong>C(n,0)</strong> 这个状态</p>
<p>2.状态转移</p>
<p>对于每一次操作显然有两种操作 一是把输入序列中的数压入栈中 c(i - 1,j + 1) 二是把栈中的数压出到输出序列中去</p>
<p>c(i,j - 1)</p>
<p>所以状态转移方程为</p>
<p>$$f_{x,y}&#x3D;f_{x-1,y+1}+f_{x,y-1}$$</p>
<p>3.边界条件特判</p>
<p>当 i &#x3D;&#x3D; 0 的时候说明输入序列已经全部输出完 已成序列 说明只有一种走法</p>
<p>当 j &#x3D;&#x3D; 0 的时候说明栈内还没有数字 只能执行 push 压入操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n; cin &gt;&gt; n;</span><br><span class="line">	int f[22][22];</span><br><span class="line">	for(int i = 0;i &lt;= n;i ++) &#123;</span><br><span class="line">		for(int j = 0;j &lt;= n;j ++) &#123;</span><br><span class="line">			if(i == 0) f[i][j] = 1;</span><br><span class="line">			else if(j == 0) f[i][j] = f[i - 1][j + 1];</span><br><span class="line">			else f[i][j] = f[i - 1][j + 1] + f[i][j - 1];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; f[n][0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="P1359-租用游艇"><a href="#P1359-租用游艇" class="headerlink" title="P1359 租用游艇"></a>P1359 租用游艇</h3><p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250328085847167.png" alt="image-20250328085847167"></p>
<p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250328085829365.png" alt="image-20250328085829365"></p>
<p>1.状态表示 : 用 dp[i]来记录从 i 到 n 站之间的最小花费</p>
<p>2.状态转移：假设有三个点 顺序分别为 i j n 那么从 i 到 n 有两种走法 一是从 i - &gt; j ,j - &gt; n 此时花费为 a[i] [j] + dp[j]</p>
<p>二是直接从 i - &gt; n 此时花费为 dp[i] 要最少花费只需要对它们取一个 min 即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用dp[i]来表示从i到n的最小花费</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">210</span>][<span class="number">210</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">210</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; n;i ++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>;j &lt;= n;j ++) &#123;</span><br><span class="line">			cin &gt;&gt; a[i][j];</span><br><span class="line">			dp[i] = <span class="number">0x3f3f3f3f</span>; <span class="comment">//注意这里需要初始化为正无穷</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>;i &gt;= <span class="number">1</span>;i --) &#123; <span class="comment">//所以从后往前遍历</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>;j &lt;= n;j ++) &#123; <span class="comment">//i为上流 j为i相对的下流</span></span><br><span class="line">			dp[i] = <span class="built_in">min</span>(dp[i],a[i][j] + dp[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; dp[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="P3131（对于倍数问题的优化）"><a href="#P3131（对于倍数问题的优化）" class="headerlink" title="P3131（对于倍数问题的优化）"></a>P3131（对于倍数问题的优化）</h3><p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250407201655470.png" alt="image-20250407201655470"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对7取模的结果只会是 0 ~ 6</span></span><br><span class="line"><span class="type">int</span> last[<span class="number">7</span>],first[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n; cin &gt;&gt; n; <span class="type">int</span> a[n + <span class="number">1</span>],sum[n + <span class="number">1</span>];</span><br><span class="line">    sum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        sum[i] = (sum[i - <span class="number">1</span>] + a[i] ) % <span class="number">7</span>; <span class="comment">// 直接记录前缀和对7取模的余数 (a - b) % c == (a % c) - (b % c)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//滚动数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n;i &gt;= <span class="number">1</span>;i --) first[sum[i]] = i; <span class="comment">//更新该余数第一次出现的位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) last[sum[i]] = i; <span class="comment">//更新该余数最后一次出现的位置</span></span><br><span class="line"></span><br><span class="line">    first[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//注意 当一个奶牛都不取的时候  ID为0 余数也为0 没有这个赋值会错</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//枚举余数 从而判断最大长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">6</span>;i ++) ans = <span class="built_in">max</span>(ans,last[i] - first[i] );</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="P2036"><a href="#P2036" class="headerlink" title="P2036"></a>P2036</h3><p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250408171247020.png" alt="image-20250408171247020"></p>
<h3 id="P2196-挖地雷（图上-DFS）"><a href="#P2196-挖地雷（图上-DFS）" class="headerlink" title="P2196 挖地雷（图上 DFS）"></a>P2196 挖地雷（图上 DFS）</h3><p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250409233215501.png" alt="image-20250409233215501"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">22</span>;</span><br><span class="line"><span class="type">int</span> a[N][N],n,ans; <span class="comment">// 数据比较小 用邻接矩阵来存图</span></span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> cnt1,cnt2; <span class="comment">//cnt1为op的路径长度 cnt2为p的路径长度</span></span><br><span class="line"><span class="type">int</span> op[N]; <span class="type">int</span> p[N]; <span class="comment">//用op来记录每次的路径 用p来记录最优路径</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> sum)</span></span>&#123;  <span class="comment">//x为起始节点 sum为挖到的地雷数目</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = x + <span class="number">1</span>;i &lt;= n;i ++) &#123; <span class="comment">//从上往下挖 所以从x + 1开始</span></span><br><span class="line">		<span class="keyword">if</span>(a[x][i]) &#123;  <span class="comment">//如果连通 则可以继续往下面挖</span></span><br><span class="line">			op[++cnt1] = i;</span><br><span class="line">			<span class="built_in">dfs</span>(i,sum + f[i]);</span><br><span class="line">			cnt1 --; <span class="comment">//回溯</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(sum &gt; ans) &#123;</span><br><span class="line">		ans = sum;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= cnt1;i ++) p[i] = op[i];</span><br><span class="line">		cnt2 = cnt1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) cin &gt;&gt; f[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>;j &lt;= n;j ++) &#123;</span><br><span class="line">			cin &gt;&gt; a[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) &#123; <span class="comment">// 枚举每一个节点作为起点</span></span><br><span class="line">		op[++cnt1] = i;</span><br><span class="line">		<span class="built_in">dfs</span>(i,f[i]);</span><br><span class="line">		cnt1 --;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt2;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,p[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n%d&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="acm-新生赛"><a href="#acm-新生赛" class="headerlink" title="acm 新生赛"></a>acm 新生赛</h2><p><strong><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/98528#question">第十六届西南石油大学程序设计新生赛<em>ACM&#x2F;NOI&#x2F;CSP&#x2F;CCPC&#x2F;ICPC 算法编程高难度练习赛</em>牛客竞赛 OJ</a></strong></p>
<h3 id="A-小刘的最短路"><a href="#A-小刘的最短路" class="headerlink" title="A 小刘的最短路"></a>A 小刘的最短路</h3><p>简单 ifelse 分情况判断，画图分析会更加清晰一点</p>
<h3 id="B-建造新家"><a href="#B-建造新家" class="headerlink" title="B 建造新家"></a>B 建造新家</h3><p><img src="/%E7%AE%97%E6%B3%95.assets/image-20241209105805539.png" alt="image-20241209105805539"></p>
<p>对于表达式中的 x++，来观察整个式子值的变化，剔除与初始式子相同的部分，剩下的部分就是每次改变的部分，那么就可以用类似前缀和计算的方法用 o(1)的时间复杂度算出每一个 x 的取值的对应值，最后枚举得以实现 o(n)算法</p>
<p>即我们可以得到每次取 x 的式子表达式变为</p>
<p>$$<br>\text{now} &#x3D; \text{f(i)} &#x3D; \text{f(i-1)} + s1 \times 2 \times (i - 1) - s2 \times 2 + s1<br>$$</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using i64 = long long;</span><br><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    std::vector&lt;i64&gt; a(n + 1, 0);</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        std::cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    i64 s1 = 0, s2 = 0;</span><br><span class="line">    for (i64 i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        s1 += a[i];</span><br><span class="line">        s2 += a[i] * i;</span><br><span class="line">    &#125;</span><br><span class="line">    //预处理式子改变量中的常数部分</span><br><span class="line">    i64 ans = 0, now = 0;</span><br><span class="line">    for (i64 i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        now += a[i] * (1 - i) * (1 - i);</span><br><span class="line">    &#125;</span><br><span class="line">    ans = now; // x取1时的表达式值，用于作为初始值</span><br><span class="line"></span><br><span class="line">    for (i64 i = 2; i &lt;= n; ++i) &#123;</span><br><span class="line">        now = now + s1 * 2 * (i - 1) - s2 * 2 + s1; //通过上面的公式计算新值（注意上面公式里面的x对应的应该是i-1哦！）</span><br><span class="line">        ans = std::min(ans, now); //枚举x的过程中动态更新答案即可</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个题中由于表达式是二次函数故而不需要复杂的求导就能直接找到取最小值时的点，故而也可以直接算出 f(i)之和表达式的对称轴，由对称轴计算即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//代码在https://ac.nowcoder.com/acm/contest/view-submission?submissionId=74064589</span><br><span class="line">//ceil是向上取整，floor是向下取整</span><br><span class="line">//为什么考试的时候没写对呢?哦哦原来是没有开longlong啊！</span><br><span class="line">//还有需要注意的是因为在运算中用到了i和a[i]，所以它们都需要开成longlong</span><br><span class="line">//答应我，下次算一下看看是不是要开longlong</span><br></pre></td></tr></table></figure>

<h3 id="C-合成大雪球"><a href="#C-合成大雪球" class="headerlink" title="C 合成大雪球"></a>C 合成大雪球</h3><p>对于求第 k 小&#x2F;大的问题，一般都可以想到二分，二分的条件一般是求比它小的元素有多少个，需要注意的是，如果比它小的元素有 k 个那么它应该是第 k+1 小的元素（必须考虑它自身）</p>
<p>对于这个题的数据很明显双遍历得到体积和的方案一定会超时的，由于这里的和由两个元素决定，所以跟之前招新考试的一个题类似，即枚举其中一个数来二分另外一个数。</p>
<p>这是外层的一个二分，即二分另一个数，但同时在这个二分中我们还需要另外一个二分即来二分判断是否是满足第 k 小的条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//考试的时候就一直在想怎么能对遍历求和进行优化</span><br><span class="line">//所以学到了枚举一个数二分另一个数</span><br><span class="line">//不要忘了对题目需要满足的条件进行二分判断</span><br><span class="line">//代码在https://ac.nowcoder.com/acm/contest/view-submission?submissionId=74098503</span><br></pre></td></tr></table></figure>

<h3 id="D-羽毛球比赛"><a href="#D-羽毛球比赛" class="headerlink" title="D 羽毛球比赛"></a>D 羽毛球比赛</h3><p>（我还没学 dfs 呢，等会儿再来）</p>
<h3 id="E-小青找宝藏"><a href="#E-小青找宝藏" class="headerlink" title="E 小青找宝藏"></a>E 小青找宝藏</h3><p>斐波拉契数列中第 45 项就已经大于 1e9 了，所以对于 0 到 1e9 的 n 来说，直接遍历三个斐波拉契数使其相加等于 n 时间复杂度最多也不过 o(45^3)即 o(91125)，所以是可以直接枚举出答案的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//谁能想到这个题是单纯枚举呢？？？？？</span><br><span class="line">//可以记一下 斐波拉契数列45项就＞1e9，我下次一定会遍历的</span><br><span class="line">//代码见https://ac.nowcoder.com/acm/contest/view-submission?submissionId=74100320</span><br></pre></td></tr></table></figure>

<h3 id="F-矩形面积"><a href="#F-矩形面积" class="headerlink" title="F 矩形面积"></a>F 矩形面积</h3><p>单调栈模板题</p>
<p>看过程，需要找到左边小于基准量的第一个位置和右边小于基准量的第一个位置，符合单调栈的工作原理</p>
<p>特别需要注意的是，为了能够进入计算部分，需要在左右分别添加一个值为 0 的哨兵元素，是为了处理数组本身就单调的情况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//谁能想到其实在刚开学那个月就做过这个题了呢</span><br><span class="line">//那个时候都还不知道啥是栈哇</span><br><span class="line">//光阴似箭岁月如梭</span><br><span class="line">//代码见https://ac.nowcoder.com/acm/contest/view-submission?submissionId=74102790</span><br></pre></td></tr></table></figure>

<p><strong>这时候就有人要问了，中间的题去哪了呢？？答案是太简单 or 太难了 hah</strong></p>
<h3 id="K-赚差价"><a href="#K-赚差价" class="headerlink" title="K 赚差价"></a>K 赚差价</h3><p><img src="/%E7%AE%97%E6%B3%95.assets/image-20241209203326445.png" alt="image-20241209203326445"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//我说白了这个题的数学运算实在是太复杂了所以直接贴付队发的解题思路</span><br><span class="line">//可以学的是找到问题的实质到底是什么，通过一些关系来减少模拟次数（比如说这里m/p相同就合并）</span><br><span class="line">//还有就是在使用各种算法或模拟之外，也可以讨论数学上的推论</span><br><span class="line">//代码见https://ac.nowcoder.com/acm/contest/view-submission?submissionId=74068323</span><br></pre></td></tr></table></figure>

<h3 id="L-编辑器"><a href="#L-编辑器" class="headerlink" title="L 编辑器"></a>L 编辑器</h3><p>此题特殊在各种操作都与现在的光标相关，故而我们需要两个数据结构分别去维护光标，又因为各种操作其实都是对上一个储存的元素就行访问所以想到用栈来处理。</p>
<p>通过对顶堆想到对顶栈，用一个栈来记录开头到光标位置，另一个栈来记录光标到结尾位置，两个栈都以光标位置作为栈顶，两个栈合起来就维护了整个序列。</p>
<p>而对于每个询问来说，直接再开一个数组来维护栈的前缀和即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//对顶栈维护整个序列的操作学到了</span><br><span class="line">//每次对左栈修改后就维护一次左边的前缀和，还是比较巧妙地</span><br><span class="line">//代码见https://www.acwing.com/problem/content/description/130/</span><br><span class="line">//不知道为什么我这个代码只在acwing上能过捏 但是我觉得应该是没什么问题嘟</span><br></pre></td></tr></table></figure>

<h2 id="牛客刷题小记"><a href="#牛客刷题小记" class="headerlink" title="牛客刷题小记"></a>牛客刷题小记</h2><h3 id="校外的树"><a href="#校外的树" class="headerlink" title="校外的树"></a>校外的树</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">题外话，记录这个题很大程度上是因为这是我第一场招新考试做到的题，纪念意义max；</span><br><span class="line">当然最主要的还是这个题因为数据的不同可以有几种做法</span><br></pre></td></tr></table></figure>

<p><strong>处理重复区间的最优方法</strong></p>
<p>按照题目的意思来看，是给每个区间内的树撤去，即减去这一部分的存在，然而由于有重复区间的存在，所以如果用减法就不可避免的多减，要避免此，每次都给减过的点打一个标记未免太过麻烦。所以我们可以转化思想，即初始化整个序列为 0，让每一个出现的区间中的数都加一，最后统计还为 0 的点就是最后剩下得树，这样的处理方法可以使得无论一个点被重复处理了多少次都不会影响最后剩下的树。</p>
<p>当然还有一种方法是通过 bool 数组给每一个点都打标记，这样就可以只统计没有被标记的点即是剩下的树了。</p>
<p><strong>不同数据下的不同做法</strong></p>
<p>1.在数据比较小的时候，可以直接使用遍历的做法，即给每一个区间内的点都去打标记，最后再统计没有被标记过的点的数量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代码见https://ac.nowcoder.com/acm/contest/view-submission?submissionId=74264751&amp;returnHomeType=1&amp;uid=401013592</span><br></pre></td></tr></table></figure>

<p>2.当数据比较大即遍历显然会超时的时候，结合题目让一个区间内的数改变，，可以用差分来实现，需要注意的还是上面介绍的应该是加 1，最后统计为 0 的点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代码见https://ac.nowcoder.com/acm/contest/view-submission?submissionId=74269667&amp;returnHomeType=1&amp;uid=401013592</span><br></pre></td></tr></table></figure>

<p>3.如果数据特别特别大，显然对于这些独立的需要处理的区间我们可以用离散化来处理，由于存在重叠的部分所以不妨直接先进行一次区间合并然后直接通过合并后的区间内的树的数目来计算（总数目-移走的数目）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代码见https://ac.nowcoder.com/acm/contest/view-submission?submissionId=74270870&amp;returnHomeType=1&amp;uid=401013592</span><br></pre></td></tr></table></figure>

<h3 id="二分（这个题跟二分无关）"><a href="#二分（这个题跟二分无关）" class="headerlink" title="二分（这个题跟二分无关）"></a>二分（这个题跟二分无关）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目和代码见https://ac.nowcoder.com/acm/problem/207053</span><br></pre></td></tr></table></figure>

<p>一道二分背景上的差分题目，我觉得还是挺有启发的。</p>
<p>最暴力的想法肯定是枚举每个数，最多符合条件的就应该是答案，显然过不了需要优化</p>
<p>可以想到，既然无法去判断每句话的真假那么不妨假设每句话都是真实的，并且依靠每一个判断给元素加权，最后我们找到权最大的就肯定是答案（即最多符合条件的点）</p>
<p>所以在这样的判断里可以想到用差分（对区间内的数做出改变），但同时因为边界可以达到正负 1e9，所以我们需要用 map 来离散化（因为我们需要判断的只有出现的几个数字）。最后判断加权的时候就相当于求这个 map 差分数组的前缀和。</p>
<h2 id="寒假刷题小记"><a href="#寒假刷题小记" class="headerlink" title="寒假刷题小记"></a>寒假刷题小记</h2><h3 id="1-全排列"><a href="#1-全排列" class="headerlink" title="1.全排列"></a>1.全排列</h3><p>给出 n 的全排列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 10;</span><br><span class="line">int ans[N],n;</span><br><span class="line">bool is[N];</span><br><span class="line"></span><br><span class="line">void dfs(int u)&#123;</span><br><span class="line">    if(u == n) &#123;</span><br><span class="line">        for(int i = 0;i &lt; n;i ++) cout &lt;&lt; ans[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">        if(!is[i])&#123;</span><br><span class="line">            ans[u] = i;</span><br><span class="line">            is[i] = true;</span><br><span class="line">            dfs(u + 1);</span><br><span class="line">            ans[u] = 0;</span><br><span class="line">            is[i] = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    dfs(0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-N-皇后"><a href="#2-N-皇后" class="headerlink" title="2.N 皇后"></a>2.N 皇后</h3><p>给出一个 n×nn\times nn×n 的国际象棋棋盘，你需要在棋盘中摆放 nnn 个皇后，使得任意两个皇后之间不能互相攻击。具体来说，不能存在两个皇后位于同一行、同一列，或者同一对角线。请问共有多少种摆放方式满足条件。</p>
<p>输入描述:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一行，一个整数n(1≤n≤12)n(1\le n \le 12)n(1≤n≤12)，表示棋盘的大小。</span><br></pre></td></tr></table></figure>

<p>输出描述:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出一行一个整数，表示总共有多少种摆放皇后的方案，使得它们两两不能互相攻击。</span><br></pre></td></tr></table></figure>

<p>代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 25;</span><br><span class="line">bool a[N],ug[N],g[N];</span><br><span class="line">int n,t;</span><br><span class="line"></span><br><span class="line">void dfs(int u)</span><br><span class="line">&#123;</span><br><span class="line">    if(u &gt; n) &#123; // 搜完了所有的行 即完成了一种排列</span><br><span class="line">        t ++;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        for(int i = 1;i &lt;= n;i ++) // 确定u相当于确定了行 故而只用遍历列</span><br><span class="line">        &#123;</span><br><span class="line">            if(!a[i] &amp;&amp; !ug[i + u] &amp;&amp; !g[n - u + i]) &#123; // 保证它不在同一列 同一对角线 同一反对角线</span><br><span class="line">                a[i] = ug[u + i] = g[n - u + i] = true;</span><br><span class="line">                dfs(u + 1); // 如果当前满足了 就继续往前搜</span><br><span class="line">                a[i] = ug[i + u] = g[i - u + n] = false; //回溯复原</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    dfs(1);</span><br><span class="line">    cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特别需要关注的几个点有：</p>
<p>一，在一个方格图中，采用的是确定行来遍历列的思想，在其他情况，有可能就是去分析行列谁放在外循环谁放在内循环的区别</p>
<p>二，在方格图中关于对角线，反对角线的表述，以及其与坐标的下标之间的关系</p>
<h3 id="3-马走日"><a href="#3-马走日" class="headerlink" title="3.马走日"></a>3.马走日</h3><p>题目描述</p>
<p>在 n 行 m 列的棋盘上有一个中国象棋的马，马走日字且不能向左走，设原本坐标为(x,y)走一步可以达到的位置有(x+1,y+2),(x+2,y+1),(x+2,y−1)(x+1,y-2)并且不能走出棋盘。请找到可行路径的条数，使得马从棋盘的左下角(1,1)走到右上角(n,m)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一行，两个整数n,m(1≤n,m≤15)n,m(1\le n,m \le 15)n,m(1≤n,m≤15)，表示棋盘的大小。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出一行一个整数，表示马从左下角到右上角的不同路径数。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 100;</span><br><span class="line">int n,m,t;</span><br><span class="line">int dx[4] = &#123;1,1,2,2&#125;;</span><br><span class="line">int dy[4] = &#123;2,-2,1,-1&#125;; // 用两个数组来表示方向的移动向量，在移动的时候只需要去遍历数组即可，类似于上面对上下左右的处理</span><br><span class="line"></span><br><span class="line">void dfs(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    if(x == n &amp;&amp; y == m)</span><br><span class="line">    &#123;</span><br><span class="line">        t ++;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(x &gt; n || x &lt; 1 || y &gt; m || y &lt; 1) return;</span><br><span class="line">    else &#123;</span><br><span class="line">        for(int i = 0;i &lt; 4;i ++) dfs(x + dx[i],y + dy[i]);</span><br><span class="line">        //每次循环就相当于往一种情况移动，再以这种移动进入dfs直到出界或者走到终点，如果出界的话就会被return到上一层的dfs，相当于进行了一次回溯</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    dfs(1,1);</span><br><span class="line">    cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里的 dfs 是多个方向的一条路走到黑，多个方向的选择是通过数组的循环来实现的</p>
<p>比如说，第一次 dfs 后，向第一种方向走，以这种状态进入第二层 dfs，然后又向第一种方向走，进入第三层 dfs，如果此时出界了就会 return 回第二层 dfs，由于之前第一方向已经走过了，所以就会向第二种方向走、</p>
<p>就是通过这样的不断迭代和回溯来实现对所有走法的可行路径的全统计</p>
<h3 id="4-数独"><a href="#4-数独" class="headerlink" title="4. 数独"></a>4. 数独</h3><p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250110154326439.png" alt="image-20250110154326439"></p>
<p>代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 100;</span><br><span class="line">int mp[12][12],cnt;</span><br><span class="line">bool h[12][12],l[12][12],gong[12][12];</span><br><span class="line">//dfs的一个关键点是如何判断可行从而进行下一步搜索</span><br><span class="line">//根据数独的要求这里分为行列和九宫格三个判断条件</span><br><span class="line"></span><br><span class="line">struct sp&#123;</span><br><span class="line">    int x;</span><br><span class="line">    int y;</span><br><span class="line">&#125;space[N];</span><br><span class="line"></span><br><span class="line">const int g[10][10] = &#123; &#123;0,0,0,0,0,0,0,0,0,0&#125;,</span><br><span class="line">					 &#123;0,1,1,1,2,2,2,3,3,3&#125;,</span><br><span class="line">					 &#123;0,1,1,1,2,2,2,3,3,3&#125;,</span><br><span class="line">					 &#123;0,1,1,1,2,2,2,3,3,3&#125;,</span><br><span class="line">					 &#123;0,4,4,4,5,5,5,6,6,6&#125;,</span><br><span class="line">					 &#123;0,4,4,4,5,5,5,6,6,6&#125;,</span><br><span class="line">					 &#123;0,4,4,4,5,5,5,6,6,6&#125;,</span><br><span class="line">					 &#123;0,7,7,7,8,8,8,9,9,9&#125;,</span><br><span class="line">					 &#123;0,7,7,7,8,8,8,9,9,9&#125;,</span><br><span class="line">					 &#123;0,7,7,7,8,8,8,9,9,9&#125;, &#125;;</span><br><span class="line">//这里使用了一个打表的小技巧，通过二维数组的值来代指目前的位置处于第几个九宫格 巧思啊！</span><br><span class="line"></span><br><span class="line">void print()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 1;i &lt;= 9;i ++)</span><br><span class="line">        for(int j = 1;j &lt;= 9;j ++) &#123;</span><br><span class="line">            cout &lt;&lt; mp[i][j];</span><br><span class="line">            if(j == 9) cout &lt;&lt; endl;</span><br><span class="line">            else cout &lt;&lt; &quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs(int u)</span><br><span class="line">&#123;</span><br><span class="line">    if(u &gt; cnt) &#123;</span><br><span class="line">        print();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        for(int i = 1;i &lt;= 9; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            int xx = space[u].x; int yy = space[u].y;</span><br><span class="line">            if(!h[xx][i] &amp;&amp; !l[yy][i] &amp;&amp; !gong[g[xx][yy]][i])</span><br><span class="line">            &#123;</span><br><span class="line">                h[xx][i] = 1, l[yy][i] = 1, gong[g[xx][yy]][i] = 1;</span><br><span class="line">                mp[xx][yy] = i;</span><br><span class="line">                dfs(u + 1);</span><br><span class="line">                h[xx][i] = l[yy][i] = gong[g[xx][yy]][i] = 0;</span><br><span class="line">                mp[xx][yy] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   for(int i = 1;i &lt;= 9;i ++)</span><br><span class="line">   &#123;</span><br><span class="line">       for(int j = 1;j &lt;= 9;j ++) &#123;</span><br><span class="line">           cin &gt;&gt; mp[i][j];</span><br><span class="line">           if(mp[i][j] == 0) &#123;</span><br><span class="line">               space[++cnt].x = i;</span><br><span class="line">               space[cnt].y = j;</span><br><span class="line">           &#125;</span><br><span class="line">           h[i][mp[i][j]] = true;</span><br><span class="line">           l[j][mp[i][j]] = true;</span><br><span class="line">           gong[g[i][j]][mp[i][j]] = true;</span><br><span class="line">           //这里的三个布尔数组的意思为，第i行的这个数已经存在以此类推</span><br><span class="line">           //故而在dfs过程中，实际上深搜的是从1~9的每个数，即这个数可以放在哪些地方</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    dfs(1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dfs-小结"><a href="#dfs-小结" class="headerlink" title="dfs 小结"></a>dfs 小结</h3><p>在 dfs 的相关问题中，主要的步骤是进行递归和回溯。</p>
<p>进行的关键点在于什么时候进入递归，以及回溯的准确性。</p>
<p>什么时候进入递归？？</p>
<p><strong>当前状态可行</strong> -&gt;<strong>先将当前标记为已走过</strong> ** -&gt; **深入到下一步状态**</p>
<p>回溯？？</p>
<p>回溯需要重新标记为没有走过</p>
<p>如果没有标记的需要，那么回溯一般表现为 return 回上一层 dfs</p>
<h3 id="5-这里有四道题-牛客周赛"><a href="#5-这里有四道题-牛客周赛" class="headerlink" title="5.(这里有四道题)牛客周赛"></a>5.(这里有四道题)牛客周赛</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目见https://ac.nowcoder.com/acm/contest/99990</span><br></pre></td></tr></table></figure>

<h4 id="q1"><a href="#q1" class="headerlink" title="q1 :"></a><strong>q1</strong> :</h4><p>理清楚逻辑即可，关于周末双休计算 n 天贡献的题还是蛮常见的</p>
<h4 id="q2-："><a href="#q2-：" class="headerlink" title="q2 ："></a><strong>q2</strong> ：</h4><p>构造题，做的时候想太多了，关键在于字符串中单一个字母也可以称其为字串，故而直接找到字符串中出现次数最多的字母即可</p>
<p>补充一下关于记录字母出现次数方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line">//建立计数数组</span><br><span class="line">cnt[N];</span><br><span class="line">int n = s.length();</span><br><span class="line">for(int i = 0;i &lt; n;i ++)</span><br><span class="line">&#123;</span><br><span class="line">	cnt[s[i]- &#x27;a&#x27;] ++; // 此处的s[i]- &#x27;a&#x27;实际为在字母表中出现的位置，故而后面可以还原这个字母</span><br><span class="line">&#125;</span><br><span class="line">//假设出现次数最多的是cnt[t],还原字母(0 &lt; t &lt; 26)</span><br><span class="line">char a = (char)(&#x27;a&#x27; + t);</span><br></pre></td></tr></table></figure>

<h4 id="q3"><a href="#q3" class="headerlink" title="q3 :"></a><strong>q3</strong> :</h4><p>一道关于最大公约数 gcd 的思维题，先在这里介绍一下 gcd</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//在c ++ 中可以直接调用函数</span><br><span class="line">#include &lt;numeric&gt;</span><br><span class="line">int a = gcd(4,6);</span><br><span class="line">//底层的计算逻辑如下</span><br><span class="line">int gcd(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">	if(b == 0) return a;</span><br><span class="line">	else return gcd(b,a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于这道题本身，因为可以进行任意次操作将两个数都变为它们的最大公约数，故而可以知道，要使整个数组的元素之和最小，就要使数组中的每个数都变成所有数的最大公约数</p>
<p><strong>最大公约数的传递性</strong>：如果我们对多个数连续应用 GCD 操作，结果等于这些数的最大公约数。例如，对于三个数 a,b,c<em>a</em>,<em>b</em>,_c_，有 gcd(a,gcd(b,c))&#x3D;gcd(a,b,c)gcd(<em>a</em>,gcd(<em>b</em>,<em>c</em>))&#x3D;gcd(<em>a</em>,<em>b</em>,<em>c</em>)。</p>
<p><strong>最小化和的关键</strong>：由于我们可以选择任意两个数进行 GCD 操作，并且可以进行任意次操作，实际上我们可以将整个数组的所有元素通过一系列的 GCD 操作合并成一个值，即所有元素的最大公约数。因为 GCD 的结果不会大于原来的任何一个数，所以这是能获得的最小可能值。</p>
<p>所以我们计算完所有元素的最大公约数 q 后，最后的数组和即为 n * q</p>
<h4 id="q4"><a href="#q4" class="headerlink" title="q4 :"></a><strong>q4</strong> :</h4><p>这道题出错了。。 可以想一下贪心的思维，要最小化，就可以从最大的开始处理，故而用一个大根堆可以处理</p>
<h3 id="6-双人迷宫相遇问题"><a href="#6-双人迷宫相遇问题" class="headerlink" title="6.双人迷宫相遇问题"></a>6.双人迷宫相遇问题</h3><p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250114162104562.png" alt="image-20250114162104562"></p>
<p>即一个双重 bfs，两个人同时进行 bfs，当 a 中途走到了 b 走过的地方即证明已经相遇了，关键就是在于如何去建立 ab 两人之间的关系</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef pair&lt;int,int&gt; pp;</span><br><span class="line"></span><br><span class="line">char b[1005][1005];</span><br><span class="line">int x1,y1,x2,y2;</span><br><span class="line">int n,m;</span><br><span class="line">queue&lt;pp&gt;q[2]; //q[0]即为小B，q[1]为小A</span><br><span class="line">//用0，1其实是一个小技巧，在需要联系另一个人的时候直接非！一次即可</span><br><span class="line">bool flag ,v[2][1005][1005] ; //同理我们用这样一个三维的bool数组来分开标记a和b走过的地方</span><br><span class="line">int ans = 0;</span><br><span class="line">int dx[] = &#123;0,0,1,-1,1,1,-1,-1&#125;; int dy[] = &#123;1,-1,0,0,1,-1,1,-1&#125;;</span><br><span class="line"></span><br><span class="line">bool bfs(int a)</span><br><span class="line">&#123;</span><br><span class="line">    int x = 0,y = 0;</span><br><span class="line">    int t = q[a].size();</span><br><span class="line">    while(t --)</span><br><span class="line">    &#123;</span><br><span class="line">        auto qq = q[a].front();</span><br><span class="line">        q[a].pop();</span><br><span class="line">        for(int i = 0;i &lt; 4 + (a?4:0);i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            x =qq.first + dx[i],y = qq.second + dy[i];</span><br><span class="line">            if(x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m || b[x][y] == &#x27;#&#x27;|| v[a][x][y]) continue;</span><br><span class="line">            if(v[!a][x][y]) &#123;</span><br><span class="line">                flag = 1;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            v[a][x][y] = 1;</span><br><span class="line">            q[a].push(&#123;x,y&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for(int i = 0;i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j = 0;j &lt; m;j ++)&#123;</span><br><span class="line">            cin &gt;&gt; b[i][j];</span><br><span class="line">            if(b[i][j] == &#x27;D&#x27;) x1 = i, y1 = j;</span><br><span class="line">            if(b[i][j] == &#x27;C&#x27;) x2 = i, y2 = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    v[0][x1][y1] = true; q[0].push(&#123;x1,y1&#125;);</span><br><span class="line">    v[1][x2][y2] = true; q[1].push(&#123;x2,y2&#125;);</span><br><span class="line">    while(!q[1].empty() || !q[0].empty())</span><br><span class="line">    &#123;</span><br><span class="line">        ans ++;</span><br><span class="line">        if(bfs(0)) break;</span><br><span class="line">        if(bfs(0)) break;</span><br><span class="line">        if(bfs(1)) break;</span><br><span class="line">    &#125;</span><br><span class="line">    if(flag) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl &lt;&lt; ans;</span><br><span class="line">    else cout &lt;&lt; &quot;NO&quot;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-地雷递推"><a href="#7-地雷递推" class="headerlink" title="7.地雷递推"></a>7.地雷递推</h3><p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250114221410059.png" alt="image-20250114221410059"></p>
<p>关键在于找到规律，对于地雷问题</p>
<p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250114221603813.png" alt="image-20250114221603813"></p>
<p>即我们需要把题目的描述转化为状态方程，进而模拟过程，对于这类问题，特别需要注意的就是特殊情况的特判</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e4 + 10;</span><br><span class="line">int ans,n,a[N],f[N];</span><br><span class="line">int flag;</span><br><span class="line"></span><br><span class="line">int hi()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 2;i &lt; n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        int t = a[i] - f[i-1] - f[i];</span><br><span class="line">        if(t &lt; 0 || t &gt; 1) return 0;</span><br><span class="line">        else f[i+1] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    if(f[n] + f[n-1] != a[n]) return 0;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        if(a[i] &gt; 3) flag = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if(a[0] &gt; 2 || a[n-1] &gt; 2 || flag)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; 0 &lt;&lt; endl;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(a[1] == 2)</span><br><span class="line">    &#123;</span><br><span class="line">        f[1] = 1;</span><br><span class="line">        f[2] = 1;</span><br><span class="line">        ans += hi();</span><br><span class="line">    &#125;</span><br><span class="line">    else if(a[1] == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        f[1] = 0;</span><br><span class="line">        ans += hi();</span><br><span class="line">    &#125;</span><br><span class="line">    else if(a[1] == 1)</span><br><span class="line">    &#123;</span><br><span class="line">        f[1] = 1;</span><br><span class="line">        ans += hi();</span><br><span class="line">        memset(f,0,sizeof f);</span><br><span class="line">        f[2] = 1;</span><br><span class="line">        ans += hi();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-贪心拼数"><a href="#8-贪心拼数" class="headerlink" title="8.贪心拼数"></a>8.贪心拼数</h3><p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250115104844171.png" alt="image-20250115104844171"></p>
<p>按照字典序大的排列即可，这里的做法是给 sort 自定义一个 cmp 来排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">bool cmp(string a,string b)</span><br><span class="line">&#123;</span><br><span class="line">    return a + b &gt; b + a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n; cin &gt;&gt; n;</span><br><span class="line">    string s[n];</span><br><span class="line">    for(int i = 0;i &lt; n;i ++) cin &gt;&gt; s[i];</span><br><span class="line">    sort(s,s + n,cmp);</span><br><span class="line">    for(int i = 0;i &lt; n;i ++) cout &lt;&lt; s[i];</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-贪心排座椅"><a href="#9-贪心排座椅" class="headerlink" title="9.贪心排座椅"></a>9.贪心排座椅</h3><p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250115112746614.png" alt="image-20250115112746614"></p>
<p>要使得上课交头接耳的学生对数最少，即要使我们划分的过道能够隔开最多的交头接耳学生对数</p>
<p>那么每次划分时，都对这条线隔开的同学对数计数（由于需要划分的行列可能是相同的，故而每次划分就是对这条过道的 cnt++）</p>
<p>最后要找到最优解只需要按照计数排序就可以得到</p>
<p>还需要注意的是输出的答案是有序的，故而还需要对划分的行进行排序</p>
<p>故而每一个划分都有数量和行数两个属性，用结构体储存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1e4;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int cnt;</span><br><span class="line">    int id;</span><br><span class="line">&#125;ct1[N],ct2[N];</span><br><span class="line"></span><br><span class="line">bool cmpcnt(node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">    return a.cnt &gt; b.cnt; //从大到小找最优解</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool cmpid(node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">    return a.id &lt; b.id; //从小到大满足输出要求</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int m,n,k,l,d; cin &gt;&gt; m &gt;&gt; n &gt;&gt; k &gt;&gt; l &gt;&gt; d;</span><br><span class="line">    while(d --)</span><br><span class="line">    &#123;</span><br><span class="line">        int x,y,p,q; cin &gt;&gt; x &gt;&gt; y &gt;&gt; p &gt;&gt; q;</span><br><span class="line">        if(x == p)</span><br><span class="line">        &#123;</span><br><span class="line">            int yy = min(y,q);</span><br><span class="line">            ct1[yy].cnt ++;</span><br><span class="line">            ct1[yy].id = yy;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(y == q)</span><br><span class="line">        &#123;</span><br><span class="line">            int xx = min(x,p);</span><br><span class="line">            ct2[xx].cnt ++;</span><br><span class="line">            ct2[xx].id = xx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ct1,ct1 + n,cmpcnt);</span><br><span class="line">    sort(ct2,ct2 + m,cmpcnt);</span><br><span class="line">    sort(ct1,ct1 + l,cmpid);</span><br><span class="line">    sort(ct2,ct2 + k,cmpid);</span><br><span class="line">    for(int i = 0;i &lt; k;i ++) cout &lt;&lt; ct2[i].id &lt;&lt; &quot; &quot;;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    for(int i = 0;i &lt; l;i ++) cout &lt;&lt; ct1[i].id &lt;&lt; &quot; &quot;;</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-贪心国王的问题"><a href="#10-贪心国王的问题" class="headerlink" title="10.贪心国王的问题"></a>10.贪心国王的问题</h3><p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250115204622555.png" alt="image-20250115204622555"></p>
<p>我们对于国王身后的两个点来分析</p>
<p>队列可能是这样的：</p>
<table>
<thead>
<tr>
<th align="left">*</th>
<th align="right">Left</th>
<th align="center">Right</th>
</tr>
</thead>
<tbody><tr>
<td align="left">king:</td>
<td align="right"><img src="/%E7%AE%97%E6%B3%95.assets/equation.svg+xml" alt="img"></td>
<td align="center"><img src="/%E7%AE%97%E6%B3%95.assets/equation-174463624228025.svg+xml" alt="img"></td>
</tr>
<tr>
<td align="left">p1</td>
<td align="right"><img src="/%E7%AE%97%E6%B3%95.assets/equation-174463624228026.svg+xml" alt="img"></td>
<td align="center"><img src="/%E7%AE%97%E6%B3%95.assets/equation-174463624228027.svg+xml" alt="img"></td>
</tr>
<tr>
<td align="left">p2</td>
<td align="right"><img src="/%E7%AE%97%E6%B3%95.assets/equation-174463624228028.svg+xml" alt="img"></td>
<td align="center"><img src="/%E7%AE%97%E6%B3%95.assets/equation-174463624228029.svg+xml" alt="img"></td>
</tr>
</tbody></table>
<p>那么我们计算可得![img](算法.assets&#x2F;times a_1}{b_2}).svg+xml)</p>
<p>队列也有可能是这样的</p>
<table>
<thead>
<tr>
<th align="left">*</th>
<th align="right">Left</th>
<th align="center">Right</th>
</tr>
</thead>
<tbody><tr>
<td align="left">king:</td>
<td align="right"><img src="/%E7%AE%97%E6%B3%95.assets/equation.svg+xml" alt="img"></td>
<td align="center"><img src="/%E7%AE%97%E6%B3%95.assets/equation-174463624228025.svg+xml" alt="img"></td>
</tr>
<tr>
<td align="left">p2</td>
<td align="right"><img src="/%E7%AE%97%E6%B3%95.assets/equation-174463624228028.svg+xml" alt="img"></td>
<td align="center"><img src="/%E7%AE%97%E6%B3%95.assets/equation-174463624228029.svg+xml" alt="img"></td>
</tr>
<tr>
<td align="left">p1</td>
<td align="right"><img src="/%E7%AE%97%E6%B3%95.assets/equation-174463624228026.svg+xml" alt="img"></td>
<td align="center"><img src="/%E7%AE%97%E6%B3%95.assets/equation-174463624228027.svg+xml" alt="img"></td>
</tr>
</tbody></table>
<p>那么我们计算可得![img](算法.assets&#x2F;times a_2}{b_1}).svg+xml)</p>
<p>我们来对比一下两个答案：</p>
<p>![img](算法.assets&#x2F;times a_1}{b_2}).svg+xml)</p>
<p>![img](算法.assets&#x2F;times a_2}{b_1}).svg+xml)</p>
<p>可以替换得：</p>
<p><img src="/%E7%AE%97%E6%B3%95.assets/equation-174463624228130.svg+xml" alt="img"></p>
<p><img src="/%E7%AE%97%E6%B3%95.assets/equation-174463624228131.svg+xml" alt="img"></p>
<p>显然我们可以得到:</p>
<p><img src="/%E7%AE%97%E6%B3%95.assets/frac%7Ba_0%7D%7Bb_2%7D.svg+xml" alt="img"></p>
<p><img src="/%E7%AE%97%E6%B3%95.assets/frac%7Ba_0%7D%7Bb_1%7D.svg+xml" alt="img"></p>
<p>即：<img src="/%E7%AE%97%E6%B3%95.assets/equation-174463624228132.svg+xml" alt="img"></p>
<p><img src="/%E7%AE%97%E6%B3%95.assets/equation-174463624228133.svg+xml" alt="img"></p>
<p>如果<img src="/%E7%AE%97%E6%B3%95.assets/equation-174463624228134.svg+xml" alt="img"></p>
<p>那么易得：</p>
<p><img src="/%E7%AE%97%E6%B3%95.assets/equation-174463624228135.svg+xml" alt="img"></p>
<p>即： ![img](算法.assets&#x2F;times a_1}{b_2}.svg+xml)</p>
<p>变形可得：</p>
<p>![img](算法.assets&#x2F;times b_2.svg+xml)</p>
<p>当![img](算法.assets&#x2F;times b_2.svg+xml)时，我们也能够得到<img src="/%E7%AE%97%E6%B3%95.assets/equation-174463624228136.svg+xml" alt="img">的结论</p>
<p>所以，为了<img src="/%E7%AE%97%E6%B3%95.assets/equation-174463624228137.svg+xml" alt="img">取到最小值，我们需要将![img](算法.assets&#x2F;times b_i.svg+xml)较小的放在前面</p>
<p>这即是需要的贪心的关键点。而后需要写高精度来满足题目</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int fir,sec;</span><br><span class="line">    bool operator &lt; (const node &amp;a)const&#123;</span><br><span class="line">        return fir*sec&lt;a.fir*a.sec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;st[1005];</span><br><span class="line">int sum[5050];</span><br><span class="line">int vis[5050];</span><br><span class="line">int arr[5050];</span><br><span class="line">int len=1,tex=1;</span><br><span class="line">void cheng(int b)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=1;i&lt;=len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vis[i]*=b;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vis[i+1]+=vis[i]/10;</span><br><span class="line">        vis[i]%=10;</span><br><span class="line">    &#125;</span><br><span class="line">    if(vis[len+1]!=0) len++;</span><br><span class="line">    while(vis[len]&gt;10)</span><br><span class="line">    &#123;</span><br><span class="line">        vis[len+1]+=vis[len]/10;</span><br><span class="line">        vis[len]%=10;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void chu(int b)</span><br><span class="line">&#123;</span><br><span class="line">    int t=0,flag=0,ans=0;</span><br><span class="line">    for(int i=len;i&gt;=1;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        t=t*10+vis[i];</span><br><span class="line">        if(t&lt;b&amp;&amp;flag==0) continue;</span><br><span class="line">        else&#123;</span><br><span class="line">            flag=1;</span><br><span class="line">            arr[++ans]=t/b;</span><br><span class="line">            t%=b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(ans&gt;tex)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=1;i&lt;=ans;i++) sum[i]=arr[i];</span><br><span class="line">        tex=ans;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        if(ans==tex)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int i=1;i&lt;=ans;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(arr[i]&gt;sum[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    for(int i=1;i&lt;=ans;i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        sum[i]=arr[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=0;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;st[i].fir&gt;&gt;st[i].sec;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(st+1,st+1+n);</span><br><span class="line">    sum[1]=vis[1]=1;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cheng(st[i-1].fir);</span><br><span class="line">        chu(st[i].sec);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=tex;i++) cout&lt;&lt;sum[i];</span><br><span class="line">    cout&lt;&lt;&quot;\n&quot;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="贪心小结"><a href="#贪心小结" class="headerlink" title="贪心小结"></a>贪心小结</h3><p>贪心问题，一般需要安排某种情况使得结果最优，获得这种最优解的方法一般有两种</p>
<p>一是直接按照题意模拟出情况，最后排序得出最优的情况（例如上面的拼座椅）</p>
<p>二是按照题意推出得到最优解的关键条件，进而对数据进行排序，从而直接得到最优的结果（例如上面的国王的问题和拼数）</p>
<p>当然可以看出，贪心中一个很重要的点就是排序，关键是找到排序的关键词！！！</p>
<h3 id="11-先序排列"><a href="#11-先序排列" class="headerlink" title="11.先序排列"></a>11.先序排列</h3><p>之前写过这里就不写了</p>
<h3 id="12-二分晾衣服"><a href="#12-二分晾衣服" class="headerlink" title="12.二分晾衣服"></a>12.二分晾衣服</h3><p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250117092642591.png" alt="image-20250117092642591"></p>
<p>首先看到问题是求最短时间，故而考虑是二分还是贪心</p>
<p>观察题目，时间少就不能完全烘干，时间长就不满足最短的限制，故而答案是单调的，进而应该选择二分答案</p>
<p>这道题的主要误区在于容易陷入贪心的思维，即想要对烘干顺序进行安排，但注意这里我们已经得出是单调二分，故而思维应该着重在 <strong>验证</strong></p>
<p>怎么写这个 check 函数呢，现在的这个时间需要让所有衣服都被烘干，那么只需要算出把每件衣服全都烘干的时间，跟此时的答案比较即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bool check(int x)</span><br><span class="line">&#123;</span><br><span class="line">	int b[N];</span><br><span class="line">	memcpy(b,a,sizeof a);</span><br><span class="line">	ll ci = 0; //第一个容易错的点，最终的时间和是可能爆int的</span><br><span class="line">	for(int i = 1;i &lt;= n;i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		b[i] -= x; //x的时间，每一个时间减少1水分，x时间减少x水分</span><br><span class="line">		if(b[i] &gt; 0) ci += ceil((double)b[i] / (k - 1)); //由于每分钟自己减少的1已经计算，所以会额外减少k-1水分。</span><br><span class="line">		//为什么要用ceil是由于必须要把每件衣服都烘干，宁多不少</span><br><span class="line">	&#125;</span><br><span class="line">	return ci &lt;= x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还注意一个特判，如果烘干机每分钟烘干的水分比自然减少的 1 还少的话，那么就不用烘干机，所有衣服水分中的最大值作为时间就可以烘干所有的衣服。</p>
<p>下面看完整代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line">const int N = 1e5 + 10;</span><br><span class="line">int a[N],n,k;</span><br><span class="line"></span><br><span class="line">bool check(int x)</span><br><span class="line">&#123;</span><br><span class="line">    int b[N];</span><br><span class="line">    ll sum = 0;</span><br><span class="line">    memcpy(b,a,sizeof a);</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        b[i] -= x;</span><br><span class="line">        if(b[i] &gt; 0) sum += ceil((double)b[i] / (k - 1));</span><br><span class="line">    &#125;</span><br><span class="line">    if(sum &gt; x) return false;</span><br><span class="line">    return true ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    int mx = 0;</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        mx = max(mx,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    if(k &lt;= 1) &#123;</span><br><span class="line">        cout &lt;&lt; mx &lt;&lt; endl;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int l = 0, r = 0x3f3f3f3f;</span><br><span class="line">    while(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid = (l + r) / 2;</span><br><span class="line">        if(check(mid)) r = mid;</span><br><span class="line">        else l = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; l;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-表达式求值"><a href="#13-表达式求值" class="headerlink" title="13.表达式求值"></a>13.表达式求值</h3><p>作为一道很典的题，一般是用栈分别存下数字和运算符，但不可避的问题是</p>
<h3 id="14-并查集"><a href="#14-并查集" class="headerlink" title="14.并查集"></a>14.并查集</h3><p>这道题虽然是并查集的模板题，但还要用字符串去储存名字，所以可以很直观地认识并查集的原理，在这里记录一下</p>
<h3 id="15-牛客周赛-a-b（2）"><a href="#15-牛客周赛-a-b（2）" class="headerlink" title="15.牛客周赛 a+b（2）"></a>15.牛客周赛 a+b（2）</h3><p>（因为是赛后随便看了一下所以没有做后面的题） 这里记录一下 b，不知道应该算是博弈还是贪心</p>
<p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250121111842766.png" alt="image-20250121111842766"></p>
<p>其实是一道思维题，不管是平均数还是中位数，最优的情况一定是能拿到足够多的大数，故而 k1k2 对于最优情况的考虑是没有意义的</p>
<p>由于这道题是需要自己先选，故而想要让菲菲拿到最少的大数，故而最优的划分情况应该是自己拿前 n-1 个数字，只留下最后一个数字给菲菲</p>
<p>又由于平均数肯定会小于或等于前 n-1 个数，那么是否拥有必胜策略就只需要看最后一个数是否大于前面 n-1 个数即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 2e5 + 10;</span><br><span class="line">int a[N];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,k1,k2; cin &gt;&gt; n &gt;&gt; k1 &gt;&gt; k2;</span><br><span class="line">    int mx = -1;</span><br><span class="line">    for(int i = 0;i &lt; n;i ++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        mx = max(mx,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    if(mx &gt; a[n-1]) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;</span><br><span class="line">    else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-cfdiv2（2）"><a href="#16-cfdiv2（2）" class="headerlink" title="16.cfdiv2（2）"></a>16.cfdiv2（2）</h3><p>a.<img src="/%E7%AE%97%E6%B3%95.assets/image-20250121113015971.png" alt="image-20250121113015971"></p>
<p>其实就是一个简单的模拟，但需要关注的是怎么最简单的得出</p>
<p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250121113124881.png" alt="image-20250121113124881"></p>
<p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250121113139110.png" alt="image-20250121113139110"></p>
<p>观察样例图解可知，其实</p>
<p>$$<br>整体周长 &#x3D; 每一次移动形成的矩形的周长 - 重叠部分矩形的周长<br>$$</p>
<p>重叠部分的矩形的对顶点实则是</p>
<p>$$<br>上一个正方形的右上顶点和下一个正方形的左下起点<br>$$</p>
<p>故而直接每次记录即可（因为保证了肯定是向左上方移动的）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while(t --)</span><br><span class="line">    &#123;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        int n, m;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        int a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        ans += 4 * m;</span><br><span class="line">        n = n - 1;</span><br><span class="line">        while(n --)</span><br><span class="line">        &#123;</span><br><span class="line">            int x1, y1;</span><br><span class="line">            cin &gt;&gt; x1 &gt;&gt; y1;</span><br><span class="line">            ans += 4 * m;</span><br><span class="line">            if(m &gt; x1 &amp;&amp; m &gt; y1)</span><br><span class="line">                ans -= (m - x1 + m - y1) * 2;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c.</p>
<h3 id="17-牛客寒假训练营-1"><a href="#17-牛客寒假训练营-1" class="headerlink" title="17.牛客寒假训练营 1"></a>17.牛客寒假训练营 1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比赛链接https://ac.nowcoder.com/acm/contest/95323（包括题目和代码）</span><br></pre></td></tr></table></figure>

<h4 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h4><p>这次比赛发现的最大的问题就是关于提前终止读入导致数据错位的问题，即比如说在多组数据中，在某一组的读入环节提前终止了读入，就会导致后续的读入都发生错误</p>
<p>比如说<img src="/%E7%AE%97%E6%B3%95.assets/image-20250122141308415.png" alt="image-20250122141308415"></p>
<p>在读入数组数据的过程中出现 1 就停止，就会导致后续数据错位</p>
<p>正确做法应该是给一个标记，在所有数据读入完后再输出</p>
<p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250122141413358.png" alt="image-20250122141413358"></p>
<h4 id="a"><a href="#a" class="headerlink" title="a."></a>a.</h4><p>简单逻辑题，什么数能够确保它不是任何数的倍数，任何数也不是它的倍数呢</p>
<p>对于第一个限制条件，很显然它需要是一个倍数，对于第二个限制条件，只需要它比数组内可能的最大值大即可</p>
<p>数组内的数的范围是 1e9，故而直接输出一个大于 1e9 的数即可</p>
<h4 id="b"><a href="#b" class="headerlink" title="b."></a>b.</h4><p>要求找一条路能够不重不漏地通过树上的所有节点，那么什么时候才可能出现这样的路径呢</p>
<p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250122141923225.png" alt="image-20250122141923225"></p>
<p>显然这棵树必须要是链状的才能满足</p>
<p>而要判断是不是链状的，我们只需要把这个树以图的方式储存下来，判断其的入度即可，只要度数大于 2，则树肯定非链状，直接输出-1 即可。</p>
<p>如果已经证明是链状的，只需要找到度数为 1 的点，根据上图可以看出，度数为 1 的点一定是起点或者终点，故而输出两个找到的点即可</p>
<p>这里的代码是用邻接表存的</p>
<h4 id="d"><a href="#d" class="headerlink" title="d."></a>d.</h4><p>这里 wa 了好几发的主要原因还是数据错位的问题，这里就不再多说了</p>
<p>只是这里再次说一下，关于数据出现的次数问题，用哈希表可以比较简便地记录，如果是记录出现次数就使用 intint 的哈希表即可，如果是记录是否出现过就直接用 intbool 的哈希表即可</p>
<h4 id="e"><a href="#e" class="headerlink" title="e."></a>e.</h4><p>非常有意思的一道题，其实在面对这种题的时候我一般都是很手足无措的，听完讲解后觉得可以这么想</p>
<p>对于这种经过操作构造目标，求操作次数的题，我们可以先关注结论，即预期的目标，再反推是怎么得来的，一般这种问题中秋最小操作次数都跟模拟无关，而是我们需要从中找到规律然后贪心地解决</p>
<p>对于这个题，不管怎么操作，最终数组都会变成 a…aaab..bbbb 的形式，即前半部分变为若干个 a 后半部分变为若干个 b，前后部分数目相同，并且这两部分变成多少（即 ab 的值）是无所谓的，我们只需要关注操作次数最小</p>
<p>分开考虑，那么问题就变成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数轴上有n个数，在数轴上找到一个数，使得数轴上的所有数移到该点所需的步数最少</span><br></pre></td></tr></table></figure>

<p>即变成了 <strong>货仓选址问题</strong> 也就是中位数定理</p>
<p><strong>中位数定理：给定一个数组，每次操作加 1 或者减 1，将所有元素变成相同的最小操作次数则是将所有元素变成中位数即可。</strong></p>
<p>有一个特判是可能两边的中位数相等，只需要任意一边改变一下即可，我们可以枚举几种改变取最优（枚举的方法非常优美）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    int n; cin &gt;&gt; n;</span><br><span class="line">    int a[n];</span><br><span class="line">    for(int i = 0;i &lt; n;i ++) cin &gt;&gt; a[i];</span><br><span class="line">    sort(a,a + n);</span><br><span class="line">    int l1 = a[(n / 2) / 2];</span><br><span class="line">    int l2 = a[n/2 + (n / 2) / 2];</span><br><span class="line">    ll ans = 1e18;</span><br><span class="line">    for(auto xl : &#123;l1,l1 - 1&#125;)&#123;</span><br><span class="line">        for(auto xr : &#123;l2,l2 + 1&#125;)&#123;</span><br><span class="line">            if(xl == xr) continue;</span><br><span class="line">            ll res = 0 ;</span><br><span class="line">            for(int i = 0;i &lt; n / 2;i ++) &#123;</span><br><span class="line">                res += abs(a[i] - xl);</span><br><span class="line">                res += abs(a[n / 2 + i] - xr);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = min(ans,res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t; cin &gt;&gt;  t;</span><br><span class="line">    while(t --)&#123;</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="g"><a href="#g" class="headerlink" title="g."></a>g.</h4><p>很经典的一种数组操作，即对左右加一减一，这样操作的关键点在于不管操作多少次数组中所有数的和都是不会发生改变的</p>
<p>故而第一个判断能不能成为排列只需要判断这个数组的和跟排列的和相等于否即可，如果相等的话就可能变为排列，不相等的话就不能</p>
<p>至于如何计算最小操作次数，一开始想的是排序数组后算出每一个位置上跟期望值之间的差是多少，但实际上这样有负有正不能算出来最小操作次数，相反，只需要算期望差中的正数或者负数即可，因为每一次操作加一和减一都是成对出现的，故而只关注一边即能计算出最小操作次数。</p>
<p>同样的思路，不管正负计算每个位置上差值的绝对值，最后除以二也能得到最小操作次数</p>
<h4 id="h"><a href="#h" class="headerlink" title="h."></a>h.</h4><p>其实是一个贪心问题，放置每一个数都需要选择一个区间，为了能够完全地构造，我们需要尽可能地在每次选择的时候都让剩余的区间能够放的数更多，例如现在能放 2 的区间有[2,7]和[2,4]那么最优的选择就是放在[2,4],因为另一个区间可以放的数字更多</p>
<p>那么问题就转化为了，首先选择所有可以放置的区间（左边界），然后按照右边界排序（最优选择），故而对于区间的排序应该以左边界为第一关键字，以右边界为第二关键字。</p>
<p>怎么做到每次选择都可以最优呢，就可以用优先队列（一个小根堆）按顺序储存完每一个区间，每次拿出再弹出即可</p>
<p>注意在优先队列里重载运算符（这道题你让我写得好苦啊！）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef pair&lt;int, int&gt; pp;</span><br><span class="line"></span><br><span class="line">//重载运算符使存放区间的vec按照左边界排好序</span><br><span class="line">struct node&#123;</span><br><span class="line">    pp fan;</span><br><span class="line">    int pos;</span><br><span class="line">    bool operator&lt;(const node &amp;a)&#123;</span><br><span class="line">        return fan.first &lt; a.fan.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//重载优先队列的比较器</span><br><span class="line">struct compare&#123;</span><br><span class="line">    bool operator()(pp a,pp b)&#123;</span><br><span class="line">        return a.first &gt; b.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;node&gt;a(n + 1);</span><br><span class="line">    vector&lt;int&gt; ans(n + 1, -1);</span><br><span class="line">    priority_queue&lt;pp, vector&lt;pp&gt;, compare&gt; b; //贪心，我们需要找到右区间最小的</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        int l,r; cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        a[i].fan = &#123;l,r&#125;;</span><br><span class="line">        a[i].pos = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a.begin(),a.end());</span><br><span class="line">    int cnt = 1;</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++)&#123;//从1到n开始放数</span><br><span class="line">        while(cnt &lt;= n &amp;&amp; a[cnt].fan.first &lt;= i) &#123; //左区间小于当前数就把这些区间放进去</span><br><span class="line">            b.push(&#123;a[cnt].fan.second,a[cnt].pos&#125;);</span><br><span class="line">            cnt ++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(b.empty()) &#123;</span><br><span class="line">            cout &lt;&lt; -1 &lt;&lt; endl;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        auto t = b.top(); b.pop();</span><br><span class="line">        if(t.first &lt; i) &#123;</span><br><span class="line">            cout &lt;&lt; - 1 &lt;&lt; endl;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            ans[t.second] = i; //把数字放到对应的位置上</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++) cout &lt;&lt; ans[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="18-牛客寒假训练营-2"><a href="#18-牛客寒假训练营-2" class="headerlink" title="18.牛客寒假训练营 2"></a>18.牛客寒假训练营 2</h3><h4 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h4><p>由于回老家的原因这场比赛没打，没想到这场比赛不会做的题还挺多的，感觉最大的问题还是确实不太会做字符串问题的题了。特别是关于子串之类的问题。</p>
<h4 id="a-1"><a href="#a-1" class="headerlink" title="a."></a>a.</h4><p>直接判断输入的数字里有没有不能出现的数字即可，注意如果是多组数据的话记得不能提前终止</p>
<h4 id="b-1"><a href="#b-1" class="headerlink" title="b."></a>b.</h4><p>一开始想偏了想到了二分，但后来发现，想要让它至少比一般的碗都小，直接找到中位数，然后中位数减 1 不就恰好能够满足条件吗，所以做题还是多从思维入手</p>
<h4 id="c"><a href="#c" class="headerlink" title="c."></a>c.</h4><h4 id="d-1"><a href="#d-1" class="headerlink" title="d."></a>d.</h4><p>一道字符串的贪心和构造问题，关键在于如何</p>
<h2 id="蓝桥杯真题补题"><a href="#蓝桥杯真题补题" class="headerlink" title="蓝桥杯真题补题"></a>蓝桥杯真题补题</h2><h3 id="十四届蓝桥杯-cb-省赛"><a href="#十四届蓝桥杯-cb-省赛" class="headerlink" title="十四届蓝桥杯 cb 省赛"></a>十四届蓝桥杯 cb 省赛</h3><h4 id="a-日期统计"><a href="#a-日期统计" class="headerlink" title="a 日期统计"></a>a 日期统计</h4><p>1.想法方面 直接八重循环去遍历所有的八位字符串显然是不现实的 所以应该先处理出所有的 2023 年的日期 然后对于每个日期都在原字符串中进行匹配</p>
<p>启发是当一个方法行不通的时候可以换一个角度想 比如这里就把从原字符串中找字符串变成了从原字符串中匹配字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int month[] = &#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;;</span><br><span class="line">char temp[8];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int ans = 0;</span><br><span class="line">	string s = &quot;5686916124919823647759503875815861830379270588570991944686338516346707827689565614010094809128502533&quot;;</span><br><span class="line">	for(int i = 1;i &lt;= 12;i ++) &#123;</span><br><span class="line">		for(int j = 1;j &lt;= month[i];j ++) &#123;</span><br><span class="line">			sprintf(temp,&quot;2023%02d%02d&quot;,i,j);</span><br><span class="line">			int id = 0;</span><br><span class="line">			for(int k = 0;k &lt; 100;k ++)&#123;</span><br><span class="line">				if(s[k] == temp[id]) &#123;</span><br><span class="line">					id ++;</span><br><span class="line">				&#125;</span><br><span class="line">				if(id == 8) &#123;</span><br><span class="line">					ans ++;</span><br><span class="line">					break; （因为如果日期一样的话只算作一个）</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="b01-串的熵"><a href="#b01-串的熵" class="headerlink" title="b01 串的熵"></a>b01 串的熵</h4><p>这道题还是想多了的缘故 其实对于填空题不用进行太复杂的数学推理论证 这里也是直接考虑暴力枚举即可 让计算机来完成大部分的运算量</p>
<p>可以做的一些优化是 由于 0 的数量要小于 1 的数量 所以 0 的数量肯定是要小于 n &#x2F; 2 的</p>
<p>还需要注意的是对于浮点数 在判断相等的时候不能直接用等于 要考虑精度的问题</p>
<p>(精度可以先默认成 0.01 如果这时输出的答案不止一个的话就可以考虑再提高精度)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	double ans = 11625907.5798;</span><br><span class="line">	double n = 23333333;</span><br><span class="line">	for(int i = 0;i &lt; n / 2;i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		double shang = 0;</span><br><span class="line">		shang -= i * (i / n) * log2(i / n) + (n - i) * ((n - i) / n ) * log2((n - i) / n);</span><br><span class="line">		if(abs(shang - ans) &lt; 0.01 ) &#123;</span><br><span class="line">			cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="c-冶炼金属"><a href="#c-冶炼金属" class="headerlink" title="c 冶炼金属"></a>c 冶炼金属</h4><p>其实是一个直接推导公式的题 关键是要根据题目推导出 v 的范围</p>
<p>1.根据题目有以下公式推导： 因为<br><strong>⌊𝐴&#x2F;𝑉⌋&#x3D;𝐵 有 𝐵&lt;&#x3D;𝐴&#x2F;𝑉&lt;𝐵+1</strong><br>取倒数有<br><strong>1&#x2F;(𝐵+1)&lt;𝑉&#x2F;𝐴&lt;&#x3D;1&#x2F;𝐵</strong><br>两边同时乘 𝐴:</p>
<p><strong>𝐴&#x2F;(𝐵+1)&lt;𝑉&lt;&#x3D;𝐴&#x2F;𝐵</strong> 2.这样，区间左边取<br><strong>𝐴&#x2F;(𝐵+1)+1 最大值</strong>（这里要加 1 是因为其实是取不到原数的，取到的应该是下一个整数），右边取 <strong>𝐴&#x2F;𝐵 最小值即可</strong></p>
<p>最后把每一个数据中 v 的范围取一个交集即可以满足所有的条件</p>
<p>注意在数轴上画一下区间取交集是怎么取的 应该是</p>
<p><strong>左边界取较大 右边界取较小</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int mn = 1; int mx = 1e9;</span><br><span class="line">	int n; cin &gt;&gt; n;</span><br><span class="line">	for(int i = 0;i &lt; n;i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		int a,b; cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		mn = max(mn,a / (b + 1) + 1);</span><br><span class="line">		mx = min(mx,a / b);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; mn &lt;&lt; &quot; &quot; &lt;&lt; mx;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反思一下可能后面看到这样的上下取整问题都可以这样推导一下下</p>
<h4 id="d-飞机降落"><a href="#d-飞机降落" class="headerlink" title="d 飞机降落"></a>d 飞机降落</h4><p>引发一个大问题 就是什么时候用 dfs 除了路径 迷宫这些问题外其实很少想到用 dfs</p>
<p>那什么时候可以用到 DFS 呢？总结来说，当问题需要枚举所有可能的解，并且问题的结构适合逐步构建解的时候，可以考虑 DFS。例如排列问题、组合问题、路径问题等。在这种情况下，DFS 通过递归或者栈的方式，尝试每一种可能的选择，并回溯到上一步尝试其他选择，直到找到解或者遍历完所有可能性。即如果我们想要枚举一下答案的某一种情况然后对于每一种情况判断其合法性的话我们就可以用 dfs</p>
<p>然后分析问题，其实是问我们有没有一种排列方式能够使得每一架飞机都能够成功平安降落 数据量要比较小 所以我们用 dfs 来枚举每一种排列方式 看看有没有合法的就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 15;</span><br><span class="line"></span><br><span class="line">struct plane&#123;</span><br><span class="line">  int t; int d; int l;</span><br><span class="line">&#125;p[N];</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">bool vis[N];</span><br><span class="line">bool flag;</span><br><span class="line"></span><br><span class="line">void  dfs(int u,int last)</span><br><span class="line">&#123;</span><br><span class="line">  if(u == n) &#123;</span><br><span class="line">    flag = true;</span><br><span class="line">    return ;</span><br><span class="line">  &#125;</span><br><span class="line">  for(int i = 0;i &lt; n;i ++) //开始遍历排列</span><br><span class="line">  &#123;</span><br><span class="line">    if(!vis[i] &amp;&amp; p[i].t + p[i].d &gt;= last)</span><br><span class="line">    &#123;</span><br><span class="line">      vis[i] = true;</span><br><span class="line">      dfs(u + 1,max(p[i].t,last) + p[i].l);</span><br><span class="line">      vis[i] = false; // 回溯</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int t; cin &gt;&gt; t;</span><br><span class="line">  while(t --)</span><br><span class="line">  &#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for(int i = 0;i &lt; n;i ++) cin &gt;&gt; p[i].t &gt;&gt; p[i].d &gt;&gt; p[i].l;</span><br><span class="line">    flag = false; dfs(0,0);</span><br><span class="line">    if(!flag) cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;</span><br><span class="line">    else cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="e-接龙数列"><a href="#e-接龙数列" class="headerlink" title="e 接龙数列"></a>e 接龙数列</h4><p>其实这是一道 dp 的题 我暂时还不会 就只把暴力 dfs 放在这里吧</p>
<p>但是其实这里要想一下为什么会想到 dfs</p>
<p>该题要求的是最少从中删除多少个数 可以使剩下的序列是接龙序列 但显然考虑删除是很难有解法的 所以不如换个思路想 这个问题的另一种说法不就是 <strong>最多能剩下几个数可以使得当前剩下的序列是一个接龙序列</strong> 也就是说 我们只需要 <strong>枚举出所有可能的接龙序列</strong> 然后取取这些接龙序列长度的最大值 l 那么最少需要删除的数字就是 n - l 了！</p>
<p>那么怎么枚举这些序列呢 可以作这样的思考</p>
<p>从某一个数开始 每一个数都面临着选或者不选的情况 所以最终可以形成这样一颗二叉树</p>
<p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250305195433802.png" alt="image-20250305195433802"></p>
<p>现在就能看出来 想求出最终的排列其实就是一个树的遍历 也就是一个 dfs</p>
<p>当然 直接这样 dfs 的时间复杂度 是 <strong>2 ^ n</strong> 显然能过的测试点太少了 所以我们应该在搜索过程中再进行一个剪枝，即我们每一步都只需要符合题意的解 即后一位的首位为前一位的末位</p>
<p>最终这样就能过大概百分之五十的测试点 其实也应该比较够用了吧</p>
<h4 id="f-岛屿个数"><a href="#f-岛屿个数" class="headerlink" title="f 岛屿个数"></a>f 岛屿个数</h4><p>似乎是个 dfs + bfs 的题 有点太难了 看不懂思密达</p>
<h4 id="g-子串简写"><a href="#g-子串简写" class="headerlink" title="g 子串简写"></a>g 子串简写</h4><p>暴力拿了 14 分 后面运行超时了 其实仔细想一下优化还是挺简单的 用一个前缀和储存一下就好了</p>
<p>这道题的意思就是在字符串中找到一个长度至少为 k 的以 c1 开头 c2 结尾的子串</p>
<p>考虑优化我们可以先用前缀和记录每个位置和之前包含 c1 的数量 然后去遍历字符串找到为 c2 的点 如果距离大于 k 的话那么就将结果++</p>
<p><strong>记得开 long long</strong> 不然会错一个测试点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define int long long</span><br><span class="line">const int N = 5e5 + 10;</span><br><span class="line">int c[N];</span><br><span class="line">int cnt = 0;</span><br><span class="line"></span><br><span class="line">signed main()</span><br><span class="line">&#123;</span><br><span class="line">    int k; string s; char a,b; cin &gt;&gt; k &gt;&gt; s &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    int n = s.length();</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++) c[i] += c[i - 1] + (s[i - 1] == a ? 1 : 0);</span><br><span class="line">    for(int i = k;i &lt;= n;i ++) if(s[i - 1] == b) cnt += c[i - k + 1];</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但其实还在题解区看到了一个更妙妙的解法即用一个类似滑动窗口的思想 固定好子串的长度至少为 k</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int K;</span><br><span class="line">long long ans = 0, c1_sum = 0;</span><br><span class="line">string S;</span><br><span class="line">char c1, c2;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; K &gt;&gt; S &gt;&gt; c1 &gt;&gt; c2;</span><br><span class="line">    for (int i = K-1, j = 0; i &lt; S.length(); i++, j++) &#123; //注意循环的初始条件 这样可以使得子串的长度至少为k</span><br><span class="line">        if (S[j] == c1) c1_sum++;       // 记录当前起始位置j是否为c1 子串的起点</span><br><span class="line">        if (S[i] == c2) ans += c1_sum;  // 若i是c2，累加合法子串数 子串的终点</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于子串的起点是从左往右遍历的 所以当 if (S[i] &#x3D;&#x3D; c2) ans +&#x3D; c1_sum; 的时候 加上的 c1_sum 即子串可能的起点数目是 j 往前的所有点 所以保证了子串的长度 &gt;&#x3D; k</p>
<p>妙啊！</p>
<h4 id="h-整数删除"><a href="#h-整数删除" class="headerlink" title="h 整数删除"></a>h 整数删除</h4><p>这道题的难度其实在于每次动态地判断最小的整数 其实现在看来可以很快地想到用小根堆来实现</p>
<h2 id="天梯赛选拔模拟"><a href="#天梯赛选拔模拟" class="headerlink" title="天梯赛选拔模拟"></a>天梯赛选拔模拟</h2><h3 id="静静的推荐"><a href="#静静的推荐" class="headerlink" title="静静的推荐"></a>静静的推荐</h3><p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250310162919117.png" alt="image-20250310162919117"></p>
<p>关键只在于对题意的理解</p>
<p>原则上一批推荐名单应该是严格单调递增（即不能有相同的） 但如果学生的分数一样但是 pat 成绩达标的话就不受影响 也可以加入名单</p>
<p>那么问题就转化成了这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、如果学生天梯赛分数不足175 不考虑</span><br><span class="line">2、如果学生天梯赛分数不小于175但是pat分数不够的话那么就应该遵循原则 即每个批次出现一次 最多只能出现k次（k个批次）</span><br><span class="line">3、日光学生天梯赛分数不小于175同时pat分数也够的话那么就可以无视原则 随便出现了 （因为批次内没有人数要求）</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 300;</span><br><span class="line">int ci[N];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n,k,s; cin &gt;&gt; n &gt;&gt; k &gt;&gt; s;</span><br><span class="line">	int ans = 0;</span><br><span class="line">	for(int i = 0;i &lt; n;i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		int t,p; cin &gt;&gt; t &gt;&gt; p;</span><br><span class="line"></span><br><span class="line">		if(t &gt;= 175)</span><br><span class="line">		&#123;</span><br><span class="line">			if(p &gt;= s) ans ++;</span><br><span class="line">			else  if(ci[t] &lt; k) &#123;</span><br><span class="line">					ci[t] ++;</span><br><span class="line">					ans ++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="病毒溯源"><a href="#病毒溯源" class="headerlink" title="病毒溯源"></a>病毒溯源</h3><p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250310172705840.png" alt="image-20250310172705840"></p>
<p>理解一下题意其实意思就是在一颗有根的树里找到最长路径 如果路径一样长的话就输出编号较小的那条路径</p>
<p>应该从这个题里学到的知识点有 ： 单链表存图 根节点的找法 有根树的遍历</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 110;</span><br><span class="line">int n;</span><br><span class="line">int h[N],e[N],ne[N],idx;</span><br><span class="line">int son[N];</span><br><span class="line">bool st[N];</span><br><span class="line"></span><br><span class="line">void add(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">	e[idx] = b,ne[idx] = h[a],h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int dfs(int u)</span><br><span class="line">&#123;</span><br><span class="line">	son[u] = -1;</span><br><span class="line">	int len = 0;</span><br><span class="line">	for(int i = h[u];i != - 1;i = ne[i])</span><br><span class="line">	&#123;</span><br><span class="line">		int j = e[i];</span><br><span class="line">		int d = dfs(j);</span><br><span class="line">		if(len &lt; d) len = d,son[u] = j;</span><br><span class="line">		else if(len == d) son[u] = min(son[u],j);</span><br><span class="line">	&#125;</span><br><span class="line">	return len + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	memset(h,-1,sizeof h);</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	for(int i = 0;i &lt; n;i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		int k; cin &gt;&gt; k;</span><br><span class="line">		if(k == 0) continue;</span><br><span class="line">		for(int j = 0;j &lt; k;j ++)</span><br><span class="line">		&#123;</span><br><span class="line">			int x; cin &gt;&gt; x;</span><br><span class="line">			add(i,x);</span><br><span class="line">			st[x] = true;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int root = 0;</span><br><span class="line"></span><br><span class="line">	while(st[root]) root ++;</span><br><span class="line"></span><br><span class="line">	int mx = dfs(root);</span><br><span class="line">	cout &lt;&lt; mx &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; root ;</span><br><span class="line"></span><br><span class="line">	while(son[root] != -1)</span><br><span class="line">	&#123;</span><br><span class="line">		root = son[root];</span><br><span class="line">		cout &lt;&lt; &quot; &quot; &lt;&lt; root;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="清点代码"><a href="#清点代码" class="headerlink" title="清点代码"></a>清点代码</h3><p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250310194915375.png" alt="image-20250310194915375"></p>
<p>stl 大模拟 需要注意的点可能是不要写昏头了</p>
<p>还有就是需要统计出现数量的时候可以用的几种数据结构 ： set map 哈希</p>
<p>但由于这里既要输出出现次数又要输出所有输出 所以用 map 最方便</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef pair&lt;int,vector&lt;int&gt;&gt; pp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">map&lt;vector&lt;int&gt;,int&gt; cnt;</span><br><span class="line">vector&lt;pp&gt; ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for(int i = 0;i &lt; n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;int&gt; temp;</span><br><span class="line">        for(int j = 0;j &lt; m;j ++) &#123;</span><br><span class="line">            int x; cin &gt;&gt; x;</span><br><span class="line">            temp.push_back(x);</span><br><span class="line">        &#125;</span><br><span class="line">        cnt[temp] ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(auto p : cnt) ans.push_back(&#123;-p.second,p.first&#125;); // 注意，排序是默认从小到大排序的 但我们需要按照出现次数从大到小排  所以我们直接放相反数进去 最后取相反数的话就能满足题意了</span><br><span class="line">    sort(ans.begin(),ans.end()); //pair的排序是默认先排first 再排 second 同时vector的排序是默认字典序的  所以用上面两个特性就很方便地按照题目要求输出了</span><br><span class="line">    cout &lt;&lt; cnt.size() &lt;&lt; endl;</span><br><span class="line">    for(auto p : ans)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; -p.first ;</span><br><span class="line">        for(auto x : p.second)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot; &quot; &lt;&lt; x;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="哲哲打游戏"><a href="#哲哲打游戏" class="headerlink" title="哲哲打游戏"></a>哲哲打游戏</h3><p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250310205518112.png" alt="image-20250310205518112"></p>
<p>还是一道大模拟 比较恶心的一点在于所有的起点都是从 1 开始的 所以需要处理好索引问题防止出现越界的情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 110;</span><br><span class="line">const int M = 1e5 + 10;</span><br><span class="line">int cun[N];</span><br><span class="line">vector&lt;int&gt; a[M];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n,m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	for(int i = 1;i &lt;= n;i ++) //这里从1开始计数保证了是从1开始的</span><br><span class="line">	&#123;</span><br><span class="line">		int k; cin &gt;&gt; k;</span><br><span class="line">		for(int j = 1;j &lt;= k;j ++)</span><br><span class="line">		&#123;</span><br><span class="line">			int x; cin &gt;&gt; x;</span><br><span class="line">			a[i].push_back(x); //注意这里直接push_back的话元素是从0的位置开始的</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	int now = 1; //从1开始</span><br><span class="line">	for(int i = 1;i &lt;= m;i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		int num; cin &gt;&gt; num;</span><br><span class="line">		if(num == 0)</span><br><span class="line">		&#123;</span><br><span class="line">			int j; cin &gt;&gt; j;</span><br><span class="line">			now = a[now][j - 1]; //前面解释了 二维是从0开始的 所以这里需要-1</span><br><span class="line">		&#125;</span><br><span class="line">		else if(num == 1)</span><br><span class="line">		&#123;</span><br><span class="line">			int j; cin &gt;&gt; j;</span><br><span class="line">			cun[j] = now;</span><br><span class="line">			cout &lt;&lt; now &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(num == 2)</span><br><span class="line">		&#123;</span><br><span class="line">			int j; cin &gt;&gt; j;</span><br><span class="line">			now = cun[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; now &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完全二叉树的层序遍历"><a href="#完全二叉树的层序遍历" class="headerlink" title="完全二叉树的层序遍历"></a>完全二叉树的层序遍历</h3><p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250310211442315.png" alt="image-20250310211442315"></p>
<p>之前找二叉树的几种遍历的时候其实自己用的方法就是递归吧 所以这里也应该想到要使用递归</p>
<p>特殊之处在于这里的输入是放在函数里面进行的 因为每次我们都只输入一下根</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">int tree[40];</span><br><span class="line"></span><br><span class="line">void create(int u)</span><br><span class="line">&#123;</span><br><span class="line">	if(u &lt;= n)&#123;</span><br><span class="line">		create(2 * u);</span><br><span class="line">		create(2 * u + 1);</span><br><span class="line">		cin &gt;&gt; tree[u];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	create(1);</span><br><span class="line">	for(int i = 1;i &lt;= n;i ++) cout &lt;&lt; tree[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">	cout &lt;&lt; tree[n] &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="杂题（具体代码都在杂题文件夹里）"><a href="#杂题（具体代码都在杂题文件夹里）" class="headerlink" title="杂题（具体代码都在杂题文件夹里）"></a>杂题（具体代码都在杂题文件夹里）</h2><h3 id="k-倍区间"><a href="#k-倍区间" class="headerlink" title="k 倍区间"></a>k 倍区间</h3><p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250314083741933.png" alt="image-20250314083741933"></p>
<p><strong>前缀和+数学</strong></p>
<p>如果用前缀和直接暴力遍历的话 只能过两个测试点 但是这种做法也想不到其他的优化了 所以应该关注其他的性质</p>
<p><strong>数学性质推导</strong></p>
<p>假设一个数列为 a1,a2,a3,….,an，一个小的前缀区间 s1 为 a1,a2,a3,….,ap,还有一个大的前缀区间 s2 为 a1,a2,a3,…,a(p+m)，p,p+m&lt;n，</p>
<p>当我们对 s1、s2 的和分别取模，得到</p>
<p><strong>(a1+a2+a3+…+ap)%k 和(a1+a2+a3+…+ap+m)%k</strong>，</p>
<p>当这两个值相等的时候，我们则可以列出这个等式：</p>
<p><strong>(a1+a2+a3+…+ap)%k-(a1+a2+a3+…+ap+m)%k&#x3D;0</strong><code>，</code></p>
<p><strong>根据取模也具有分配律</strong>可得到，</p>
<p><strong>(a1+a2+a3+…+ap-a1-a2-a3-…-ap+m)%k&#x3D;0</strong></p>
<p>因此可以推出结论，<strong>s2-s1 得出的区间必定为 k 倍区间。</strong></p>
<p>那么我们可以记录每一个区间和对 k 取模的值 储存一下这些值的数量 即取模值相等的区间 在这些区间中任选两个相减的区间必定为 k 倍区间</p>
<p>所以问题就转换为了从 x 个取模值相等的区间中任选两个（组合数）</p>
<p>那 n 个中取任何两个区间都可以组成 k 倍区间，问有多少 k 倍区间，就转换成 n 个区间取两个的情况有多少个，就是 Cn2&#x3D;n*(n-1)&#x2F;2，所以对于每个%k 值相等的区间都添加一次组合就可以算出总共有多少 k 倍区间了</p>
<h3 id="分巧克力"><a href="#分巧克力" class="headerlink" title="分巧克力"></a>分巧克力</h3><p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250314085801444.png" alt="image-20250314085801444"></p>
<p><strong>二分</strong></p>
<p>看到最值先想一下二分 然后想一下是否满足二分条件 如果二分边长的话<strong>sum +&#x3D; (h &#x2F; u) * (w &#x2F; u);</strong> 需要 sum &#x3D;&#x3D; k</p>
<p>k 越大 sum 越小 也就是说这个表达式是满足单调性的 所以可以二分</p>
<h3 id="玩三国杀"><a href="#玩三国杀" class="headerlink" title="玩三国杀"></a>玩三国杀</h3><p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250314090738027.png" alt="image-20250314090738027"></p>
<p><strong>贪心</strong></p>
<p>关键在于理解题意 需要所有的事都确定发生与否 问最多发生多少个事件能使得某一国胜利 所以关键问题在于怎么去考虑每件事发生或没有发生的影响</p>
<p>如果单纯记录发生或者没有发生的状态 即写一个 dfs 暴搜 每个事件都有发生或没有发生两种情况 时间复杂度会是 2^n 次方 只能过两个测试点</p>
<p>所以不能暴力地去考虑状态 换个思路 我们只需要关注每件事情发生的贡献即可</p>
<p>以魏国获胜为例 即 X &gt; Y + Z 那么每次事件发生的贡献即为 <strong>ai - bi - ci</strong> 如果这个贡献大于 0 则是有利的 应该让它发生否则就不发生最好</p>
<p>对于每一个国家用 sum 来记录贡献和 如果 sum 还大于 0 则说明该国家此时还可以获胜</p>
<p>想要求得最多发生多少 可以算出三个国家分别获胜的最多事件 最后取一个 max 就行</p>
<h2 id="天梯赛选拔"><a href="#天梯赛选拔" class="headerlink" title="天梯赛选拔"></a>天梯赛选拔</h2><h3 id="比赛链接"><a href="#比赛链接" class="headerlink" title="比赛链接"></a>比赛链接</h3><p><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/105044">西南石油大学天梯赛选拔赛<em>ACM&#x2F;NOI&#x2F;CSP&#x2F;CCPC&#x2F;ICPC 算法编程高难度练习赛</em>牛客竞赛 OJ</a></p>
<h3 id="L1-A-进制"><a href="#L1-A-进制" class="headerlink" title="L1 - A 进制"></a>L1 - A 进制</h3><p>进制转化题 无限像豪豪历险记 想要任意转换只需要把大于 10 的部分用字母记录一下即可 用栈来储存余数</p>
<p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250316111455471.png" alt="image-20250316111455471"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define int long long</span><br><span class="line"></span><br><span class="line">signed main()</span><br><span class="line">&#123;</span><br><span class="line">    int x,k; cin &gt;&gt; x &gt;&gt; k;</span><br><span class="line">    char c[17] = &#123;&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;&#125;;</span><br><span class="line">    stack&lt;int&gt; m;</span><br><span class="line"></span><br><span class="line">    if(x == 0) &#123;</span><br><span class="line">        cout &lt;&lt; 0 &lt;&lt; endl;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while(x)</span><br><span class="line">    &#123;</span><br><span class="line">        m.push(x % k);</span><br><span class="line">        x /= k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while(!m.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        int n = m.top();</span><br><span class="line">        cout &lt;&lt; c[n];</span><br><span class="line">        m.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="L1-麻将"><a href="#L1-麻将" class="headerlink" title="L1-麻将"></a>L1-麻将</h3><p>除了能跟着题意写大模拟之外 现在应该更多地考虑优化简化代码 赛时写的代码太冗长了 容易出错 debug 还很麻烦</p>
<p>注意写的时候一定一定要冷静 然后就是每次都需要查找值 所以应该用数组记录 因为只需要找到胜者 所以直接用 max 记录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a[33];</span><br><span class="line">	for(int i = 1;i &lt;= 32;i ++) cin &gt;&gt; a[i];</span><br><span class="line">	int t = a[1];</span><br><span class="line">	for(int i = 1;i &lt;= 32;i += 4) sort(a + i,a + i + 4);</span><br><span class="line">	if(t == a[1] || a[2] == t) &#123;</span><br><span class="line">		cout &lt;&lt; 17 &lt;&lt; endl;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int b[9];</span><br><span class="line">	b[1] = max(a[4],a[7]);</span><br><span class="line">	b[2] = max(a[12],a[15]);</span><br><span class="line">	b[3] = max(a[20],a[23]);</span><br><span class="line">	b[4] = max(a[28],a[31]);</span><br><span class="line">	b[5] = max(a[8],a[3]);</span><br><span class="line">	b[6] = max(a[16],a[11]);</span><br><span class="line">	b[7] = max(a[24],a[19]);</span><br><span class="line">	b[8] = max(a[32],a[27]);</span><br><span class="line"></span><br><span class="line">	bool flag = false;</span><br><span class="line">	for(int i = 1;i &lt;= 8;i ++)&#123;</span><br><span class="line">		if(t == b[i]) &#123;</span><br><span class="line">			flag = true;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if(!flag) &#123;</span><br><span class="line">		cout &lt;&lt; 9 &lt;&lt; endl;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	flag = false;</span><br><span class="line"></span><br><span class="line">	int c[5];</span><br><span class="line">	c[1] = max(b[1],b[2]);</span><br><span class="line">	c[2] = max(b[3],b[4]);</span><br><span class="line">	c[3] = max(b[5],b[6]);</span><br><span class="line">	c[4] = max(b[7],b[8]);</span><br><span class="line"></span><br><span class="line">	for(int i = 1;i &lt;= 4;i ++)&#123;</span><br><span class="line">		if(t == c[i]) &#123;</span><br><span class="line">			flag = true;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if(!flag) &#123;</span><br><span class="line">		cout &lt;&lt; 5 &lt;&lt; endl;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int c1,c2;</span><br><span class="line">	c1 = max(c[1],c[2]); c2 = max(c[3],c[4]);</span><br><span class="line"></span><br><span class="line">	if(t != c1 &amp;&amp; t != c2) &#123;</span><br><span class="line">		cout &lt;&lt; 3 &lt;&lt; endl;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if(c1 &gt; c2) &#123;</span><br><span class="line">		if(t == c1) cout &lt;&lt; 1 &lt;&lt; endl;</span><br><span class="line">		else cout &lt;&lt; 2 &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	else if(c2 &gt; c1)&#123;</span><br><span class="line">		if(t == c2) cout &lt;&lt; 1 &lt;&lt; endl;</span><br><span class="line">		else cout &lt;&lt; 2 &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="L1-位运算"><a href="#L1-位运算" class="headerlink" title="L1-位运算"></a>L1-位运算</h3><p>关于位运算的题目 一个小要点是位运算没有进位 所以应该按位考虑 每一位的计算和贡献都是独立的</p>
<p>如果题目的数据范围是 2 的多少次方就应该考虑转换为 2 进制用位运算解决问题</p>
<p>位运算题目的重点是对题目给出式子的分析和推导</p>
<p>对于该题</p>
<p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250317111310192.png" alt="image-20250317111310192"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,k; cin &gt;&gt; n &gt;&gt; k; <span class="type">int</span> x = <span class="number">2</span>;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数字转化为2进制表示</span></span><br><span class="line">	<span class="keyword">while</span>(n)&#123;</span><br><span class="line">		s.<span class="built_in">push_back</span>(n &amp; <span class="number">1</span>);</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(s.<span class="built_in">size</span>() &lt; k)&#123;</span><br><span class="line">		s.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每一位的可能组合之间应该相乘</span></span><br><span class="line">	<span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; s.<span class="built_in">size</span>();i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(s[i] == <span class="number">0</span>) ans *= <span class="number">4</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="number">1</span>) ans *= <span class="number">12</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t --)&#123;</span><br><span class="line">		<span class="built_in">solve</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="L2-查无此号"><a href="#L2-查无此号" class="headerlink" title="L2-查无此号"></a>L2-查无此号</h3><p>一道字符串加数据结构大模拟 需要注意两个点</p>
<p><strong>1、耐心读题 把题读懂先</strong></p>
<p>邮箱地址由邮箱用户名和域名构成 只要邮箱用户名相同 就能登录相同的 dd 账号</p>
<p>所以 由邮箱用户名和账号名来确定一个账号</p>
<p>只需要判断这个账号的登录次数即可</p>
<p><strong>2.字符串函数和 stl 的使用</strong></p>
<p>由于就连昵称中都有可能出现空格 所以只能把邮箱 昵称 ip 地址整体<strong>getline</strong>进来</p>
<p>用 <strong>substr</strong> 来分割出我们所需要的部分</p>
<p>我们用 pair 来储存一个账号 用 map 来记录 ip 登录的种数</p>
<p>这里有一个之前没想到的问题是如果用 pair int 的 map 来记录的话 需要再给 ip 开一个 string bool 的 map 但是这样就没法把 ip 跟账号对应出来 会导致出错 所以我们应该开一个 pair set<string>的 map 来记录对应账号的 ip 情况 根据 set 的大小来判断登录次数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef pair&lt;string,string&gt; pp;</span><br><span class="line"></span><br><span class="line">map&lt;pp, set&lt;string&gt; &gt; cnt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(nullptr);</span><br><span class="line">    cout.tie(nullptr);</span><br><span class="line">    int n,k; cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    string ch; getline(cin,ch);</span><br><span class="line">    for(int i = 0;i &lt; n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        string s; getline(cin,s);</span><br><span class="line">        string mail = s.substr(0,s.find(&#x27;@&#x27;));</span><br><span class="line">        string ip = s.substr(s.size() - 15);</span><br><span class="line">        string name = s.substr(s.find(&quot;.com&quot;) + 5);</span><br><span class="line">        name = name.substr(0,name.size() - 15);</span><br><span class="line">        set&lt;string&gt; &amp;temp = cnt[&#123;mail, name&#125;];  // 注意这里应该直接取地址 这样的话 对temp的改变会直接改变map的键值 如果重新定义一个set的话每次清空再插入就会超时</span><br><span class="line">        int ts = temp.size();</span><br><span class="line">        if(temp.find(ip) == temp.end())&#123;</span><br><span class="line">            temp.insert(ip);</span><br><span class="line">            if(ts + 1 &lt; k) &#123;</span><br><span class="line">                cout &lt;&lt; &quot;zheng chang deng lu&quot; &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(ts + 1 == k) &#123;</span><br><span class="line">                cout &lt;&lt; &quot;zui hou yi ci la!!! xiao xin yi dian!!!&quot; &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(ts + 1 == k + 1) &#123;</span><br><span class="line">                cout &lt;&lt; &quot;hahaha bei feng hao le ba!!!&quot; &lt;&lt; endl;</span><br><span class="line">                temp.insert(&quot;123456&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else cout &lt;&lt; &quot;cha wu ci hao&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            if(ts &lt;= k) cout &lt;&lt; &quot;zheng chang deng lu&quot; &lt;&lt; endl;</span><br><span class="line">            else cout &lt;&lt; &quot;cha wu ci hao&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="天梯赛准备"><a href="#天梯赛准备" class="headerlink" title="天梯赛准备"></a>天梯赛准备</h2><h3 id="敲笨钟"><a href="#敲笨钟" class="headerlink" title="敲笨钟"></a>敲笨钟</h3><p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250317205457959.png" alt="image-20250317205457959"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n; cin &gt;&gt; n;</span><br><span class="line">    string ch; getline(cin,ch);  // 在用getline前 吸收掉cin产生的换行符</span><br><span class="line">    while(n --)&#123;</span><br><span class="line">        string s;  getline(cin,s);</span><br><span class="line">        string s2 = s.substr(s.find(&#x27;,&#x27;) + 1);</span><br><span class="line">        string s1 = s.substr(0,s.size() - s2.size() - 1);</span><br><span class="line">        string wei1 = (s1.size() &gt;= 3) ? s1.substr(s1.size() - 3, 3) : &quot;&quot;;</span><br><span class="line">        string wei2 = (s2.size() &gt;= 4) ? s2.substr(s2.size() - 4, 3) : &quot;&quot;;</span><br><span class="line">        //注意这里的判断条件 防止因为字符串长度不够造成越界访问 一开始就是这里没改导致了运行错误！！！</span><br><span class="line">        if(wei2 == &quot;ong&quot; &amp;&amp; wei1 == &quot;ong&quot;) &#123;</span><br><span class="line">            int cnt2 = 0;</span><br><span class="line">            int cnt0 = 0;</span><br><span class="line">            cout &lt;&lt; s1 &lt;&lt; &quot;,&quot;;</span><br><span class="line">            for(int i = s2.size() - 1;i &gt;= 0;i --)&#123;</span><br><span class="line">                cnt2 ++;</span><br><span class="line">                if(s2[i] == &#x27; &#x27;) cnt0 ++;</span><br><span class="line">                if(cnt0 == 3) break;</span><br><span class="line">            &#125;</span><br><span class="line">            //小知识点 当出现这种中间有空格的句子型的字符串的时候 可以用一个指针找空格出现的次数就可以达到分割单词的效果</span><br><span class="line">            s2.erase(s2.size() - cnt2);</span><br><span class="line">            cout &lt;&lt; s2 &lt;&lt; &quot; &quot; &lt;&lt; &quot;qiao ben zhong&quot; &lt;&lt; &quot;.&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        else cout &lt;&lt; &quot;Skipped&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里重温一下字符串中 substr 和 erase 和 find 函数的应用</p>
<p><strong>substr 函数 用于从原字符串中提取指定长度的子字符串</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string substr (size_t pos = 0, size_t len = npos) const;</span><br><span class="line">//应用时</span><br><span class="line">string s1;</span><br><span class="line">string s2 = s.substr(s.find(&#x27;,&#x27;) + 1);</span><br><span class="line">string s1 = s.substr(0,s.size() - s2.size() - 1);</span><br></pre></td></tr></table></figure>

<p>◦ pos：表示子字符串<strong>开始的位置</strong>，索引从 0 开始。<br>◦ len：表示子字符串的<strong>长度</strong>。若省略该参数，就会提取从 pos 开始直到字符串末尾的所有字符。</p>
<p><strong>erase 函数 用于在原字符串中删除指定长度的子字符串</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">erase(size_t pos = 0, size_t len = npos)</span><br><span class="line">// 应用时</span><br><span class="line">  s2.erase(s2.size() - cnt2);</span><br></pre></td></tr></table></figure>

<p>◦ pos：表示子字符串<strong>开始的位置</strong>，索引从 0 开始。<br>◦ len：表示子字符串的<strong>长度</strong>。若省略该参数，就会提取从 pos 开始删除直到字符串末尾的所有字符。</p>
<p><strong>find 函数 用于在原字符串中寻找某个字符或某个子串的位置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line">int pos1 = s.find(&#x27;,&#x27;);</span><br><span class="line">int pos2 = s.find(&quot;NJY&quot;);</span><br></pre></td></tr></table></figure>

<p>查找子字符串的时候 返回的位置是这个字符串的第一个字符出现的位置</p>
<p>如果没有找到 会返回 <strong>-1</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">NJY</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2025/04/15/%E7%AE%97%E6%B3%95/">http://example.com/2025/04/15/%E7%AE%97%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/ava.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/04/15/hello-world/" title="Hello World"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">Hello World</div></div><div class="info-2"><div class="info-item-1">Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot;  More info: Writing Run server1$ hexo server  More info: Server Generate static files1$ hexo generate  More info: Generating Deploy to remote sites1$ hexo deploy  More info: Deployment </div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/ava.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">NJY</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">第一章基础算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9"><span class="toc-number">1.2.1.</span> <span class="toc-text">快速排序与快速选择</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%A1%AE%E5%AE%9A%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E5%86%85%E7%9A%84%E5%80%BC%E7%94%A8%E6%9D%A5%E5%88%92%E5%88%86%E6%95%B0%E7%BB%84"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">1.确定一个数组内的值用来划分数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AF%B9%E4%BA%8E%E5%8E%9F%E6%95%B0%E7%BB%84%E8%BF%9B%E8%A1%8C%E5%88%92%E5%88%86%E3%80%82"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">2.对于原数组进行划分。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AF%B9%E5%88%86%E5%87%BA%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%8C%BA%E5%9F%9F%E8%BF%9B%E8%A1%8C%E9%80%92%E5%BD%92%E5%A4%84%E7%90%86"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">3.对分出的两个区域进行递归处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">4.快速选择</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">1. 基本步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E4%B8%AD%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2.归并排序中求逆序对</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86"><span class="toc-number">1.2.3.</span> <span class="toc-text">整数二分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">1.整数二分</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF-1"><span class="toc-number">1.2.3.1.1.</span> <span class="toc-text">模板 1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF-2"><span class="toc-number">1.2.3.1.2.</span> <span class="toc-text">模板 2</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B5%AE%E7%82%B9%E4%BA%8C%E5%88%86%EF%BC%9A"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">2.浮点二分：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">3.二分答案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6"><span class="toc-number">1.2.4.</span> <span class="toc-text">高精度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">1.高精度加法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">2.高精度减法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">3.高精度乘法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%A7%E6%95%B0-%C3%97-%E5%A4%A7%E6%95%B0%E7%9A%84%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95"><span class="toc-number">1.2.4.3.1.</span> <span class="toc-text">大数 × 大数的高精度乘法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%99%A4%E6%B3%95"><span class="toc-number">1.2.4.4.</span> <span class="toc-text">4.高精度除法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-number">1.2.5.</span> <span class="toc-text">前缀和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%80%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">1.一维前缀和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">2.二维前缀和</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%AE%E5%88%86"><span class="toc-number">1.2.6.</span> <span class="toc-text">差分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%80%E7%BB%B4%E5%B7%AE%E5%88%86"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">1.一维差分</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%AE%E5%88%86%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.2.6.1.1.</span> <span class="toc-text">差分的应用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">1.2.6.1.2.</span> <span class="toc-text">差分数组的构造</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">2.二维差分</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">1.2.6.2.1.</span> <span class="toc-text">应用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0"><span class="toc-number">1.2.6.2.2.</span> <span class="toc-text">构造</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A6%BB%E6%95%A3%E5%8C%96"><span class="toc-number">1.2.7.</span> <span class="toc-text">离散化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E5%92%8C"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">区间和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6"><span class="toc-number">1.2.7.2.</span> <span class="toc-text">区间合并</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text">第二章数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">1.4.</span> <span class="toc-text">栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%88"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%98%9F%E5%88%97"><span class="toc-number">1.4.2.</span> <span class="toc-text">2.队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E7%9A%84%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.3.</span> <span class="toc-text">3.使用场景的总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97"><span class="toc-number">1.4.4.</span> <span class="toc-text">4.单调栈和单调队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8D%95%E8%B0%83%E6%A0%88"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">1.单调栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">2.单调队列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Trie-%E6%A0%91"><span class="toc-number">1.5.</span> <span class="toc-text">Trie 树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">1.5.1.</span> <span class="toc-text">并查集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%8D%E7%B1%BB%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">1.5.2.</span> <span class="toc-text">种类并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E5%AF%B9%E5%85%B3%E7%B3%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">注意对关系之间的处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E6%9D%83%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">1.5.3.</span> <span class="toc-text">带权并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Q1-%E5%AE%9A%E4%B9%89"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">Q1 定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q3-%E6%9D%83%E5%80%BC%E5%88%B0%E5%BA%95%E4%BB%A3%E8%A1%A8%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">Q3 权值到底代表了什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q2-%E6%9D%83%E5%80%BC%E7%9A%84%E8%BD%AC%E7%A7%BB"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">Q2 权值的转移</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E8%A7%81%E6%B4%9B%E8%B0%B7-P2024-%E9%A3%9F%E7%89%A9%E9%93%BE"><span class="toc-number">1.5.3.4.</span> <span class="toc-text">详见洛谷 P2024 食物链</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">1.6.</span> <span class="toc-text">堆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A0%86%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.6.1.</span> <span class="toc-text">1.堆的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A0%B9%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">1.6.2.</span> <span class="toc-text">2.根的存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A0%86%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.6.3.</span> <span class="toc-text">3.堆的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A0%86%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%85%83%E7%B4%A0%E5%A4%84%E7%90%86"><span class="toc-number">1.6.4.</span> <span class="toc-text">4.堆中的一些元素处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E9%A1%B6%E5%A0%86"><span class="toc-number">1.6.5.</span> <span class="toc-text">对顶堆</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">1.7.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8"><span class="toc-number">1.7.1.</span> <span class="toc-text">链表的主要作用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8D%95%E9%93%BE%E8%A1%A8-%E9%82%BB%E6%8E%A5%E8%A1%A8-%E7%94%A8%E6%9D%A5%E5%82%A8%E5%AD%98%E6%A0%91%E5%92%8C%E5%9B%BE"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">1.单链表-&gt;邻接表-&gt;用来储存树和图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8F%8C%E9%93%BE%E8%A1%A8-%E7%94%A8%E6%9D%A5%E4%BC%98%E5%8C%96%E6%9F%90%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">2.双链表-&gt;用来优化某些问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="toc-number">1.7.2.</span> <span class="toc-text">用指针实现的链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">一，单向链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">1.初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.7.2.3.</span> <span class="toc-text">2.单向链表的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5"><span class="toc-number">1.7.2.4.</span> <span class="toc-text">3.单向链表的插入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">1.7.2.5.</span> <span class="toc-text">4.单链表的删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9E%84%E5%BB%BA"><span class="toc-number">1.7.2.6.</span> <span class="toc-text">5.链表的构建</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8C%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">1.7.3.</span> <span class="toc-text">二，双向链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9D%E5%A7%8B%E5%8C%96-1"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">1.初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%9C%A8-p-%E8%8A%82%E7%82%B9%E5%90%8E%E6%8F%92%E5%85%A5-now-%E8%8A%82%E7%82%B9"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">2.在 p 节点后插入 now 节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA-now-%E8%8A%82%E7%82%B9"><span class="toc-number">1.7.3.3.</span> <span class="toc-text">3.删除一个 now 节点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%EF%BC%8C%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">1.7.4.</span> <span class="toc-text">三，循环链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="toc-number">1.7.5.</span> <span class="toc-text">用数组模拟实现的链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8-1"><span class="toc-number">1.7.5.1.</span> <span class="toc-text">一，单向链表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%A8%A1%E6%8B%9F%E6%96%B9%E5%BC%8F"><span class="toc-number">1.7.5.1.1.</span> <span class="toc-text">1.模拟方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.7.5.1.2.</span> <span class="toc-text">2.初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">1.7.5.1.3.</span> <span class="toc-text">3.插入操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">1.7.5.1.4.</span> <span class="toc-text">4.删除操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8C%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8-1"><span class="toc-number">1.7.5.2.</span> <span class="toc-text">二，双向链表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%A8%A1%E6%8B%9F%E6%96%B9%E5%BC%8F-1"><span class="toc-number">1.7.5.2.1.</span> <span class="toc-text">1.模拟方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%88%9D%E5%A7%8B%E5%8C%96-1"><span class="toc-number">1.7.5.2.2.</span> <span class="toc-text">2.初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C-1"><span class="toc-number">1.7.5.2.3.</span> <span class="toc-text">3.插入操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C-1"><span class="toc-number">1.7.5.2.4.</span> <span class="toc-text">4.删除操作</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C"><span class="toc-number">1.8.</span> <span class="toc-text">哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.8.1.</span> <span class="toc-text">1.简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%80%BC%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">1.8.2.</span> <span class="toc-text">2.值冲突解决方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Plan-A-%E8%B7%B3%E8%BF%87%E6%B3%95"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">Plan A 跳过法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Plan-B-%E5%AE%B9%E5%99%A8%E6%B3%95"><span class="toc-number">1.8.2.2.</span> <span class="toc-text">Plan B 容器法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.8.3.</span> <span class="toc-text">3.哈希函数的设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C"><span class="toc-number">1.8.4.</span> <span class="toc-text">4.字符串哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%94%A8%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B0%E5%AD%97"><span class="toc-number">1.8.4.1.</span> <span class="toc-text">1.用哈希函数将字符串转化为数字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%87%BD%E6%95%B0%E7%9A%84%E8%A7%A3%E9%87%8A"><span class="toc-number">1.8.4.2.</span> <span class="toc-text">2.函数的解释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%B1%82%E4%BB%BB%E6%84%8F%E7%89%87%E6%AE%B5%E5%AD%90%E4%B8%B2%E7%9A%84%E5%93%88%E5%B8%8C%E5%80%BC"><span class="toc-number">1.8.4.3.</span> <span class="toc-text">3.求任意片段子串的哈希值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-stl-%E5%BA%93%E4%B8%AD%E7%9A%84-hash"><span class="toc-number">1.8.5.</span> <span class="toc-text">5.stl 库中的 hash</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stl-%E5%BA%93%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.9.</span> <span class="toc-text">stl 库中的数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA"><span class="toc-number">1.10.</span> <span class="toc-text">第三章搜索与图论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E5%92%8C%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%EF%BC%88%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%89"><span class="toc-number">1.11.</span> <span class="toc-text">树和图的存储（邻接表）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-DFS"><span class="toc-number">1.12.</span> <span class="toc-text">1.DFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-BFS"><span class="toc-number">1.13.</span> <span class="toc-text">2.BFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">1.14.</span> <span class="toc-text">3.拓扑排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="toc-number">1.15.</span> <span class="toc-text">最短路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%88%9A4-Dijkstra"><span class="toc-number">1.15.1.</span> <span class="toc-text">√4.Dijkstra</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%88%9A5-bellman-ford"><span class="toc-number">1.15.2.</span> <span class="toc-text">√5.bellman-ford</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-spfa"><span class="toc-number">1.15.3.</span> <span class="toc-text">6.spfa</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="toc-number">1.15.3.1.</span> <span class="toc-text">判断最短路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#spfa-%E5%88%A4%E6%96%AD%E8%B4%9F%E7%8E%AF"><span class="toc-number">1.15.3.2.</span> <span class="toc-text">spfa 判断负环</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%88%9A7-Floyd"><span class="toc-number">1.15.4.</span> <span class="toc-text">√7.Floyd</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">1.16.</span> <span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-Prim"><span class="toc-number">1.16.1.</span> <span class="toc-text">8.Prim</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%88%9A9-Kruskal"><span class="toc-number">1.16.2.</span> <span class="toc-text">√9.Kruskal</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="toc-number">1.17.</span> <span class="toc-text">二分图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E6%9F%93%E8%89%B2%E6%B3%95%E5%88%A4%E5%AE%9A%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="toc-number">1.17.1.</span> <span class="toc-text">10.染色法判定二分图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95"><span class="toc-number">1.17.2.</span> <span class="toc-text">11.匈牙利算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86"><span class="toc-number">1.18.</span> <span class="toc-text">第四章数学知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%B4%A8%E6%95%B0"><span class="toc-number">1.19.</span> <span class="toc-text">1.质数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0-%E8%AF%95%E9%99%A4%E6%B3%95%E5%88%A4%E6%96%AD%E8%B4%A8%E6%95%B0"><span class="toc-number">1.19.1.</span> <span class="toc-text">① 试除法判断质数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1-%E8%AF%95%E9%99%A4%E6%B3%95%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0"><span class="toc-number">1.19.2.</span> <span class="toc-text">② 试除法分解质因数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2-%E7%AD%9B%E8%B4%A8%E6%95%B0"><span class="toc-number">1.19.3.</span> <span class="toc-text">③ 筛质数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BA%A6%E6%95%B0"><span class="toc-number">1.20.</span> <span class="toc-text">2.约数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0-%E8%AF%95%E9%99%A4%E6%B3%95%E6%B1%82%E7%BA%A6%E6%95%B0"><span class="toc-number">1.20.1.</span> <span class="toc-text">① 试除法求约数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1-%E6%B1%82%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0"><span class="toc-number">1.20.2.</span> <span class="toc-text">② 求约数个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2-%E6%B1%82%E7%BA%A6%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">1.20.3.</span> <span class="toc-text">③ 求约数之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0"><span class="toc-number">1.20.4.</span> <span class="toc-text">③ 最大公约数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3-%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95"><span class="toc-number">1.20.5.</span> <span class="toc-text">④ 扩展欧几里得算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0"><span class="toc-number">1.21.</span> <span class="toc-text">3.欧拉函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.21.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E6%B3%95"><span class="toc-number">1.21.2.</span> <span class="toc-text">求法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%85%AC%E5%BC%8F%E6%B1%82%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0"><span class="toc-number">1.21.2.1.</span> <span class="toc-text">1、公式求欧拉函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E7%AD%9B%E6%B3%95%E6%B1%82%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0"><span class="toc-number">1.21.2.2.</span> <span class="toc-text">2、筛法求欧拉函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="toc-number">1.22.</span> <span class="toc-text">4.快速幂</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82%E6%B1%82%E9%80%86%E5%85%83"><span class="toc-number">1.22.1.</span> <span class="toc-text">快速幂求逆元</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E6%B1%82%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84"><span class="toc-number">1.23.</span> <span class="toc-text">5.高斯消元求线性方程组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">1.24.</span> <span class="toc-text">第五章动态规划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%88%9A-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.25.</span> <span class="toc-text">√ 背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-01-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.25.1.</span> <span class="toc-text">1.01 背包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.25.2.</span> <span class="toc-text">2.完全背包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%88%E6%95%B0%E6%8D%AE%E5%B0%8F%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%89"><span class="toc-number">1.25.3.</span> <span class="toc-text">3.多重背包问题（数据小的时候）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%88%E6%95%B0%E6%8D%AE%E5%A4%A7%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%89"><span class="toc-number">1.25.4.</span> <span class="toc-text">4.多重背包问题（数据大的时候）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.25.5.</span> <span class="toc-text">5.分组背包问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7-DP"><span class="toc-number">1.26.</span> <span class="toc-text">线性 DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%88%9A6-%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="toc-number">1.26.1.</span> <span class="toc-text">√6.数字三角形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%88%9A7-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88%E6%95%B0%E6%8D%AE%E5%B0%8F%E6%97%B6%EF%BC%89"><span class="toc-number">1.26.2.</span> <span class="toc-text">√7.最长上升子序列（数据小时）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%88%9A8-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88%E6%95%B0%E6%8D%AE%E5%A4%A7%E6%97%B6%EF%BC%89"><span class="toc-number">1.26.3.</span> <span class="toc-text">√8.最长上升子序列（数据大时）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">1.26.4.</span> <span class="toc-text">9.最长公共子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="toc-number">1.26.5.</span> <span class="toc-text">10.最短编辑距离</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4-DP"><span class="toc-number">1.27.</span> <span class="toc-text">区间 DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6"><span class="toc-number">1.27.1.</span> <span class="toc-text">11.石子合并</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E7%B1%BB-DP"><span class="toc-number">1.28.</span> <span class="toc-text">计数类 DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86"><span class="toc-number">1.28.1.</span> <span class="toc-text">12.整数划分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E4%BD%8D%E7%BB%9F%E8%AE%A1-DP"><span class="toc-number">1.29.</span> <span class="toc-text">数位统计 DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98"><span class="toc-number">1.29.1.</span> <span class="toc-text">13.计数问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9-DP"><span class="toc-number">1.30.</span> <span class="toc-text">状态压缩 DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E8%92%99%E5%BE%B7%E9%87%8C%E5%AE%89%E7%9A%84%E6%A2%A6%E6%83%B3"><span class="toc-number">1.30.1.</span> <span class="toc-text">14.蒙德里安的梦想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E6%9C%80%E7%9F%AD-Hamilton-%E8%B7%AF%E5%BE%84"><span class="toc-number">1.30.2.</span> <span class="toc-text">15.最短 Hamilton 路径</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E5%BD%A2-DP"><span class="toc-number">1.31.</span> <span class="toc-text">树形 DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E6%B2%A1%E6%9C%89%E4%B8%8A%E5%8F%B8%E7%9A%84%E8%88%9E%E4%BC%9A"><span class="toc-number">1.31.1.</span> <span class="toc-text">16.没有上司的舞会</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2"><span class="toc-number">1.32.</span> <span class="toc-text">记忆化搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E6%BB%91%E9%9B%AA"><span class="toc-number">1.32.1.</span> <span class="toc-text">17.滑雪</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%B4%AA%E5%BF%83"><span class="toc-number">2.</span> <span class="toc-text">第六章贪心</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.</span> <span class="toc-text">区间问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8C%BA%E9%97%B4%E9%80%89%E7%82%B9"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.区间选点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8C%BA%E9%97%B4%E5%88%86%E7%BB%84"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.区间分组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8C%BA%E9%97%B4%E8%A6%86%E7%9B%96"><span class="toc-number">2.1.3.</span> <span class="toc-text">3.区间覆盖</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Huffman-%E6%A0%91"><span class="toc-number">2.2.</span> <span class="toc-text">Huffman 树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%90%88%E5%B9%B6%E6%9E%9C%E5%AD%90"><span class="toc-number">2.2.1.</span> <span class="toc-text">4.合并果子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E4%B8%8D%E7%AD%89%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">排序不等式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%89%93%E6%B0%B4%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.1.</span> <span class="toc-text">5.打水问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%9D%E5%AF%B9%E5%80%BC%E4%B8%8D%E7%AD%89%E5%BC%8F"><span class="toc-number">2.4.</span> <span class="toc-text">绝对值不等式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%B4%A7%E4%BB%93%E9%80%89%E5%9D%80"><span class="toc-number">2.4.1.</span> <span class="toc-text">6.货仓选址</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A8%E5%85%AC%E5%BC%8F"><span class="toc-number">2.5.</span> <span class="toc-text">推公式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%80%8D%E6%9D%82%E6%8A%80%E7%9A%84%E7%89%9B"><span class="toc-number">2.5.1.</span> <span class="toc-text">7.耍杂技的牛</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93"><span class="toc-number">2.6.</span> <span class="toc-text">刷题总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93"><span class="toc-number">2.7.</span> <span class="toc-text">方法技巧总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%8F%A5%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%AF%B9%E5%8D%95%E8%AF%8D%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">2.7.1.</span> <span class="toc-text">在句子字符串中对单词的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%85%A5%E9%97%AE%E9%A2%98"><span class="toc-number">2.7.1.1.</span> <span class="toc-text">读入问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%90%E4%B8%AA%E5%88%86%E6%9E%90%E5%8D%95%E8%AF%8D"><span class="toc-number">2.7.1.2.</span> <span class="toc-text">逐个分析单词</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string-%E4%B8%AD-find-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.7.2.</span> <span class="toc-text">string 中 find 函数的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A0%BC%E5%9B%BE%E5%B0%8F%E6%8A%80%E5%B7%A7"><span class="toc-number">2.7.3.</span> <span class="toc-text">方格图小技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%86%E6%9E%90%E4%B8%8A%E4%B8%8B%E5%B7%A6%E5%8F%B3"><span class="toc-number">2.7.3.1.</span> <span class="toc-text">1.分析上下左右</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AF%B9%E8%A7%92%E7%BA%BF%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">2.7.3.2.</span> <span class="toc-text">2.对角线的表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%96%B9%E6%A0%BC%E5%9B%BE%E4%B8%AD%E4%BF%A1%E6%81%AF%E5%8F%98%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.7.3.3.</span> <span class="toc-text">3.方格图中信息变字符串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%A7%E4%BB%93%E9%80%89%E5%9D%80%E5%B0%8F%E7%BB%93%E8%AE%BA"><span class="toc-number">2.7.4.</span> <span class="toc-text">货仓选址小结论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8-DFS"><span class="toc-number">2.7.5.</span> <span class="toc-text">什么时候用 DFS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0"><span class="toc-number">2.7.6.</span> <span class="toc-text">统计出现次数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%80%8D%E6%95%B0%E9%97%AE%E9%A2%98%E7%9A%84%E5%B0%8F%E7%BB%93%E8%AE%BA"><span class="toc-number">2.7.7.</span> <span class="toc-text">关于倍数问题的小结论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DFS-%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%BA%94%E7%94%A8"><span class="toc-number">2.7.8.</span> <span class="toc-text">DFS 的两种应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DFS-%E6%B1%82%E8%BF%9E%E9%80%9A%E5%9D%97"><span class="toc-number">2.7.8.1.</span> <span class="toc-text">DFS 求连通块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DFS-%E6%B1%82%E6%89%80%E6%9C%89%E6%8E%92%E5%88%97"><span class="toc-number">2.7.8.2.</span> <span class="toc-text">DFS 求所有排列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E5%9B%9E%E6%BA%AF"><span class="toc-number">2.7.8.3.</span> <span class="toc-text">是否需要回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BD%95%E6%97%B6%E9%9C%80%E8%A6%81%E6%98%BE%E5%BC%8F%E7%BB%93%E6%9D%9F%E6%9D%A1%E4%BB%B6%EF%BC%9F"><span class="toc-number">2.7.8.3.1.</span> <span class="toc-text">1. 何时需要显式结束条件？</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98"><span class="toc-number">2.7.8.3.1.1.</span> <span class="toc-text">示例：全排列问题</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BD%95%E6%97%B6%E4%B8%8D%E9%9C%80%E8%A6%81%E6%98%BE%E5%BC%8F%E7%BB%93%E6%9D%9F%E6%9D%A1%E4%BB%B6%EF%BC%9F"><span class="toc-number">2.7.8.3.2.</span> <span class="toc-text">2. 何时不需要显式结束条件？</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E9%97%AE%E9%A2%98"><span class="toc-number">2.7.8.3.2.1.</span> <span class="toc-text">示例：字符串拼接问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%85%B3%E9%94%AE%E5%8C%BA%E5%88%86%E5%8E%9F%E5%88%99"><span class="toc-number">2.7.8.4.</span> <span class="toc-text">3. 关键区分原则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BFS"><span class="toc-number">2.7.9.</span> <span class="toc-text">BFS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%95%B0%E9%97%AE%E9%A2%98"><span class="toc-number">2.7.10.</span> <span class="toc-text">选数问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%98%E5%B0%8F%E8%AE%B0"><span class="toc-number">2.8.</span> <span class="toc-text">洛谷刷题小记</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#P1083-%E5%80%9F%E6%95%99%E5%AE%A4"><span class="toc-number">2.8.1.</span> <span class="toc-text">P1083 借教室</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P1030-%E6%B1%82%E5%85%88%E5%BA%8F%E6%8E%92%E5%88%97"><span class="toc-number">2.8.2.</span> <span class="toc-text">P1030 求先序排列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88Pre-order-Traversal%EF%BC%89"><span class="toc-number">2.8.2.1.</span> <span class="toc-text">1. 先序遍历（Pre-order Traversal）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88In-order-Traversal%EF%BC%89"><span class="toc-number">2.8.2.2.</span> <span class="toc-text">2. 中序遍历（In-order Traversal）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88Post-order-Traversal%EF%BC%89"><span class="toc-number">2.8.2.3.</span> <span class="toc-text">3. 后序遍历（Post-order Traversal）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.8.2.4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E5%9B%BE%E8%A7%A3"><span class="toc-number">2.8.2.5.</span> <span class="toc-text">示例图解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P10905-%E8%93%9D%E6%A1%A5%E6%9D%AF-2024-%E7%9C%81-C-%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.8.3.</span> <span class="toc-text">P10905 [蓝桥杯 2024 省 C] 回文字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P1044-%E6%A0%88"><span class="toc-number">2.8.4.</span> <span class="toc-text">P1044 栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P1359-%E7%A7%9F%E7%94%A8%E6%B8%B8%E8%89%87"><span class="toc-number">2.8.5.</span> <span class="toc-text">P1359 租用游艇</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P3131%EF%BC%88%E5%AF%B9%E4%BA%8E%E5%80%8D%E6%95%B0%E9%97%AE%E9%A2%98%E7%9A%84%E4%BC%98%E5%8C%96%EF%BC%89"><span class="toc-number">2.8.6.</span> <span class="toc-text">P3131（对于倍数问题的优化）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P2036"><span class="toc-number">2.8.7.</span> <span class="toc-text">P2036</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P2196-%E6%8C%96%E5%9C%B0%E9%9B%B7%EF%BC%88%E5%9B%BE%E4%B8%8A-DFS%EF%BC%89"><span class="toc-number">2.8.8.</span> <span class="toc-text">P2196 挖地雷（图上 DFS）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#acm-%E6%96%B0%E7%94%9F%E8%B5%9B"><span class="toc-number">2.9.</span> <span class="toc-text">acm 新生赛</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-%E5%B0%8F%E5%88%98%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="toc-number">2.9.1.</span> <span class="toc-text">A 小刘的最短路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E5%BB%BA%E9%80%A0%E6%96%B0%E5%AE%B6"><span class="toc-number">2.9.2.</span> <span class="toc-text">B 建造新家</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E5%90%88%E6%88%90%E5%A4%A7%E9%9B%AA%E7%90%83"><span class="toc-number">2.9.3.</span> <span class="toc-text">C 合成大雪球</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#D-%E7%BE%BD%E6%AF%9B%E7%90%83%E6%AF%94%E8%B5%9B"><span class="toc-number">2.9.4.</span> <span class="toc-text">D 羽毛球比赛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#E-%E5%B0%8F%E9%9D%92%E6%89%BE%E5%AE%9D%E8%97%8F"><span class="toc-number">2.9.5.</span> <span class="toc-text">E 小青找宝藏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#F-%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF"><span class="toc-number">2.9.6.</span> <span class="toc-text">F 矩形面积</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#K-%E8%B5%9A%E5%B7%AE%E4%BB%B7"><span class="toc-number">2.9.7.</span> <span class="toc-text">K 赚差价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#L-%E7%BC%96%E8%BE%91%E5%99%A8"><span class="toc-number">2.9.8.</span> <span class="toc-text">L 编辑器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%9B%E5%AE%A2%E5%88%B7%E9%A2%98%E5%B0%8F%E8%AE%B0"><span class="toc-number">2.10.</span> <span class="toc-text">牛客刷题小记</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%A1%E5%A4%96%E7%9A%84%E6%A0%91"><span class="toc-number">2.10.1.</span> <span class="toc-text">校外的树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%EF%BC%88%E8%BF%99%E4%B8%AA%E9%A2%98%E8%B7%9F%E4%BA%8C%E5%88%86%E6%97%A0%E5%85%B3%EF%BC%89"><span class="toc-number">2.10.2.</span> <span class="toc-text">二分（这个题跟二分无关）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98%E5%B0%8F%E8%AE%B0"><span class="toc-number">2.11.</span> <span class="toc-text">寒假刷题小记</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-number">2.11.1.</span> <span class="toc-text">1.全排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-N-%E7%9A%87%E5%90%8E"><span class="toc-number">2.11.2.</span> <span class="toc-text">2.N 皇后</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%A9%AC%E8%B5%B0%E6%97%A5"><span class="toc-number">2.11.3.</span> <span class="toc-text">3.马走日</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%95%B0%E7%8B%AC"><span class="toc-number">2.11.4.</span> <span class="toc-text">4. 数独</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dfs-%E5%B0%8F%E7%BB%93"><span class="toc-number">2.11.5.</span> <span class="toc-text">dfs 小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%BF%99%E9%87%8C%E6%9C%89%E5%9B%9B%E9%81%93%E9%A2%98-%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B"><span class="toc-number">2.11.6.</span> <span class="toc-text">5.(这里有四道题)牛客周赛</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#q1"><span class="toc-number">2.11.6.1.</span> <span class="toc-text">q1 :</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#q2-%EF%BC%9A"><span class="toc-number">2.11.6.2.</span> <span class="toc-text">q2 ：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#q3"><span class="toc-number">2.11.6.3.</span> <span class="toc-text">q3 :</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#q4"><span class="toc-number">2.11.6.4.</span> <span class="toc-text">q4 :</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%8F%8C%E4%BA%BA%E8%BF%B7%E5%AE%AB%E7%9B%B8%E9%81%87%E9%97%AE%E9%A2%98"><span class="toc-number">2.11.7.</span> <span class="toc-text">6.双人迷宫相遇问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%9C%B0%E9%9B%B7%E9%80%92%E6%8E%A8"><span class="toc-number">2.11.8.</span> <span class="toc-text">7.地雷递推</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E8%B4%AA%E5%BF%83%E6%8B%BC%E6%95%B0"><span class="toc-number">2.11.9.</span> <span class="toc-text">8.贪心拼数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E8%B4%AA%E5%BF%83%E6%8E%92%E5%BA%A7%E6%A4%85"><span class="toc-number">2.11.10.</span> <span class="toc-text">9.贪心排座椅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E8%B4%AA%E5%BF%83%E5%9B%BD%E7%8E%8B%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.11.11.</span> <span class="toc-text">10.贪心国王的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E5%B0%8F%E7%BB%93"><span class="toc-number">2.11.12.</span> <span class="toc-text">贪心小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%85%88%E5%BA%8F%E6%8E%92%E5%88%97"><span class="toc-number">2.11.13.</span> <span class="toc-text">11.先序排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E4%BA%8C%E5%88%86%E6%99%BE%E8%A1%A3%E6%9C%8D"><span class="toc-number">2.11.14.</span> <span class="toc-text">12.二分晾衣服</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-number">2.11.15.</span> <span class="toc-text">13.表达式求值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">2.11.16.</span> <span class="toc-text">14.并查集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-a-b%EF%BC%882%EF%BC%89"><span class="toc-number">2.11.17.</span> <span class="toc-text">15.牛客周赛 a+b（2）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-cfdiv2%EF%BC%882%EF%BC%89"><span class="toc-number">2.11.18.</span> <span class="toc-text">16.cfdiv2（2）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E8%AE%AD%E7%BB%83%E8%90%A5-1"><span class="toc-number">2.11.19.</span> <span class="toc-text">17.牛客寒假训练营 1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E8%A8%80-1"><span class="toc-number">2.11.19.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#a"><span class="toc-number">2.11.19.2.</span> <span class="toc-text">a.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b"><span class="toc-number">2.11.19.3.</span> <span class="toc-text">b.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d"><span class="toc-number">2.11.19.4.</span> <span class="toc-text">d.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#e"><span class="toc-number">2.11.19.5.</span> <span class="toc-text">e.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#g"><span class="toc-number">2.11.19.6.</span> <span class="toc-text">g.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#h"><span class="toc-number">2.11.19.7.</span> <span class="toc-text">h.</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E8%AE%AD%E7%BB%83%E8%90%A5-2"><span class="toc-number">2.11.20.</span> <span class="toc-text">18.牛客寒假训练营 2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E8%A8%80-2"><span class="toc-number">2.11.20.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#a-1"><span class="toc-number">2.11.20.2.</span> <span class="toc-text">a.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-1"><span class="toc-number">2.11.20.3.</span> <span class="toc-text">b.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c"><span class="toc-number">2.11.20.4.</span> <span class="toc-text">c.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d-1"><span class="toc-number">2.11.20.5.</span> <span class="toc-text">d.</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98%E8%A1%A5%E9%A2%98"><span class="toc-number">2.12.</span> <span class="toc-text">蓝桥杯真题补题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF-cb-%E7%9C%81%E8%B5%9B"><span class="toc-number">2.12.1.</span> <span class="toc-text">十四届蓝桥杯 cb 省赛</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E6%97%A5%E6%9C%9F%E7%BB%9F%E8%AE%A1"><span class="toc-number">2.12.1.1.</span> <span class="toc-text">a 日期统计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b01-%E4%B8%B2%E7%9A%84%E7%86%B5"><span class="toc-number">2.12.1.2.</span> <span class="toc-text">b01 串的熵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-%E5%86%B6%E7%82%BC%E9%87%91%E5%B1%9E"><span class="toc-number">2.12.1.3.</span> <span class="toc-text">c 冶炼金属</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d-%E9%A3%9E%E6%9C%BA%E9%99%8D%E8%90%BD"><span class="toc-number">2.12.1.4.</span> <span class="toc-text">d 飞机降落</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#e-%E6%8E%A5%E9%BE%99%E6%95%B0%E5%88%97"><span class="toc-number">2.12.1.5.</span> <span class="toc-text">e 接龙数列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#f-%E5%B2%9B%E5%B1%BF%E4%B8%AA%E6%95%B0"><span class="toc-number">2.12.1.6.</span> <span class="toc-text">f 岛屿个数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#g-%E5%AD%90%E4%B8%B2%E7%AE%80%E5%86%99"><span class="toc-number">2.12.1.7.</span> <span class="toc-text">g 子串简写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#h-%E6%95%B4%E6%95%B0%E5%88%A0%E9%99%A4"><span class="toc-number">2.12.1.8.</span> <span class="toc-text">h 整数删除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A9%E6%A2%AF%E8%B5%9B%E9%80%89%E6%8B%94%E6%A8%A1%E6%8B%9F"><span class="toc-number">2.13.</span> <span class="toc-text">天梯赛选拔模拟</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E9%9D%99%E7%9A%84%E6%8E%A8%E8%8D%90"><span class="toc-number">2.13.1.</span> <span class="toc-text">静静的推荐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%97%85%E6%AF%92%E6%BA%AF%E6%BA%90"><span class="toc-number">2.13.2.</span> <span class="toc-text">病毒溯源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%85%E7%82%B9%E4%BB%A3%E7%A0%81"><span class="toc-number">2.13.3.</span> <span class="toc-text">清点代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%B2%E5%93%B2%E6%89%93%E6%B8%B8%E6%88%8F"><span class="toc-number">2.13.4.</span> <span class="toc-text">哲哲打游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">2.13.5.</span> <span class="toc-text">完全二叉树的层序遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%82%E9%A2%98%EF%BC%88%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81%E9%83%BD%E5%9C%A8%E6%9D%82%E9%A2%98%E6%96%87%E4%BB%B6%E5%A4%B9%E9%87%8C%EF%BC%89"><span class="toc-number">2.14.</span> <span class="toc-text">杂题（具体代码都在杂题文件夹里）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#k-%E5%80%8D%E5%8C%BA%E9%97%B4"><span class="toc-number">2.14.1.</span> <span class="toc-text">k 倍区间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B7%A7%E5%85%8B%E5%8A%9B"><span class="toc-number">2.14.2.</span> <span class="toc-text">分巧克力</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%A9%E4%B8%89%E5%9B%BD%E6%9D%80"><span class="toc-number">2.14.3.</span> <span class="toc-text">玩三国杀</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A9%E6%A2%AF%E8%B5%9B%E9%80%89%E6%8B%94"><span class="toc-number">2.15.</span> <span class="toc-text">天梯赛选拔</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%B5%9B%E9%93%BE%E6%8E%A5"><span class="toc-number">2.15.1.</span> <span class="toc-text">比赛链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#L1-A-%E8%BF%9B%E5%88%B6"><span class="toc-number">2.15.2.</span> <span class="toc-text">L1 - A 进制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#L1-%E9%BA%BB%E5%B0%86"><span class="toc-number">2.15.3.</span> <span class="toc-text">L1-麻将</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#L1-%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">2.15.4.</span> <span class="toc-text">L1-位运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#L2-%E6%9F%A5%E6%97%A0%E6%AD%A4%E5%8F%B7"><span class="toc-number">2.15.5.</span> <span class="toc-text">L2-查无此号</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A9%E6%A2%AF%E8%B5%9B%E5%87%86%E5%A4%87"><span class="toc-number">2.16.</span> <span class="toc-text">天梯赛准备</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B2%E7%AC%A8%E9%92%9F"><span class="toc-number">2.16.1.</span> <span class="toc-text">敲笨钟</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/15/hello-world/" title="Hello World">Hello World</a><time datetime="2025-04-15T03:21:12.959Z" title="Created 2025-04-15 03:21:12">2025-04-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/15/%E7%AE%97%E6%B3%95/" title="算法">算法</a><time datetime="2025-04-15T03:21:12.959Z" title="Created 2025-04-15 03:21:12">2025-04-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By NJY</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="N,LOVE,T" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>