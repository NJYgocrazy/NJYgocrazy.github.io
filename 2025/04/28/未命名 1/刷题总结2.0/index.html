<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>刷题小记--从下笔到遗忘 | NJYgocrazy</title><meta name="author" content="NJY"><meta name="copyright" content="NJY"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="刷题总结前言这里记录了一些补题和总结。从头看到尾，算是一条学习算法的时间线。 方法技巧总结在句子字符串中对单词的处理（句子字符串代指所有其中含有空格或换行符的字符串） 读入问题 对 char a[N]类型的字符数组的读入 12fgets(a,sizeof a,stdin);&#x2F;&#x2F;stdin表示从键盘中读入  在 c++中对 string a 的读入 1getline(cin,a);  在已知单词数目">
<meta property="og:type" content="article">
<meta property="og:title" content="刷题小记--从下笔到遗忘">
<meta property="og:url" content="http://example.com/2025/04/28/%E6%9C%AA%E5%91%BD%E5%90%8D%201/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0/index.html">
<meta property="og:site_name" content="NJYgocrazy">
<meta property="og:description" content="刷题总结前言这里记录了一些补题和总结。从头看到尾，算是一条学习算法的时间线。 方法技巧总结在句子字符串中对单词的处理（句子字符串代指所有其中含有空格或换行符的字符串） 读入问题 对 char a[N]类型的字符数组的读入 12fgets(a,sizeof a,stdin);&#x2F;&#x2F;stdin表示从键盘中读入  在 c++中对 string a 的读入 1getline(cin,a);  在已知单词数目">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s21.ax1x.com/2025/04/28/pE7libq.jpg">
<meta property="article:published_time" content="2025-04-28T14:00:14.820Z">
<meta property="article:modified_time" content="2025-04-28T14:00:14.821Z">
<meta property="article:author" content="NJY">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="cpp">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s21.ax1x.com/2025/04/28/pE7libq.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "刷题小记--从下笔到遗忘",
  "url": "http://example.com/2025/04/28/%E6%9C%AA%E5%91%BD%E5%90%8D%201/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0/",
  "image": "https://s21.ax1x.com/2025/04/28/pE7libq.jpg",
  "datePublished": "2025-04-28T14:00:14.820Z",
  "dateModified": "2025-04-28T14:00:14.821Z",
  "author": [
    {
      "@type": "Person",
      "name": "NJY",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/04/28/%E6%9C%AA%E5%91%BD%E5%90%8D%201/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '刷题小记--从下笔到遗忘',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/top.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/ava.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://s21.ax1x.com/2025/04/28/pE7libq.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">NJYgocrazy</span></a><a class="nav-page-title" href="/"><span class="site-name">刷题小记--从下笔到遗忘</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">刷题小记--从下笔到遗忘</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-28T14:00:14.820Z" title="发表于 2025-04-28 14:00:14">2025-04-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-28T14:00:14.821Z" title="更新于 2025-04-28 14:00:14">2025-04-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="刷题总结"><a href="#刷题总结" class="headerlink" title="刷题总结"></a>刷题总结</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这里记录了一些补题和总结。<br>从头看到尾，算是一条学习算法的时间线。</p>
<h2 id="方法技巧总结"><a href="#方法技巧总结" class="headerlink" title="方法技巧总结"></a>方法技巧总结</h2><h3 id="在句子字符串中对单词的处理"><a href="#在句子字符串中对单词的处理" class="headerlink" title="在句子字符串中对单词的处理"></a>在句子字符串中对单词的处理</h3><p>（句子字符串代指所有其中含有空格或换行符的字符串）</p>
<h4 id="读入问题"><a href="#读入问题" class="headerlink" title="读入问题"></a>读入问题</h4><ol>
<li><p>对 char a[N]类型的字符数组的读入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fgets(a,sizeof a,stdin);</span><br><span class="line">//stdin表示从键盘中读入</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 c++中对 string a 的读入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getline(cin,a);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在已知单词数目的情况下直接逐个读入单词</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">	string a;</span><br><span class="line">	cin &gt;&gt; a;</span><br><span class="line">&#125;</span><br><span class="line">//n是字符串中单词的数目，每次读入的a就是其中的单个的单词</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="逐个分析单词"><a href="#逐个分析单词" class="headerlink" title="逐个分析单词"></a>逐个分析单词</h4><p>使用字符串流来分割句子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sstream&gt;</span><br><span class="line">istringstream iss(a);</span><br><span class="line">string word;</span><br><span class="line">while(iss &gt;&gt; word)</span><br><span class="line">&#123;</span><br><span class="line">	//在这个循环中可以对每一个单词进行处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方法三读入可以直接在循环中逐个分析单词</p>
<h3 id="string-中-find-函数的使用"><a href="#string-中-find-函数的使用" class="headerlink" title="string 中 find 函数的使用"></a>string 中 find 函数的使用</h3><p>find 的原型如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size_t find(const string&amp; str, size_t pos = 0) const noexcept;</span><br></pre></td></tr></table></figure>

<p>其中 str 是要查找的子字符串，pos 是开始查找的位置，默认为 0(pos 在 find 函数中可以省略)</p>
<p>返回值：如果找到子字符串，返回子字符串的第一个字符在原字符串中的位置；如果没有找到，返回 npos（一个常数）</p>
<p>一般的用法如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//比如我们要查找的子字符串是lec</span><br><span class="line">string sentence;</span><br><span class="line">string temp = &quot;lec&quot;;</span><br><span class="line">auto weizhi = sentence.find(temp,0);</span><br></pre></td></tr></table></figure>

<h3 id="方格图小技巧"><a href="#方格图小技巧" class="headerlink" title="方格图小技巧"></a>方格图小技巧</h3><h4 id="1-分析上下左右"><a href="#1-分析上下左右" class="headerlink" title="1.分析上下左右"></a>1.分析上下左右</h4><p>在分析一个点上下左右的坐标时，我们可以先写出上下左右的四个向量，在需要分析时直接循环加上即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int D[4][2] = &#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;.&#123;0,1&#125;&#125;;</span><br><span class="line">int x,y;//假设x，y即为现在节点的横纵坐标</span><br><span class="line"></span><br><span class="line">for(int i = 0;i &lt; 4;i ++)</span><br><span class="line">&#123;</span><br><span class="line">	int xx = x + D[i][0]; int yy = y + D[i][1];</span><br><span class="line">	//后续直接对点（xx，yy）进行分析即可</span><br><span class="line">	//这样就可以在一个循环中处理上下左右四个点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-对角线的表示"><a href="#2-对角线的表示" class="headerlink" title="2.对角线的表示"></a>2.对角线的表示</h4><p>对于一个 n*n 的矩形方格图，我们用每条对角线的纵截距 b 来作为它的编号，则</p>
<p>对于点（u，i），它所在的对角线分别是 d[u+i]和 d[i-u+n]</p>
<p>这里加上 n 是给它一个偏移量让数组的下标始终是大于 0 的</p>
<h4 id="3-方格图中信息变字符串"><a href="#3-方格图中信息变字符串" class="headerlink" title="3.方格图中信息变字符串"></a>3.方格图中信息变字符串</h4><p>把一个 n*m 的矩形方格图中的量按顺序写进字符串中，那么方格图中的某个元素（x，y）和其在字符串中的位置 k 存在这样的关系</p>
<p>$ x &#x3D; \left\lfloor \frac{k}{n} \right\rfloor $ &#x2F;&#x2F;代表向下取整</p>
<p>$ y &#x3D; k % n $</p>
<p>注意这里的矩形必须是从行到列遍历的</p>
<h3 id="货仓选址小结论"><a href="#货仓选址小结论" class="headerlink" title="货仓选址小结论"></a>货仓选址小结论</h3><p>在一条数轴上有 n 个商店坐标分别为 a[0]~a[n-1]，当且仅当货仓建在这个数组的中位数的位置上时，货仓到每家店的距离之和最小。</p>
<h3 id="什么时候用-DFS"><a href="#什么时候用-DFS" class="headerlink" title="什么时候用 DFS"></a>什么时候用 DFS</h3><p>那什么时候可以用到 DFS 呢？总结来说，当问题需要枚举所有可能的解，并且问题的结构适合逐步构建解的时候，可以考虑 DFS。例如排列问题、组合问题、路径问题等。在这种情况下，DFS 通过递归或者栈的方式，尝试每一种可能的选择，并回溯到上一步尝试其他选择，直到找到解或者遍历完所有可能性。</p>
<p>即如果我们想要枚举一下答案的某一种情况然后对于每一种情况判断其合法性的话我们就可以用 dfs</p>
<p>虽然是一种暴力搜索 但是面对数据量较小的时候还是能很好地解决问题</p>
<p>当我们有想法想要把所有的方案都枚举出来找合法解的时候 就可以想想能不能 dfs</p>
<h3 id="统计出现次数"><a href="#统计出现次数" class="headerlink" title="统计出现次数"></a>统计出现次数</h3><p>当需要统计某些元素的出现次数时，可以用以下几种数据结构</p>
<p><strong>map set 哈希</strong></p>
<p>map 可以通过键对关系储存每一种元素的出现次数 可以避免重复的情况 好处是可以直接通过键对值得到元素的出现次数</p>
<p>set 可以直接把元素塞进去 不用考虑是否重复 因为最后只会留下不同的元素 好处是插入后的元素是默认从小到大排序的</p>
<p>但坏处是如果要记录次数的话 还需要另外开一个 map 来记载一下出现次数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set&lt;int&gt; a;</span><br><span class="line">a.insert(); a.size(); a.empty(); a.clear(); a.find(); //find函数跟其他地方一样 如果没有找到还是返回end()迭代器</span><br><span class="line">//可以用for循环遍历set</span><br><span class="line">for(int num : a)</span><br></pre></td></tr></table></figure>

<p>哈希我不太常用 先略去</p>
<h3 id="关于倍数问题的小结论"><a href="#关于倍数问题的小结论" class="headerlink" title="关于倍数问题的小结论"></a>关于倍数问题的小结论</h3><p><strong>两个数 a,b，如果(a - b) % c &#x3D;&#x3D; 0 那么一定有 a % c &#x3D;&#x3D; b % c</strong></p>
<p>依靠这个结论 可以避免全部枚举 只需要记录余数相同的位置即可 具体可以看下面的题 （P3131）</p>
<h3 id="DFS-的两种应用"><a href="#DFS-的两种应用" class="headerlink" title="DFS 的两种应用"></a>DFS 的两种应用</h3><h4 id="DFS-求连通块"><a href="#DFS-求连通块" class="headerlink" title="DFS 求连通块"></a>DFS 求连通块</h4><p>可以理解为 洪水从外到内渗透 统计渗透不到的点 可以用染色法解决 即我们把所有可以搜索到的点都进行染色 最后没有被染色的点就是需要求的点 下面是两道例题</p>
<p><img src="/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0.assets/image-20250408110315030.png" alt="image-20250408110315030"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> a[<span class="number">510</span>][<span class="number">510</span>];</span><br><span class="line"><span class="type">int</span> m,n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    a[x][y] = <span class="number">1</span>; <span class="comment">// 能被搜索到的地方进行染色</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i ++)&#123; <span class="comment">//向四周蔓延</span></span><br><span class="line">        <span class="type">int</span> x0 = x + dx[i]; <span class="type">int</span> y0 = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span>(x0 &gt;= <span class="number">0</span> &amp;&amp; x0 &lt; n &amp;&amp; y0 &gt;= <span class="number">0</span> &amp;&amp; y0 &lt; m &amp;&amp; a[x0][y0] == <span class="number">0</span> ) <span class="built_in">dfs</span>(x0,y0); <span class="comment">// 起点变为下一个可以搜到的地方</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;j ++) &#123;</span><br><span class="line">            <span class="type">char</span> c; cin &gt;&gt; c;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;*&#x27;</span>) a[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;0&#x27;</span>) a[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意一定是从边界往里搜的  所以只需要搜索第一列 最后一列 第一排 最后一排</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>][i] == <span class="number">0</span>) <span class="built_in">dfs</span>(<span class="number">0</span>,i);</span><br><span class="line">        <span class="keyword">if</span>(a[n - <span class="number">1</span>][i] == <span class="number">0</span>) <span class="built_in">dfs</span>(n - <span class="number">1</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i][<span class="number">0</span>] == <span class="number">0</span>) <span class="built_in">dfs</span>(i,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(a[i][m - <span class="number">1</span>] == <span class="number">0</span>) <span class="built_in">dfs</span>(i,m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j] == <span class="number">0</span>) cnt ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0.assets/image-20250408110917640.png" alt="image-20250408110917640"></p>
<p>这道题不一样的地方在于 搜索过的染色应该用其他数字标记 才能在最后复原矩阵 （当然开两个数组也可以 但是有点麻烦）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int dx[] = &#123;1,0,-1,0&#125;;</span><br><span class="line">int dy[] = &#123;0,1,0,-1&#125;;</span><br><span class="line">int n,a[35][35];</span><br><span class="line"></span><br><span class="line">void dfs(int x,int y) &#123;</span><br><span class="line">    a[x][y] = 3;</span><br><span class="line">    for(int i = 0;i &lt; 4;i ++) &#123;</span><br><span class="line">        int x0 = x + dx[i];</span><br><span class="line">        int y0 = y + dy[i];</span><br><span class="line">        if(x0 &gt;= 0 &amp;&amp; x0 &lt; n &amp;&amp; y0 &gt;=0 &amp;&amp; y0 &lt; n &amp;&amp; a[x0][y0] == 0) dfs(x0,y0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for(int i = 0;i &lt; n;i ++) &#123;</span><br><span class="line">        for(int j = 0;j &lt; n;j ++) cin &gt;&gt; a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i = 0;i &lt; n;i ++) &#123;</span><br><span class="line">        if(a[0][i] == 0) dfs(0,i);</span><br><span class="line">        if(a[n - 1][i] == 0) dfs(n - 1,i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i = 0;i &lt; n;i ++) &#123;</span><br><span class="line">        if(a[i][0] == 0) dfs(i,0);</span><br><span class="line">        if(a[i][n - 1] == 0) dfs(i,n - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int cnt = 0;</span><br><span class="line">    for(int i = 0;i &lt; n;i ++) &#123;</span><br><span class="line">        for(int j = 0;j &lt; n;j ++) &#123;</span><br><span class="line">            if(a[i][j] == 0) a[i][j] = 2;</span><br><span class="line">            if(a[i][j] == 3) a[i][j] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i = 0;i &lt; n;i ++) &#123;</span><br><span class="line">        for(int j = 0;j &lt; n;j ++) cout &lt;&lt; a[i][j] &lt;&lt; &quot; &quot;;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DFS-求所有排列"><a href="#DFS-求所有排列" class="headerlink" title="DFS 求所有排列"></a>DFS 求所有排列</h4><p>即爆搜出所有的可能排列 然后判断是否存在满足条件的排列或者从中选出最优解 一般的 会在搜索过程中进行剪枝 可以看 <strong>飞机降落</strong></p>
<p>和 <strong>接龙数列</strong> 这两道题</p>
<h4 id="是否需要回溯"><a href="#是否需要回溯" class="headerlink" title="是否需要回溯"></a>是否需要回溯</h4><p>考虑是否回溯其实就是考虑 dfs 会不会对后续的搜索造成影响 如果会造成影响的话 就应该在搜索后回溯 否则的话就不用回溯</p>
<p>比如在求所有的排列时 某个数是否应用是在搜索过程中改变了的 所以需要在搜索后进行回溯</p>
<p>但在染色法求连通块 或者遍历树这些不改变元素性质 不会重复访问的问题里 就不需要回溯 比如说<strong>P2036</strong></p>
<p>在 DFS 中，是否需要显式地在函数开头添加<strong>结束条件判断</strong>（如<code>if (搜索完) return;</code>），取决于<strong>问题的性质</strong>和<strong>解的生成方式</strong>。以下是关键区分点：</p>
<hr>
<h5 id="1-何时需要显式结束条件？"><a href="#1-何时需要显式结束条件？" class="headerlink" title="1. 何时需要显式结束条件？"></a><strong>1. 何时需要显式结束条件？</strong></h5><p>当 <strong>“解的完整性”</strong> 必须在递归的某一层被明确判断时，需要在 DFS 开头检查结束条件。常见场景包括：</p>
<ul>
<li><strong>组合&#x2F;排列问题</strong>：只有选满特定数量的元素才算有效解（如全排列、组合数问题）。</li>
<li><strong>路径终点问题</strong>：必须到达某个特定节点才算解（如迷宫出口、二叉树叶子节点）。</li>
<li><strong>约束满足问题</strong>：必须满足所有约束条件才能形成有效解（如数独填满且合法）。</li>
</ul>
<h6 id="示例：全排列问题"><a href="#示例：全排列问题" class="headerlink" title="示例：全排列问题"></a><strong>示例：全排列问题</strong></h6><p>cpp</p>
<p>复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void dfs(vector&lt;int&gt;&amp; path) &#123;</span><br><span class="line">    if (path.size() == n) &#123; // 显式判断是否完成排列</span><br><span class="line">        print(path);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        if (!used[i]) &#123;</span><br><span class="line">            used[i] = true;</span><br><span class="line">            path.push_back(i);</span><br><span class="line">            dfs(path);</span><br><span class="line">            path.pop_back();</span><br><span class="line">            used[i] = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：必须显式判断<code>path.size() == n</code>，因为只有选满 n 个数才是一个有效排列。</p>
<hr>
<h5 id="2-何时不需要显式结束条件？"><a href="#2-何时不需要显式结束条件？" class="headerlink" title="2. 何时不需要显式结束条件？"></a><strong>2. 何时不需要显式结束条件？</strong></h5><p>当 <strong>“解的局部状态”</strong> 可以随时更新答案，且递归的终止由无法继续搜索隐式触发时，无需显式结束判断。常见场景包括：</p>
<ul>
<li><strong>最长&#x2F;最短路径问题</strong>：每一步都可能更新当前最优解（如字符串拼接最长长度）。</li>
<li><strong>连通性&#x2F;遍历问题</strong>：递归自然终止于无法继续扩展的节点（如岛屿数量、图的遍历）。</li>
</ul>
<h6 id="示例：字符串拼接问题"><a href="#示例：字符串拼接问题" class="headerlink" title="示例：字符串拼接问题"></a><strong>示例：字符串拼接问题</strong></h6><p>cpp</p>
<p>复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void dfs(string current) &#123;</span><br><span class="line">    ans = max(ans, current.length()); // 随时更新答案</span><br><span class="line">    for (auto&amp; s : candidates) &#123;</span><br><span class="line">        if (can_append(current, s)) &#123;</span><br><span class="line">            dfs(append(current, s)); // 隐式终止于无法拼接</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：每次递归都尝试延长当前字符串，并更新最大长度。当无法继续拼接时，循环自然结束，无需显式判断终止。</p>
<hr>
<h4 id="3-关键区分原则"><a href="#3-关键区分原则" class="headerlink" title="3. 关键区分原则"></a><strong>3. 关键区分原则</strong></h4><table>
<thead>
<tr>
<th align="left"><strong>特征</strong></th>
<th align="left">需要显式结束条件</th>
<th align="left">不需要显式结束条件</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>解的形式</strong></td>
<td align="left">必须完整（如全排列）</td>
<td align="left">局部状态即可更新（如最长路径）</td>
</tr>
<tr>
<td align="left"><strong>递归终止触发方式</strong></td>
<td align="left">显式判断完整性后返回</td>
<td align="left">无法继续搜索时自然返回</td>
</tr>
<tr>
<td align="left"><strong>答案更新时机</strong></td>
<td align="left">仅在完整解时更新</td>
<td align="left">每一步都可能更新</td>
</tr>
</tbody></table>
<h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>BFS 具有最短路性质 即它是贪心的 每一步都选择了最优解 因为每次搜索都选择的是距离最近的点（队列实现）</p>
<p>模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;类型&gt;Q;</span><br><span class="line">Q.<span class="built_in">push</span>(最初状态);</span><br><span class="line"><span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">	类型 u=Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>(); <span class="comment">//每次处理的下一步就是这里的u</span></span><br><span class="line">	<span class="keyword">for</span>(枚举所有可扩展到的状态)&#123;</span><br><span class="line">		<span class="keyword">if</span>(满足入队条件)&#123;</span><br><span class="line">			Q.<span class="built_in">push</span>(状态); <span class="comment">//维护某些必要信息</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例题</p>
<p><img src="/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0.assets/image-20250408163244410.png" alt="image-20250408163244410"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pp;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1005</span>;</span><br><span class="line"><span class="type">int</span> vi[N],k[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,a,b; cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) cin &gt;&gt; k[i];</span><br><span class="line">    <span class="keyword">if</span>(a == b) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;pp&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,a&#125;); <span class="comment">//初始状态 pair里fi代表现在按了几次键 se代表现在的楼层（id）</span></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        pp u = q.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">if</span>(u.se == b) &#123;</span><br><span class="line">            cout &lt;&lt; u.fi &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(u.se + k[u.se] &lt;= n &amp;&amp; vi[u.se + k[u.se]] == <span class="number">0</span>) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;u.fi + <span class="number">1</span>,u.se + k[u.se]&#125;);</span><br><span class="line">            vi[u.se + k[u.se]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u.se - k[u.se] &gt;= <span class="number">1</span> &amp;&amp; vi[u.se - k[u.se]] == <span class="number">0</span>) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;u.fi + <span class="number">1</span>,u.se - k[u.se]&#125;);</span><br><span class="line">            vi[u.se - k[u.se]] = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="comment">//注意这里不要用else if 因为这两种情况是有可能同时成立的 所以要直接用两个if</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="选数问题"><a href="#选数问题" class="headerlink" title="选数问题"></a>选数问题</h3><p>从 n 个数中选择 k 个数 要想没有遗漏地枚举出所有的选择情况 就必须遵循 <strong>不降原则</strong></p>
<p>即每次选择的时候不选择比上次选择的数小的数字</p>
<p>比如说要从 n 个数中选择 3 个数 那么最暴力的枚举就应该是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++) &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>;j &lt; n;j ++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k = j + <span class="number">1</span>;k &lt; n;k ++) &#123;</span><br><span class="line">			<span class="comment">//选出的三个数即为i j k</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一道例题</p>
<p><img src="/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0.assets/image-20250408193853045.png" alt="image-20250408193853045"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">22</span>;</span><br><span class="line"><span class="type">int</span> n,k,cnt;</span><br><span class="line"><span class="type">int</span> x[N],vi[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= u / i;i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(u % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> sum,<span class="type">int</span> now)</span> </span>&#123; <span class="comment">// 用now来记录上次选择的数的下一个 从而遵循不降原则</span></span><br><span class="line">    <span class="keyword">if</span>(u == k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(sum)) cnt ++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过不降原则实现dfs</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = now;i &lt; n;i ++) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(u + <span class="number">1</span>,sum + x[i],i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++) cin &gt;&gt; x[i];</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="洛谷刷题小记"><a href="#洛谷刷题小记" class="headerlink" title="洛谷刷题小记"></a>洛谷刷题小记</h2><h3 id="P1083-借教室"><a href="#P1083-借教室" class="headerlink" title="P1083 借教室"></a>P1083 借教室</h3><p>像题目中这样，有一天不满足其后的每一天都不满足的情况就完全满足二分答案的单调性特征。</p>
<p>当题目中的数据范围能恰好达到 1e9 时，不妨在作运算的量上开 longlong 防止加和后超过 2e9 爆 int</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代码见https://www.luogu.com.cn/problem/P1083#submit</span><br></pre></td></tr></table></figure>

<h3 id="P1030-求先序排列"><a href="#P1030-求先序排列" class="headerlink" title="P1030 求先序排列"></a>P1030 求先序排列</h3><h4 id="1-先序遍历（Pre-order-Traversal）"><a href="#1-先序遍历（Pre-order-Traversal）" class="headerlink" title="1. 先序遍历（Pre-order Traversal）"></a>1. 先序遍历（Pre-order Traversal）</h4><p><strong>定义</strong>：先序遍历按照以下顺序访问二叉树的节点：</p>
<ul>
<li>访问根节点。</li>
<li>先序遍历左子树。</li>
<li>先序遍历右子树。</li>
</ul>
<p><strong>特点</strong>：先访问根节点，然后依次访问左右子树。对于每个子树，也遵循同样的规则。</p>
<p><strong>应用</strong>：常用于创建树的复制或输出树的结构信息，因为它首先处理根节点。</p>
<p><strong>示例</strong>： 假设有一棵如下所示的二叉树：</p>
<p>深色版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    A</span><br><span class="line">   / \</span><br><span class="line">  B   C</span><br><span class="line"> / \   \</span><br><span class="line">D   E   F</span><br></pre></td></tr></table></figure>

<p>先序遍历的顺序为：<code>A -&gt; B -&gt; D -&gt; E -&gt; C -&gt; F</code></p>
<h4 id="2-中序遍历（In-order-Traversal）"><a href="#2-中序遍历（In-order-Traversal）" class="headerlink" title="2. 中序遍历（In-order Traversal）"></a>2. 中序遍历（In-order Traversal）</h4><p><strong>定义</strong>：中序遍历按照以下顺序访问二叉树的节点：</p>
<ul>
<li>中序遍历左子树。</li>
<li>访问根节点。</li>
<li>中序遍历右子树。</li>
</ul>
<p><strong>特点</strong>：先访问左子树，再访问根节点，最后访问右子树。对于每个子树，也遵循同样的规则。</p>
<p><strong>应用</strong>：广泛应用于二叉搜索树（BST），因为中序遍历会以升序访问节点值，适用于排序和查找操作。</p>
<p><strong>示例</strong>： 对于上述相同的二叉树，中序遍历的顺序为：<code>D -&gt; B -&gt; E -&gt; A -&gt; C -&gt; F</code></p>
<p><strong>注意这里是递归的先访问子树再访问这个子树的根，不断向上寻找</strong></p>
<h4 id="3-后序遍历（Post-order-Traversal）"><a href="#3-后序遍历（Post-order-Traversal）" class="headerlink" title="3. 后序遍历（Post-order Traversal）"></a>3. 后序遍历（Post-order Traversal）</h4><p><strong>定义</strong>：后序遍历按照以下顺序访问二叉树的节点：</p>
<ul>
<li>后序遍历左子树。</li>
<li>后序遍历右子树。</li>
<li>访问根节点。</li>
</ul>
<p><strong>特点</strong>：先访问左右子树，最后访问根节点。对于每个子树，也遵循同样的规则。</p>
<p><strong>应用</strong>：常用于释放树占用的内存或计算表达式的值，因为在删除或计算时通常需要先处理子节点再处理父节点。</p>
<p><strong>示例</strong>： 对于上述相同的二叉树，后序遍历的顺序为：<code>D -&gt; E -&gt; B -&gt; F -&gt; C -&gt; A</code></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><strong>先序遍历</strong>：根 -&gt; 左 -&gt; 右</li>
<li><strong>中序遍历</strong>：左 -&gt; 根 -&gt; 右</li>
<li><strong>后序遍历</strong>：左 -&gt; 右 -&gt; 根</li>
</ul>
<h4 id="示例图解"><a href="#示例图解" class="headerlink" title="示例图解"></a>示例图解</h4><p>为了更直观地理解，我们可以通过一个简单的二叉树来展示这三种遍历的结果：</p>
<p>深色版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>先序遍历</strong>：<code>1 -&gt; 2 -&gt; 4 -&gt; 5 -&gt; 3</code></li>
<li><strong>中序遍历</strong>：<code>4 -&gt; 2 -&gt; 5 -&gt; 1 -&gt; 3</code></li>
<li><strong>后序遍历</strong>：<code>4 -&gt; 5 -&gt; 2 -&gt; 3 -&gt; 1</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">如果当前子树范围无效（即 ml &gt; mr 或 al &gt; ar），直接返回。</span><br><span class="line">输出后序遍历中的最后一个元素 aft[ar]，这是当前子树的根节点。</span><br><span class="line">查找这个根节点在中序遍历中的位置 k。</span><br><span class="line"></span><br><span class="line">根据找到的位置 k，递归处理左子树和右子树：</span><br><span class="line"></span><br><span class="line">左子树：中序遍历 [ml, k-1] 和后序遍历 [al, al+k-ml-1]。</span><br><span class="line">已知后序遍历序列的起始位置是 al，由于后序遍历的顺序是先左子树，再右子树，最后根节点，所以左子树在后序遍历中的结束位置可以通过以下方式计算：</span><br><span class="line">假设 n 是当前子树的节点数量，对于左子树，其节点数量为 k - ml。</span><br><span class="line">我们从后序遍历序列的起始位置 al 开始，由于左子树有 k - ml 个节点，所以左子树在后序遍历中的结束位置是 al + (k - ml) - 1，也就是 al + k - ml - 1。</span><br><span class="line"></span><br><span class="line">右子树：中序遍历 [k+1, mr] 和后序遍历 [al+k-ml, ar-1]。</span><br><span class="line">我们知道左子树的节点数量是 k - ml，所以右子树在后序遍历中的起始位置是 al + (k - ml)，即 al + k - ml。因为左子树在后序遍历中占据了 k - ml 个位置，所以右子树的起始位置是从左子树结束的下一个位置开始。</span><br><span class="line">ar 是整个子树后序遍历的结束位置，由于根节点是最后一个元素，右子树的结束位置是根节点的前一个位置，所以是 ar - 1。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这样每次输出子树的根节点最后就能得出先序排列的结果</span><br><span class="line">代码见https://www.luogu.com.cn/problem/P1030#submit</span><br></pre></td></tr></table></figure>

<h3 id="P10905-蓝桥杯-2024-省-C-回文字符串"><a href="#P10905-蓝桥杯-2024-省-C-回文字符串" class="headerlink" title="P10905 [蓝桥杯 2024 省 C] 回文字符串"></a>P10905 [蓝桥杯 2024 省 C] 回文字符串</h3><p>一开始的想法是直接把字符串右端由 lqb 这三个字符组成的字符串给去掉 如果剩下的字符串回文那么久可以使它变得回文</p>
<p>但是这样做只能过百分之五十，因为没有考虑像 <strong>qwq</strong>这样的情况</p>
<h3 id="P1044-栈"><a href="#P1044-栈" class="headerlink" title="P1044 栈"></a>P1044 栈</h3><p><img src="/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0.assets/image-20250328084606790.png" alt="image-20250328084606790"></p>
<p>可以用一个 dp 来做</p>
<p>1.考虑状态 我们设置这样一个函数<strong>C(i,j)</strong> 其中 i 表示输入序列中待处理的数字 j 表示目前栈中的数字个数</p>
<p>所以我们要求的就是<strong>C(n,0)</strong> 这个状态</p>
<p>2.状态转移</p>
<p>对于每一次操作显然有两种操作 一是把输入序列中的数压入栈中 c(i - 1,j + 1) 二是把栈中的数压出到输出序列中去</p>
<p>c(i,j - 1)</p>
<p>所以状态转移方程为</p>
<p>$$f_{x,y}&#x3D;f_{x-1,y+1}+f_{x,y-1}$$</p>
<p>3.边界条件特判</p>
<p>当 i &#x3D;&#x3D; 0 的时候说明输入序列已经全部输出完 已成序列 说明只有一种走法</p>
<p>当 j &#x3D;&#x3D; 0 的时候说明栈内还没有数字 只能执行 push 压入操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n; cin &gt;&gt; n;</span><br><span class="line">	int f[22][22];</span><br><span class="line">	for(int i = 0;i &lt;= n;i ++) &#123;</span><br><span class="line">		for(int j = 0;j &lt;= n;j ++) &#123;</span><br><span class="line">			if(i == 0) f[i][j] = 1;</span><br><span class="line">			else if(j == 0) f[i][j] = f[i - 1][j + 1];</span><br><span class="line">			else f[i][j] = f[i - 1][j + 1] + f[i][j - 1];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; f[n][0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="P1359-租用游艇"><a href="#P1359-租用游艇" class="headerlink" title="P1359 租用游艇"></a>P1359 租用游艇</h3><p><img src="/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0.assets/image-20250328085847167.png" alt="image-20250328085847167"></p>
<p><img src="/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0.assets/image-20250328085829365.png" alt="image-20250328085829365"></p>
<p>1.状态表示 : 用 dp[i]来记录从 i 到 n 站之间的最小花费</p>
<p>2.状态转移：假设有三个点 顺序分别为 i j n 那么从 i 到 n 有两种走法 一是从 i - &gt; j ,j - &gt; n 此时花费为 a[i] [j] + dp[j]</p>
<p>二是直接从 i - &gt; n 此时花费为 dp[i] 要最少花费只需要对它们取一个 min 即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用dp[i]来表示从i到n的最小花费</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">210</span>][<span class="number">210</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">210</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; n;i ++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>;j &lt;= n;j ++) &#123;</span><br><span class="line">			cin &gt;&gt; a[i][j];</span><br><span class="line">			dp[i] = <span class="number">0x3f3f3f3f</span>; <span class="comment">//注意这里需要初始化为正无穷</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>;i &gt;= <span class="number">1</span>;i --) &#123; <span class="comment">//所以从后往前遍历</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>;j &lt;= n;j ++) &#123; <span class="comment">//i为上流 j为i相对的下流</span></span><br><span class="line">			dp[i] = <span class="built_in">min</span>(dp[i],a[i][j] + dp[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; dp[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="P3131（对于倍数问题的优化）"><a href="#P3131（对于倍数问题的优化）" class="headerlink" title="P3131（对于倍数问题的优化）"></a>P3131（对于倍数问题的优化）</h3><p><img src="/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0.assets/image-20250407201655470.png" alt="image-20250407201655470"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对7取模的结果只会是 0 ~ 6</span></span><br><span class="line"><span class="type">int</span> last[<span class="number">7</span>],first[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n; cin &gt;&gt; n; <span class="type">int</span> a[n + <span class="number">1</span>],sum[n + <span class="number">1</span>];</span><br><span class="line">    sum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        sum[i] = (sum[i - <span class="number">1</span>] + a[i] ) % <span class="number">7</span>; <span class="comment">// 直接记录前缀和对7取模的余数 (a - b) % c == (a % c) - (b % c)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//滚动数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n;i &gt;= <span class="number">1</span>;i --) first[sum[i]] = i; <span class="comment">//更新该余数第一次出现的位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) last[sum[i]] = i; <span class="comment">//更新该余数最后一次出现的位置</span></span><br><span class="line"></span><br><span class="line">    first[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//注意 当一个奶牛都不取的时候  ID为0 余数也为0 没有这个赋值会错</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//枚举余数 从而判断最大长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">6</span>;i ++) ans = <span class="built_in">max</span>(ans,last[i] - first[i] );</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="P2036"><a href="#P2036" class="headerlink" title="P2036"></a>P2036</h3><p><img src="/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0.assets/image-20250408171247020.png" alt="image-20250408171247020"></p>
<h3 id="P2196-挖地雷（图上-DFS）"><a href="#P2196-挖地雷（图上-DFS）" class="headerlink" title="P2196 挖地雷（图上 DFS）"></a>P2196 挖地雷（图上 DFS）</h3><p><img src="/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0.assets/image-20250409233215501.png" alt="image-20250409233215501"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">22</span>;</span><br><span class="line"><span class="type">int</span> a[N][N],n,ans; <span class="comment">// 数据比较小 用邻接矩阵来存图</span></span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> cnt1,cnt2; <span class="comment">//cnt1为op的路径长度 cnt2为p的路径长度</span></span><br><span class="line"><span class="type">int</span> op[N]; <span class="type">int</span> p[N]; <span class="comment">//用op来记录每次的路径 用p来记录最优路径</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> sum)</span></span>&#123;  <span class="comment">//x为起始节点 sum为挖到的地雷数目</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = x + <span class="number">1</span>;i &lt;= n;i ++) &#123; <span class="comment">//从上往下挖 所以从x + 1开始</span></span><br><span class="line">		<span class="keyword">if</span>(a[x][i]) &#123;  <span class="comment">//如果连通 则可以继续往下面挖</span></span><br><span class="line">			op[++cnt1] = i;</span><br><span class="line">			<span class="built_in">dfs</span>(i,sum + f[i]);</span><br><span class="line">			cnt1 --; <span class="comment">//回溯</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(sum &gt; ans) &#123;</span><br><span class="line">		ans = sum;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= cnt1;i ++) p[i] = op[i];</span><br><span class="line">		cnt2 = cnt1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) cin &gt;&gt; f[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>;j &lt;= n;j ++) &#123;</span><br><span class="line">			cin &gt;&gt; a[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) &#123; <span class="comment">// 枚举每一个节点作为起点</span></span><br><span class="line">		op[++cnt1] = i;</span><br><span class="line">		<span class="built_in">dfs</span>(i,f[i]);</span><br><span class="line">		cnt1 --;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt2;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,p[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n%d&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="acm-新生赛"><a href="#acm-新生赛" class="headerlink" title="acm 新生赛"></a>acm 新生赛</h2><p><strong><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/98528#question">第十六届西南石油大学程序设计新生赛<em>ACM&#x2F;NOI&#x2F;CSP&#x2F;CCPC&#x2F;ICPC 算法编程高难度练习赛</em>牛客竞赛 OJ</a></strong></p>
<h3 id="A-小刘的最短路"><a href="#A-小刘的最短路" class="headerlink" title="A 小刘的最短路"></a>A 小刘的最短路</h3><p>简单 ifelse 分情况判断，画图分析会更加清晰一点</p>
<h3 id="B-建造新家"><a href="#B-建造新家" class="headerlink" title="B 建造新家"></a>B 建造新家</h3><p><img src="/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0.assets/image-20241209105805539.png" alt="image-20241209105805539"></p>
<p>对于表达式中的 x++，来观察整个式子值的变化，剔除与初始式子相同的部分，剩下的部分就是每次改变的部分，那么就可以用类似前缀和计算的方法用 o(1)的时间复杂度算出每一个 x 的取值的对应值，最后枚举得以实现 o(n)算法</p>
<p>即我们可以得到每次取 x 的式子表达式变为</p>
<p>$$<br>\text{now} &#x3D; \text{f(i)} &#x3D; \text{f(i-1)} + s1 \times 2 \times (i - 1) - s2 \times 2 + s1<br>$$</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using i64 = long long;</span><br><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    std::vector&lt;i64&gt; a(n + 1, 0);</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        std::cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    i64 s1 = 0, s2 = 0;</span><br><span class="line">    for (i64 i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        s1 += a[i];</span><br><span class="line">        s2 += a[i] * i;</span><br><span class="line">    &#125;</span><br><span class="line">    //预处理式子改变量中的常数部分</span><br><span class="line">    i64 ans = 0, now = 0;</span><br><span class="line">    for (i64 i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        now += a[i] * (1 - i) * (1 - i);</span><br><span class="line">    &#125;</span><br><span class="line">    ans = now; // x取1时的表达式值，用于作为初始值</span><br><span class="line"></span><br><span class="line">    for (i64 i = 2; i &lt;= n; ++i) &#123;</span><br><span class="line">        now = now + s1 * 2 * (i - 1) - s2 * 2 + s1; //通过上面的公式计算新值（注意上面公式里面的x对应的应该是i-1哦！）</span><br><span class="line">        ans = std::min(ans, now); //枚举x的过程中动态更新答案即可</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个题中由于表达式是二次函数故而不需要复杂的求导就能直接找到取最小值时的点，故而也可以直接算出 f(i)之和表达式的对称轴，由对称轴计算即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//代码在https://ac.nowcoder.com/acm/contest/view-submission?submissionId=74064589</span><br><span class="line">//ceil是向上取整，floor是向下取整</span><br><span class="line">//为什么考试的时候没写对呢?哦哦原来是没有开longlong啊！</span><br><span class="line">//还有需要注意的是因为在运算中用到了i和a[i]，所以它们都需要开成longlong</span><br><span class="line">//答应我，下次算一下看看是不是要开longlong</span><br></pre></td></tr></table></figure>

<h3 id="C-合成大雪球"><a href="#C-合成大雪球" class="headerlink" title="C 合成大雪球"></a>C 合成大雪球</h3><p>对于求第 k 小&#x2F;大的问题，一般都可以想到二分，二分的条件一般是求比它小的元素有多少个，需要注意的是，如果比它小的元素有 k 个那么它应该是第 k+1 小的元素（必须考虑它自身）</p>
<p>对于这个题的数据很明显双遍历得到体积和的方案一定会超时的，由于这里的和由两个元素决定，所以跟之前招新考试的一个题类似，即枚举其中一个数来二分另外一个数。</p>
<p>这是外层的一个二分，即二分另一个数，但同时在这个二分中我们还需要另外一个二分即来二分判断是否是满足第 k 小的条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//考试的时候就一直在想怎么能对遍历求和进行优化</span><br><span class="line">//所以学到了枚举一个数二分另一个数</span><br><span class="line">//不要忘了对题目需要满足的条件进行二分判断</span><br><span class="line">//代码在https://ac.nowcoder.com/acm/contest/view-submission?submissionId=74098503</span><br></pre></td></tr></table></figure>

<h3 id="D-羽毛球比赛"><a href="#D-羽毛球比赛" class="headerlink" title="D 羽毛球比赛"></a>D 羽毛球比赛</h3><p>（我还没学 dfs 呢，等会儿再来）</p>
<h3 id="E-小青找宝藏"><a href="#E-小青找宝藏" class="headerlink" title="E 小青找宝藏"></a>E 小青找宝藏</h3><p>斐波拉契数列中第 45 项就已经大于 1e9 了，所以对于 0 到 1e9 的 n 来说，直接遍历三个斐波拉契数使其相加等于 n 时间复杂度最多也不过 o(45^3)即 o(91125)，所以是可以直接枚举出答案的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//谁能想到这个题是单纯枚举呢？？？？？</span><br><span class="line">//可以记一下 斐波拉契数列45项就＞1e9，我下次一定会遍历的</span><br><span class="line">//代码见https://ac.nowcoder.com/acm/contest/view-submission?submissionId=74100320</span><br></pre></td></tr></table></figure>

<h3 id="F-矩形面积"><a href="#F-矩形面积" class="headerlink" title="F 矩形面积"></a>F 矩形面积</h3><p>单调栈模板题</p>
<p>看过程，需要找到左边小于基准量的第一个位置和右边小于基准量的第一个位置，符合单调栈的工作原理</p>
<p>特别需要注意的是，为了能够进入计算部分，需要在左右分别添加一个值为 0 的哨兵元素，是为了处理数组本身就单调的情况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//谁能想到其实在刚开学那个月就做过这个题了呢</span><br><span class="line">//那个时候都还不知道啥是栈哇</span><br><span class="line">//光阴似箭岁月如梭</span><br><span class="line">//代码见https://ac.nowcoder.com/acm/contest/view-submission?submissionId=74102790</span><br></pre></td></tr></table></figure>

<p><strong>这时候就有人要问了，中间的题去哪了呢？？答案是太简单 or 太难了 hah</strong></p>
<h3 id="K-赚差价"><a href="#K-赚差价" class="headerlink" title="K 赚差价"></a>K 赚差价</h3><p><img src="/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0.assets/image-20241209203326445.png" alt="image-20241209203326445"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//我说白了这个题的数学运算实在是太复杂了所以直接贴付队发的解题思路</span><br><span class="line">//可以学的是找到问题的实质到底是什么，通过一些关系来减少模拟次数（比如说这里m/p相同就合并）</span><br><span class="line">//还有就是在使用各种算法或模拟之外，也可以讨论数学上的推论</span><br><span class="line">//代码见https://ac.nowcoder.com/acm/contest/view-submission?submissionId=74068323</span><br></pre></td></tr></table></figure>

<h3 id="L-编辑器"><a href="#L-编辑器" class="headerlink" title="L 编辑器"></a>L 编辑器</h3><p>此题特殊在各种操作都与现在的光标相关，故而我们需要两个数据结构分别去维护光标，又因为各种操作其实都是对上一个储存的元素就行访问所以想到用栈来处理。</p>
<p>通过对顶堆想到对顶栈，用一个栈来记录开头到光标位置，另一个栈来记录光标到结尾位置，两个栈都以光标位置作为栈顶，两个栈合起来就维护了整个序列。</p>
<p>而对于每个询问来说，直接再开一个数组来维护栈的前缀和即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//对顶栈维护整个序列的操作学到了</span><br><span class="line">//每次对左栈修改后就维护一次左边的前缀和，还是比较巧妙地</span><br><span class="line">//代码见https://www.acwing.com/problem/content/description/130/</span><br><span class="line">//不知道为什么我这个代码只在acwing上能过捏 但是我觉得应该是没什么问题嘟</span><br></pre></td></tr></table></figure>

<h2 id="牛客刷题小记"><a href="#牛客刷题小记" class="headerlink" title="牛客刷题小记"></a>牛客刷题小记</h2><h3 id="校外的树"><a href="#校外的树" class="headerlink" title="校外的树"></a>校外的树</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">题外话，记录这个题很大程度上是因为这是我第一场招新考试做到的题，纪念意义max；</span><br><span class="line">当然最主要的还是这个题因为数据的不同可以有几种做法</span><br></pre></td></tr></table></figure>

<p><strong>处理重复区间的最优方法</strong></p>
<p>按照题目的意思来看，是给每个区间内的树撤去，即减去这一部分的存在，然而由于有重复区间的存在，所以如果用减法就不可避免的多减，要避免此，每次都给减过的点打一个标记未免太过麻烦。所以我们可以转化思想，即初始化整个序列为 0，让每一个出现的区间中的数都加一，最后统计还为 0 的点就是最后剩下得树，这样的处理方法可以使得无论一个点被重复处理了多少次都不会影响最后剩下的树。</p>
<p>当然还有一种方法是通过 bool 数组给每一个点都打标记，这样就可以只统计没有被标记的点即是剩下的树了。</p>
<p><strong>不同数据下的不同做法</strong></p>
<p>1.在数据比较小的时候，可以直接使用遍历的做法，即给每一个区间内的点都去打标记，最后再统计没有被标记过的点的数量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代码见https://ac.nowcoder.com/acm/contest/view-submission?submissionId=74264751&amp;returnHomeType=1&amp;uid=401013592</span><br></pre></td></tr></table></figure>

<p>2.当数据比较大即遍历显然会超时的时候，结合题目让一个区间内的数改变，，可以用差分来实现，需要注意的还是上面介绍的应该是加 1，最后统计为 0 的点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代码见https://ac.nowcoder.com/acm/contest/view-submission?submissionId=74269667&amp;returnHomeType=1&amp;uid=401013592</span><br></pre></td></tr></table></figure>

<p>3.如果数据特别特别大，显然对于这些独立的需要处理的区间我们可以用离散化来处理，由于存在重叠的部分所以不妨直接先进行一次区间合并然后直接通过合并后的区间内的树的数目来计算（总数目-移走的数目）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代码见https://ac.nowcoder.com/acm/contest/view-submission?submissionId=74270870&amp;returnHomeType=1&amp;uid=401013592</span><br></pre></td></tr></table></figure>

<h3 id="二分（这个题跟二分无关）"><a href="#二分（这个题跟二分无关）" class="headerlink" title="二分（这个题跟二分无关）"></a>二分（这个题跟二分无关）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目和代码见https://ac.nowcoder.com/acm/problem/207053</span><br></pre></td></tr></table></figure>

<p>一道二分背景上的差分题目，我觉得还是挺有启发的。</p>
<p>最暴力的想法肯定是枚举每个数，最多符合条件的就应该是答案，显然过不了需要优化</p>
<p>可以想到，既然无法去判断每句话的真假那么不妨假设每句话都是真实的，并且依靠每一个判断给元素加权，最后我们找到权最大的就肯定是答案（即最多符合条件的点）</p>
<p>所以在这样的判断里可以想到用差分（对区间内的数做出改变），但同时因为边界可以达到正负 1e9，所以我们需要用 map 来离散化（因为我们需要判断的只有出现的几个数字）。最后判断加权的时候就相当于求这个 map 差分数组的前缀和。</p>
<h2 id="寒假刷题小记"><a href="#寒假刷题小记" class="headerlink" title="寒假刷题小记"></a>寒假刷题小记</h2><h3 id="1-全排列"><a href="#1-全排列" class="headerlink" title="1.全排列"></a>1.全排列</h3><p>给出 n 的全排列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 10;</span><br><span class="line">int ans[N],n;</span><br><span class="line">bool is[N];</span><br><span class="line"></span><br><span class="line">void dfs(int u)&#123;</span><br><span class="line">    if(u == n) &#123;</span><br><span class="line">        for(int i = 0;i &lt; n;i ++) cout &lt;&lt; ans[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">        if(!is[i])&#123;</span><br><span class="line">            ans[u] = i;</span><br><span class="line">            is[i] = true;</span><br><span class="line">            dfs(u + 1);</span><br><span class="line">            ans[u] = 0;</span><br><span class="line">            is[i] = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    dfs(0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-N-皇后"><a href="#2-N-皇后" class="headerlink" title="2.N 皇后"></a>2.N 皇后</h3><p>给出一个 n×nn\times nn×n 的国际象棋棋盘，你需要在棋盘中摆放 nnn 个皇后，使得任意两个皇后之间不能互相攻击。具体来说，不能存在两个皇后位于同一行、同一列，或者同一对角线。请问共有多少种摆放方式满足条件。</p>
<p>输入描述:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一行，一个整数n(1≤n≤12)n(1\le n \le 12)n(1≤n≤12)，表示棋盘的大小。</span><br></pre></td></tr></table></figure>

<p>输出描述:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出一行一个整数，表示总共有多少种摆放皇后的方案，使得它们两两不能互相攻击。</span><br></pre></td></tr></table></figure>

<p>代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 25;</span><br><span class="line">bool a[N],ug[N],g[N];</span><br><span class="line">int n,t;</span><br><span class="line"></span><br><span class="line">void dfs(int u)</span><br><span class="line">&#123;</span><br><span class="line">    if(u &gt; n) &#123; // 搜完了所有的行 即完成了一种排列</span><br><span class="line">        t ++;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        for(int i = 1;i &lt;= n;i ++) // 确定u相当于确定了行 故而只用遍历列</span><br><span class="line">        &#123;</span><br><span class="line">            if(!a[i] &amp;&amp; !ug[i + u] &amp;&amp; !g[n - u + i]) &#123; // 保证它不在同一列 同一对角线 同一反对角线</span><br><span class="line">                a[i] = ug[u + i] = g[n - u + i] = true;</span><br><span class="line">                dfs(u + 1); // 如果当前满足了 就继续往前搜</span><br><span class="line">                a[i] = ug[i + u] = g[i - u + n] = false; //回溯复原</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    dfs(1);</span><br><span class="line">    cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特别需要关注的几个点有：</p>
<p>一，在一个方格图中，采用的是确定行来遍历列的思想，在其他情况，有可能就是去分析行列谁放在外循环谁放在内循环的区别</p>
<p>二，在方格图中关于对角线，反对角线的表述，以及其与坐标的下标之间的关系</p>
<h3 id="3-马走日"><a href="#3-马走日" class="headerlink" title="3.马走日"></a>3.马走日</h3><p>题目描述</p>
<p>在 n 行 m 列的棋盘上有一个中国象棋的马，马走日字且不能向左走，设原本坐标为(x,y)走一步可以达到的位置有(x+1,y+2),(x+2,y+1),(x+2,y−1)(x+1,y-2)并且不能走出棋盘。请找到可行路径的条数，使得马从棋盘的左下角(1,1)走到右上角(n,m)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一行，两个整数n,m(1≤n,m≤15)n,m(1\le n,m \le 15)n,m(1≤n,m≤15)，表示棋盘的大小。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出一行一个整数，表示马从左下角到右上角的不同路径数。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 100;</span><br><span class="line">int n,m,t;</span><br><span class="line">int dx[4] = &#123;1,1,2,2&#125;;</span><br><span class="line">int dy[4] = &#123;2,-2,1,-1&#125;; // 用两个数组来表示方向的移动向量，在移动的时候只需要去遍历数组即可，类似于上面对上下左右的处理</span><br><span class="line"></span><br><span class="line">void dfs(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    if(x == n &amp;&amp; y == m)</span><br><span class="line">    &#123;</span><br><span class="line">        t ++;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(x &gt; n || x &lt; 1 || y &gt; m || y &lt; 1) return;</span><br><span class="line">    else &#123;</span><br><span class="line">        for(int i = 0;i &lt; 4;i ++) dfs(x + dx[i],y + dy[i]);</span><br><span class="line">        //每次循环就相当于往一种情况移动，再以这种移动进入dfs直到出界或者走到终点，如果出界的话就会被return到上一层的dfs，相当于进行了一次回溯</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    dfs(1,1);</span><br><span class="line">    cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里的 dfs 是多个方向的一条路走到黑，多个方向的选择是通过数组的循环来实现的</p>
<p>比如说，第一次 dfs 后，向第一种方向走，以这种状态进入第二层 dfs，然后又向第一种方向走，进入第三层 dfs，如果此时出界了就会 return 回第二层 dfs，由于之前第一方向已经走过了，所以就会向第二种方向走、</p>
<p>就是通过这样的不断迭代和回溯来实现对所有走法的可行路径的全统计</p>
<h3 id="4-数独"><a href="#4-数独" class="headerlink" title="4. 数独"></a>4. 数独</h3><p><img src="/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0.assets/image-20250110154326439.png" alt="image-20250110154326439"></p>
<p>代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 100;</span><br><span class="line">int mp[12][12],cnt;</span><br><span class="line">bool h[12][12],l[12][12],gong[12][12];</span><br><span class="line">//dfs的一个关键点是如何判断可行从而进行下一步搜索</span><br><span class="line">//根据数独的要求这里分为行列和九宫格三个判断条件</span><br><span class="line"></span><br><span class="line">struct sp&#123;</span><br><span class="line">    int x;</span><br><span class="line">    int y;</span><br><span class="line">&#125;space[N];</span><br><span class="line"></span><br><span class="line">const int g[10][10] = &#123; &#123;0,0,0,0,0,0,0,0,0,0&#125;,</span><br><span class="line">					 &#123;0,1,1,1,2,2,2,3,3,3&#125;,</span><br><span class="line">					 &#123;0,1,1,1,2,2,2,3,3,3&#125;,</span><br><span class="line">					 &#123;0,1,1,1,2,2,2,3,3,3&#125;,</span><br><span class="line">					 &#123;0,4,4,4,5,5,5,6,6,6&#125;,</span><br><span class="line">					 &#123;0,4,4,4,5,5,5,6,6,6&#125;,</span><br><span class="line">					 &#123;0,4,4,4,5,5,5,6,6,6&#125;,</span><br><span class="line">					 &#123;0,7,7,7,8,8,8,9,9,9&#125;,</span><br><span class="line">					 &#123;0,7,7,7,8,8,8,9,9,9&#125;,</span><br><span class="line">					 &#123;0,7,7,7,8,8,8,9,9,9&#125;, &#125;;</span><br><span class="line">//这里使用了一个打表的小技巧，通过二维数组的值来代指目前的位置处于第几个九宫格 巧思啊！</span><br><span class="line"></span><br><span class="line">void print()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 1;i &lt;= 9;i ++)</span><br><span class="line">        for(int j = 1;j &lt;= 9;j ++) &#123;</span><br><span class="line">            cout &lt;&lt; mp[i][j];</span><br><span class="line">            if(j == 9) cout &lt;&lt; endl;</span><br><span class="line">            else cout &lt;&lt; &quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs(int u)</span><br><span class="line">&#123;</span><br><span class="line">    if(u &gt; cnt) &#123;</span><br><span class="line">        print();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        for(int i = 1;i &lt;= 9; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            int xx = space[u].x; int yy = space[u].y;</span><br><span class="line">            if(!h[xx][i] &amp;&amp; !l[yy][i] &amp;&amp; !gong[g[xx][yy]][i])</span><br><span class="line">            &#123;</span><br><span class="line">                h[xx][i] = 1, l[yy][i] = 1, gong[g[xx][yy]][i] = 1;</span><br><span class="line">                mp[xx][yy] = i;</span><br><span class="line">                dfs(u + 1);</span><br><span class="line">                h[xx][i] = l[yy][i] = gong[g[xx][yy]][i] = 0;</span><br><span class="line">                mp[xx][yy] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   for(int i = 1;i &lt;= 9;i ++)</span><br><span class="line">   &#123;</span><br><span class="line">       for(int j = 1;j &lt;= 9;j ++) &#123;</span><br><span class="line">           cin &gt;&gt; mp[i][j];</span><br><span class="line">           if(mp[i][j] == 0) &#123;</span><br><span class="line">               space[++cnt].x = i;</span><br><span class="line">               space[cnt].y = j;</span><br><span class="line">           &#125;</span><br><span class="line">           h[i][mp[i][j]] = true;</span><br><span class="line">           l[j][mp[i][j]] = true;</span><br><span class="line">           gong[g[i][j]][mp[i][j]] = true;</span><br><span class="line">           //这里的三个布尔数组的意思为，第i行的这个数已经存在以此类推</span><br><span class="line">           //故而在dfs过程中，实际上深搜的是从1~9的每个数，即这个数可以放在哪些地方</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    dfs(1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dfs-小结"><a href="#dfs-小结" class="headerlink" title="dfs 小结"></a>dfs 小结</h3><p>在 dfs 的相关问题中，主要的步骤是进行递归和回溯。</p>
<p>进行的关键点在于什么时候进入递归，以及回溯的准确性。</p>
<p>什么时候进入递归？？</p>
<p><strong>当前状态可行</strong> -&gt;<strong>先将当前标记为已走过</strong> ** -&gt; **深入到下一步状态**</p>
<p>回溯？？</p>
<p>回溯需要重新标记为没有走过</p>
<p>如果没有标记的需要，那么回溯一般表现为 return 回上一层 dfs</p>
<h3 id="5-这里有四道题-牛客周赛"><a href="#5-这里有四道题-牛客周赛" class="headerlink" title="5.(这里有四道题)牛客周赛"></a>5.(这里有四道题)牛客周赛</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目见https://ac.nowcoder.com/acm/contest/99990</span><br></pre></td></tr></table></figure>

<h4 id="q1"><a href="#q1" class="headerlink" title="q1 :"></a><strong>q1</strong> :</h4><p>理清楚逻辑即可，关于周末双休计算 n 天贡献的题还是蛮常见的</p>
<h4 id="q2-："><a href="#q2-：" class="headerlink" title="q2 ："></a><strong>q2</strong> ：</h4><p>构造题，做的时候想太多了，关键在于字符串中单一个字母也可以称其为字串，故而直接找到字符串中出现次数最多的字母即可</p>
<p>补充一下关于记录字母出现次数方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line">//建立计数数组</span><br><span class="line">cnt[N];</span><br><span class="line">int n = s.length();</span><br><span class="line">for(int i = 0;i &lt; n;i ++)</span><br><span class="line">&#123;</span><br><span class="line">	cnt[s[i]- &#x27;a&#x27;] ++; // 此处的s[i]- &#x27;a&#x27;实际为在字母表中出现的位置，故而后面可以还原这个字母</span><br><span class="line">&#125;</span><br><span class="line">//假设出现次数最多的是cnt[t],还原字母(0 &lt; t &lt; 26)</span><br><span class="line">char a = (char)(&#x27;a&#x27; + t);</span><br></pre></td></tr></table></figure>

<h4 id="q3"><a href="#q3" class="headerlink" title="q3 :"></a><strong>q3</strong> :</h4><p>一道关于最大公约数 gcd 的思维题，先在这里介绍一下 gcd</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//在c ++ 中可以直接调用函数</span><br><span class="line">#include &lt;numeric&gt;</span><br><span class="line">int a = gcd(4,6);</span><br><span class="line">//底层的计算逻辑如下</span><br><span class="line">int gcd(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">	if(b == 0) return a;</span><br><span class="line">	else return gcd(b,a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于这道题本身，因为可以进行任意次操作将两个数都变为它们的最大公约数，故而可以知道，要使整个数组的元素之和最小，就要使数组中的每个数都变成所有数的最大公约数</p>
<p><strong>最大公约数的传递性</strong>：如果我们对多个数连续应用 GCD 操作，结果等于这些数的最大公约数。例如，对于三个数 a,b,c<em>a</em>,<em>b</em>,_c_，有 gcd(a,gcd(b,c))&#x3D;gcd(a,b,c)gcd(<em>a</em>,gcd(<em>b</em>,<em>c</em>))&#x3D;gcd(<em>a</em>,<em>b</em>,<em>c</em>)。</p>
<p><strong>最小化和的关键</strong>：由于我们可以选择任意两个数进行 GCD 操作，并且可以进行任意次操作，实际上我们可以将整个数组的所有元素通过一系列的 GCD 操作合并成一个值，即所有元素的最大公约数。因为 GCD 的结果不会大于原来的任何一个数，所以这是能获得的最小可能值。</p>
<p>所以我们计算完所有元素的最大公约数 q 后，最后的数组和即为 n * q</p>
<h4 id="q4"><a href="#q4" class="headerlink" title="q4 :"></a><strong>q4</strong> :</h4><p>这道题出错了。。 可以想一下贪心的思维，要最小化，就可以从最大的开始处理，故而用一个大根堆可以处理</p>
<h3 id="6-双人迷宫相遇问题"><a href="#6-双人迷宫相遇问题" class="headerlink" title="6.双人迷宫相遇问题"></a>6.双人迷宫相遇问题</h3><p><img src="/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0.assets/image-20250114162104562.png" alt="image-20250114162104562"></p>
<p>即一个双重 bfs，两个人同时进行 bfs，当 a 中途走到了 b 走过的地方即证明已经相遇了，关键就是在于如何去建立 ab 两人之间的关系</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef pair&lt;int,int&gt; pp;</span><br><span class="line"></span><br><span class="line">char b[1005][1005];</span><br><span class="line">int x1,y1,x2,y2;</span><br><span class="line">int n,m;</span><br><span class="line">queue&lt;pp&gt;q[2]; //q[0]即为小B，q[1]为小A</span><br><span class="line">//用0，1其实是一个小技巧，在需要联系另一个人的时候直接非！一次即可</span><br><span class="line">bool flag ,v[2][1005][1005] ; //同理我们用这样一个三维的bool数组来分开标记a和b走过的地方</span><br><span class="line">int ans = 0;</span><br><span class="line">int dx[] = &#123;0,0,1,-1,1,1,-1,-1&#125;; int dy[] = &#123;1,-1,0,0,1,-1,1,-1&#125;;</span><br><span class="line"></span><br><span class="line">bool bfs(int a)</span><br><span class="line">&#123;</span><br><span class="line">    int x = 0,y = 0;</span><br><span class="line">    int t = q[a].size();</span><br><span class="line">    while(t --)</span><br><span class="line">    &#123;</span><br><span class="line">        auto qq = q[a].front();</span><br><span class="line">        q[a].pop();</span><br><span class="line">        for(int i = 0;i &lt; 4 + (a?4:0);i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            x =qq.first + dx[i],y = qq.second + dy[i];</span><br><span class="line">            if(x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m || b[x][y] == &#x27;#&#x27;|| v[a][x][y]) continue;</span><br><span class="line">            if(v[!a][x][y]) &#123;</span><br><span class="line">                flag = 1;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            v[a][x][y] = 1;</span><br><span class="line">            q[a].push(&#123;x,y&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for(int i = 0;i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j = 0;j &lt; m;j ++)&#123;</span><br><span class="line">            cin &gt;&gt; b[i][j];</span><br><span class="line">            if(b[i][j] == &#x27;D&#x27;) x1 = i, y1 = j;</span><br><span class="line">            if(b[i][j] == &#x27;C&#x27;) x2 = i, y2 = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    v[0][x1][y1] = true; q[0].push(&#123;x1,y1&#125;);</span><br><span class="line">    v[1][x2][y2] = true; q[1].push(&#123;x2,y2&#125;);</span><br><span class="line">    while(!q[1].empty() || !q[0].empty())</span><br><span class="line">    &#123;</span><br><span class="line">        ans ++;</span><br><span class="line">        if(bfs(0)) break;</span><br><span class="line">        if(bfs(0)) break;</span><br><span class="line">        if(bfs(1)) break;</span><br><span class="line">    &#125;</span><br><span class="line">    if(flag) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl &lt;&lt; ans;</span><br><span class="line">    else cout &lt;&lt; &quot;NO&quot;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-地雷递推"><a href="#7-地雷递推" class="headerlink" title="7.地雷递推"></a>7.地雷递推</h3><p><img src="/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0.assets/image-20250114221410059.png" alt="image-20250114221410059"></p>
<p>关键在于找到规律，对于地雷问题</p>
<p><img src="/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0.assets/image-20250114221603813.png" alt="image-20250114221603813"></p>
<p>即我们需要把题目的描述转化为状态方程，进而模拟过程，对于这类问题，特别需要注意的就是特殊情况的特判</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e4 + 10;</span><br><span class="line">int ans,n,a[N],f[N];</span><br><span class="line">int flag;</span><br><span class="line"></span><br><span class="line">int hi()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 2;i &lt; n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        int t = a[i] - f[i-1] - f[i];</span><br><span class="line">        if(t &lt; 0 || t &gt; 1) return 0;</span><br><span class="line">        else f[i+1] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    if(f[n] + f[n-1] != a[n]) return 0;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        if(a[i] &gt; 3) flag = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if(a[0] &gt; 2 || a[n-1] &gt; 2 || flag)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; 0 &lt;&lt; endl;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(a[1] == 2)</span><br><span class="line">    &#123;</span><br><span class="line">        f[1] = 1;</span><br><span class="line">        f[2] = 1;</span><br><span class="line">        ans += hi();</span><br><span class="line">    &#125;</span><br><span class="line">    else if(a[1] == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        f[1] = 0;</span><br><span class="line">        ans += hi();</span><br><span class="line">    &#125;</span><br><span class="line">    else if(a[1] == 1)</span><br><span class="line">    &#123;</span><br><span class="line">        f[1] = 1;</span><br><span class="line">        ans += hi();</span><br><span class="line">        memset(f,0,sizeof f);</span><br><span class="line">        f[2] = 1;</span><br><span class="line">        ans += hi();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-贪心拼数"><a href="#8-贪心拼数" class="headerlink" title="8.贪心拼数"></a>8.贪心拼数</h3><p><img src="/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0.assets/image-20250115104844171.png" alt="image-20250115104844171"></p>
<p>按照字典序大的排列即可，这里的做法是给 sort 自定义一个 cmp 来排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">bool cmp(string a,string b)</span><br><span class="line">&#123;</span><br><span class="line">    return a + b &gt; b + a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n; cin &gt;&gt; n;</span><br><span class="line">    string s[n];</span><br><span class="line">    for(int i = 0;i &lt; n;i ++) cin &gt;&gt; s[i];</span><br><span class="line">    sort(s,s + n,cmp);</span><br><span class="line">    for(int i = 0;i &lt; n;i ++) cout &lt;&lt; s[i];</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-贪心排座椅"><a href="#9-贪心排座椅" class="headerlink" title="9.贪心排座椅"></a>9.贪心排座椅</h3><p><img src="/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0.assets/image-20250115112746614.png" alt="image-20250115112746614"></p>
<p>要使得上课交头接耳的学生对数最少，即要使我们划分的过道能够隔开最多的交头接耳学生对数</p>
<p>那么每次划分时，都对这条线隔开的同学对数计数（由于需要划分的行列可能是相同的，故而每次划分就是对这条过道的 cnt++）</p>
<p>最后要找到最优解只需要按照计数排序就可以得到</p>
<p>还需要注意的是输出的答案是有序的，故而还需要对划分的行进行排序</p>
<p>故而每一个划分都有数量和行数两个属性，用结构体储存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1e4;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int cnt;</span><br><span class="line">    int id;</span><br><span class="line">&#125;ct1[N],ct2[N];</span><br><span class="line"></span><br><span class="line">bool cmpcnt(node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">    return a.cnt &gt; b.cnt; //从大到小找最优解</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool cmpid(node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">    return a.id &lt; b.id; //从小到大满足输出要求</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int m,n,k,l,d; cin &gt;&gt; m &gt;&gt; n &gt;&gt; k &gt;&gt; l &gt;&gt; d;</span><br><span class="line">    while(d --)</span><br><span class="line">    &#123;</span><br><span class="line">        int x,y,p,q; cin &gt;&gt; x &gt;&gt; y &gt;&gt; p &gt;&gt; q;</span><br><span class="line">        if(x == p)</span><br><span class="line">        &#123;</span><br><span class="line">            int yy = min(y,q);</span><br><span class="line">            ct1[yy].cnt ++;</span><br><span class="line">            ct1[yy].id = yy;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(y == q)</span><br><span class="line">        &#123;</span><br><span class="line">            int xx = min(x,p);</span><br><span class="line">            ct2[xx].cnt ++;</span><br><span class="line">            ct2[xx].id = xx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ct1,ct1 + n,cmpcnt);</span><br><span class="line">    sort(ct2,ct2 + m,cmpcnt);</span><br><span class="line">    sort(ct1,ct1 + l,cmpid);</span><br><span class="line">    sort(ct2,ct2 + k,cmpid);</span><br><span class="line">    for(int i = 0;i &lt; k;i ++) cout &lt;&lt; ct2[i].id &lt;&lt; &quot; &quot;;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    for(int i = 0;i &lt; l;i ++) cout &lt;&lt; ct1[i].id &lt;&lt; &quot; &quot;;</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-贪心国王的问题"><a href="#10-贪心国王的问题" class="headerlink" title="10.贪心国王的问题"></a>10.贪心国王的问题</h3><p><img src="/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0.assets/image-20250115204622555.png" alt="image-20250115204622555"></p>
<p>我们对于国王身后的两个点来分析</p>
<p>队列可能是这样的：</p>
<table>
<thead>
<tr>
<th align="left">*</th>
<th align="right">Left</th>
<th align="center">Right</th>
</tr>
</thead>
<tbody><tr>
<td align="left">king:</td>
<td align="right"><img src="https://www.nowcoder.com/equation?tex=a_0" alt="img"></td>
<td align="center"><img src="https://www.nowcoder.com/equation?tex=b_0" alt="img"></td>
</tr>
<tr>
<td align="left">p1</td>
<td align="right"><img src="https://www.nowcoder.com/equation?tex=a_1" alt="img"></td>
<td align="center"><img src="https://www.nowcoder.com/equation?tex=b_1" alt="img"></td>
</tr>
<tr>
<td align="left">p2</td>
<td align="right"><img src="https://www.nowcoder.com/equation?tex=a_2" alt="img"></td>
<td align="center"><img src="https://www.nowcoder.com/equation?tex=b_2" alt="img"></td>
</tr>
</tbody></table>
<p>那么我们计算可得<img src="https://www.nowcoder.com/equation?tex=ans_1%20=max(%5Cfrac%7Ba_0%7D%7Bb_1%7D,%5Cfrac%7Ba_0%5Ctimes%20a_1%7D%7Bb_2%7D)" alt="img"></p>
<p>队列也有可能是这样的</p>
<table>
<thead>
<tr>
<th align="left">*</th>
<th align="right">Left</th>
<th align="center">Right</th>
</tr>
</thead>
<tbody><tr>
<td align="left">king:</td>
<td align="right"><img src="https://www.nowcoder.com/equation?tex=a_0" alt="img"></td>
<td align="center"><img src="https://www.nowcoder.com/equation?tex=b_0" alt="img"></td>
</tr>
<tr>
<td align="left">p2</td>
<td align="right"><img src="https://www.nowcoder.com/equation?tex=a_2" alt="img"></td>
<td align="center"><img src="https://www.nowcoder.com/equation?tex=b_2" alt="img"></td>
</tr>
<tr>
<td align="left">p1</td>
<td align="right"><img src="https://www.nowcoder.com/equation?tex=a_1" alt="img"></td>
<td align="center"><img src="https://www.nowcoder.com/equation?tex=b_1" alt="img"></td>
</tr>
</tbody></table>
<p>那么我们计算可得<img src="https://www.nowcoder.com/equation?tex=ans_2%20=max(%5Cfrac%7Ba_0%7D%7Bb_2%7D,%5Cfrac%7Ba_0%5Ctimes%20a_2%7D%7Bb_1%7D)" alt="img"></p>
<p>我们来对比一下两个答案：</p>
<p><img src="https://www.nowcoder.com/equation?tex=ans_1%20=max(%5Cfrac%7Ba_0%7D%7Bb_1%7D,%5Cfrac%7Ba_0%5Ctimes%20a_1%7D%7Bb_2%7D)" alt="img"></p>
<p><img src="https://www.nowcoder.com/equation?tex=ans_2%20=max(%5Cfrac%7Ba_0%7D%7Bb_2%7D,%5Cfrac%7Ba_0%5Ctimes%20a_2%7D%7Bb_1%7D)" alt="img"></p>
<p>可以替换得：</p>
<p><img src="https://www.nowcoder.com/equation?tex=ans_1=max(k_1,k_2)" alt="img"></p>
<p><img src="https://www.nowcoder.com/equation?tex=ans_2%20=max(k_3,k_4)" alt="img"></p>
<p>显然我们可以得到:</p>
<p><img src="https://www.nowcoder.com/equation?tex=%5Cfrac%7Ba_0%5Ctimes%20a_1%7D%7Bb_2%7D%20%3E%5Cfrac%7Ba_0%7D%7Bb_2%7D" alt="img"></p>
<p><img src="https://www.nowcoder.com/equation?tex=%5Cfrac%7Ba_0%5Ctimes%20a_2%7D%7Bb_1%7D%20%3E%5Cfrac%7Ba_0%7D%7Bb_1%7D" alt="img"></p>
<p>即：<img src="https://www.nowcoder.com/equation?tex=k_2%3Ek_3" alt="img"></p>
<p><img src="https://www.nowcoder.com/equation?tex=k_4%3Ek_1" alt="img"></p>
<p>如果<img src="https://www.nowcoder.com/equation?tex=ans_1%3Cans_2" alt="img"></p>
<p>那么易得：</p>
<p><img src="https://www.nowcoder.com/equation?tex=k_4%3Ek_2" alt="img"></p>
<p>即： <img src="https://www.nowcoder.com/equation?tex=%5Cfrac%7Ba_0%5Ctimes%20a_2%7D%7Bb_1%7D%20%3E%5Cfrac%7Ba_0%20%5Ctimes%20a_1%7D%7Bb_2%7D" alt="img"></p>
<p>变形可得：</p>
<p><img src="https://www.nowcoder.com/equation?tex=a_1%5Ctimes%20b_1%3Ca_2%5Ctimes%20b_2" alt="img"></p>
<p>当<img src="https://www.nowcoder.com/equation?tex=a_1%5Ctimes%20b_1%3Ca_2%5Ctimes%20b_2" alt="img">时，我们也能够得到<img src="https://www.nowcoder.com/equation?tex=ans_1%20%3Cans_2" alt="img">的结论</p>
<p>所以，为了<img src="https://www.nowcoder.com/equation?tex=ans" alt="img">取到最小值，我们需要将<img src="https://www.nowcoder.com/equation?tex=a_i%5Ctimes%20b_i" alt="img">较小的放在前面</p>
<p>这即是需要的贪心的关键点。而后需要写高精度来满足题目</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int fir,sec;</span><br><span class="line">    bool operator &lt; (const node &amp;a)const&#123;</span><br><span class="line">        return fir*sec&lt;a.fir*a.sec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;st[1005];</span><br><span class="line">int sum[5050];</span><br><span class="line">int vis[5050];</span><br><span class="line">int arr[5050];</span><br><span class="line">int len=1,tex=1;</span><br><span class="line">void cheng(int b)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=1;i&lt;=len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vis[i]*=b;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vis[i+1]+=vis[i]/10;</span><br><span class="line">        vis[i]%=10;</span><br><span class="line">    &#125;</span><br><span class="line">    if(vis[len+1]!=0) len++;</span><br><span class="line">    while(vis[len]&gt;10)</span><br><span class="line">    &#123;</span><br><span class="line">        vis[len+1]+=vis[len]/10;</span><br><span class="line">        vis[len]%=10;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void chu(int b)</span><br><span class="line">&#123;</span><br><span class="line">    int t=0,flag=0,ans=0;</span><br><span class="line">    for(int i=len;i&gt;=1;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        t=t*10+vis[i];</span><br><span class="line">        if(t&lt;b&amp;&amp;flag==0) continue;</span><br><span class="line">        else&#123;</span><br><span class="line">            flag=1;</span><br><span class="line">            arr[++ans]=t/b;</span><br><span class="line">            t%=b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(ans&gt;tex)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=1;i&lt;=ans;i++) sum[i]=arr[i];</span><br><span class="line">        tex=ans;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        if(ans==tex)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int i=1;i&lt;=ans;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(arr[i]&gt;sum[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    for(int i=1;i&lt;=ans;i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        sum[i]=arr[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=0;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;st[i].fir&gt;&gt;st[i].sec;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(st+1,st+1+n);</span><br><span class="line">    sum[1]=vis[1]=1;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cheng(st[i-1].fir);</span><br><span class="line">        chu(st[i].sec);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=tex;i++) cout&lt;&lt;sum[i];</span><br><span class="line">    cout&lt;&lt;&quot;\n&quot;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="贪心小结"><a href="#贪心小结" class="headerlink" title="贪心小结"></a>贪心小结</h3><p>贪心问题，一般需要安排某种情况使得结果最优，获得这种最优解的方法一般有两种</p>
<p>一是直接按照题意模拟出情况，最后排序得出最优的情况（例如上面的拼座椅）</p>
<p>二是按照题意推出得到最优解的关键条件，进而对数据进行排序，从而直接得到最优的结果（例如上面的国王的问题和拼数）</p>
<p>当然可以看出，贪心中一个很重要的点就是排序，关键是找到排序的关键词！！！</p>
<h3 id="11-先序排列"><a href="#11-先序排列" class="headerlink" title="11.先序排列"></a>11.先序排列</h3><p>之前写过这里就不写了</p>
<h3 id="12-二分晾衣服"><a href="#12-二分晾衣服" class="headerlink" title="12.二分晾衣服"></a>12.二分晾衣服</h3><p><img src="/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0.assets/image-20250117092642591.png" alt="image-20250117092642591"></p>
<p>首先看到问题是求最短时间，故而考虑是二分还是贪心</p>
<p>观察题目，时间少就不能完全烘干，时间长就不满足最短的限制，故而答案是单调的，进而应该选择二分答案</p>
<p>这道题的主要误区在于容易陷入贪心的思维，即想要对烘干顺序进行安排，但注意这里我们已经得出是单调二分，故而思维应该着重在 <strong>验证</strong></p>
<p>怎么写这个 check 函数呢，现在的这个时间需要让所有衣服都被烘干，那么只需要算出把每件衣服全都烘干的时间，跟此时的答案比较即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bool check(int x)</span><br><span class="line">&#123;</span><br><span class="line">	int b[N];</span><br><span class="line">	memcpy(b,a,sizeof a);</span><br><span class="line">	ll ci = 0; //第一个容易错的点，最终的时间和是可能爆int的</span><br><span class="line">	for(int i = 1;i &lt;= n;i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		b[i] -= x; //x的时间，每一个时间减少1水分，x时间减少x水分</span><br><span class="line">		if(b[i] &gt; 0) ci += ceil((double)b[i] / (k - 1)); //由于每分钟自己减少的1已经计算，所以会额外减少k-1水分。</span><br><span class="line">		//为什么要用ceil是由于必须要把每件衣服都烘干，宁多不少</span><br><span class="line">	&#125;</span><br><span class="line">	return ci &lt;= x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还注意一个特判，如果烘干机每分钟烘干的水分比自然减少的 1 还少的话，那么就不用烘干机，所有衣服水分中的最大值作为时间就可以烘干所有的衣服。</p>
<p>下面看完整代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line">const int N = 1e5 + 10;</span><br><span class="line">int a[N],n,k;</span><br><span class="line"></span><br><span class="line">bool check(int x)</span><br><span class="line">&#123;</span><br><span class="line">    int b[N];</span><br><span class="line">    ll sum = 0;</span><br><span class="line">    memcpy(b,a,sizeof a);</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        b[i] -= x;</span><br><span class="line">        if(b[i] &gt; 0) sum += ceil((double)b[i] / (k - 1));</span><br><span class="line">    &#125;</span><br><span class="line">    if(sum &gt; x) return false;</span><br><span class="line">    return true ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    int mx = 0;</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        mx = max(mx,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    if(k &lt;= 1) &#123;</span><br><span class="line">        cout &lt;&lt; mx &lt;&lt; endl;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int l = 0, r = 0x3f3f3f3f;</span><br><span class="line">    while(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid = (l + r) / 2;</span><br><span class="line">        if(check(mid)) r = mid;</span><br><span class="line">        else l = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; l;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-表达式求值"><a href="#13-表达式求值" class="headerlink" title="13.表达式求值"></a>13.表达式求值</h3><p>作为一道很典的题，一般是用栈分别存下数字和运算符，但不可避的问题是</p>
<h3 id="14-并查集"><a href="#14-并查集" class="headerlink" title="14.并查集"></a>14.并查集</h3><p>这道题虽然是并查集的模板题，但还要用字符串去储存名字，所以可以很直观地认识并查集的原理，在这里记录一下</p>
<h3 id="15-牛客周赛-a-b（2）"><a href="#15-牛客周赛-a-b（2）" class="headerlink" title="15.牛客周赛 a+b（2）"></a>15.牛客周赛 a+b（2）</h3><p>（因为是赛后随便看了一下所以没有做后面的题） 这里记录一下 b，不知道应该算是博弈还是贪心</p>
<p><img src="/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0.assets/image-20250121111842766.png" alt="image-20250121111842766"></p>
<p>其实是一道思维题，不管是平均数还是中位数，最优的情况一定是能拿到足够多的大数，故而 k1k2 对于最优情况的考虑是没有意义的</p>
<p>由于这道题是需要自己先选，故而想要让菲菲拿到最少的大数，故而最优的划分情况应该是自己拿前 n-1 个数字，只留下最后一个数字给菲菲</p>
<p>又由于平均数肯定会小于或等于前 n-1 个数，那么是否拥有必胜策略就只需要看最后一个数是否大于前面 n-1 个数即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 2e5 + 10;</span><br><span class="line">int a[N];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,k1,k2; cin &gt;&gt; n &gt;&gt; k1 &gt;&gt; k2;</span><br><span class="line">    int mx = -1;</span><br><span class="line">    for(int i = 0;i &lt; n;i ++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        mx = max(mx,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    if(mx &gt; a[n-1]) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;</span><br><span class="line">    else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-cfdiv2（2）"><a href="#16-cfdiv2（2）" class="headerlink" title="16.cfdiv2（2）"></a>16.cfdiv2（2）</h3><p>a.<img src="/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0.assets/image-20250121113015971.png" alt="image-20250121113015971"></p>
<p>其实就是一个简单的模拟，但需要关注的是怎么最简单的得出</p>
<p><img src="/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0.assets/image-20250121113124881.png" alt="image-20250121113124881"></p>
<p><img src="/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0.assets/image-20250121113139110.png" alt="image-20250121113139110"></p>
<p>观察样例图解可知，其实</p>
<p>$$<br>整体周长 &#x3D; 每一次移动形成的矩形的周长 - 重叠部分矩形的周长<br>$$</p>
<p>重叠部分的矩形的对顶点实则是</p>
<p>$$<br>上一个正方形的右上顶点和下一个正方形的左下起点<br>$$</p>
<p>故而直接每次记录即可（因为保证了肯定是向左上方移动的）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while(t --)</span><br><span class="line">    &#123;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        int n, m;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        int a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        ans += 4 * m;</span><br><span class="line">        n = n - 1;</span><br><span class="line">        while(n --)</span><br><span class="line">        &#123;</span><br><span class="line">            int x1, y1;</span><br><span class="line">            cin &gt;&gt; x1 &gt;&gt; y1;</span><br><span class="line">            ans += 4 * m;</span><br><span class="line">            if(m &gt; x1 &amp;&amp; m &gt; y1)</span><br><span class="line">                ans -= (m - x1 + m - y1) * 2;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c.</p>
<h3 id="17-牛客寒假训练营-1"><a href="#17-牛客寒假训练营-1" class="headerlink" title="17.牛客寒假训练营 1"></a>17.牛客寒假训练营 1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比赛链接https://ac.nowcoder.com/acm/contest/95323（包括题目和代码）</span><br></pre></td></tr></table></figure>

<h4 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h4><p>这次比赛发现的最大的问题就是关于提前终止读入导致数据错位的问题，即比如说在多组数据中，在某一组的读入环节提前终止了读入，就会导致后续的读入都发生错误</p>
<p>比如说<img src="/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0.assets/image-20250122141308415.png" alt="image-20250122141308415"></p>
<p>在读入数组数据的过程中出现 1 就停止，就会导致后续数据错位</p>
<p>正确做法应该是给一个标记，在所有数据读入完后再输出</p>
<p><img src="/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0.assets/image-20250122141413358.png" alt="image-20250122141413358"></p>
<h4 id="a"><a href="#a" class="headerlink" title="a."></a>a.</h4><p>简单逻辑题，什么数能够确保它不是任何数的倍数，任何数也不是它的倍数呢</p>
<p>对于第一个限制条件，很显然它需要是一个倍数，对于第二个限制条件，只需要它比数组内可能的最大值大即可</p>
<p>数组内的数的范围是 1e9，故而直接输出一个大于 1e9 的数即可</p>
<h4 id="b"><a href="#b" class="headerlink" title="b."></a>b.</h4><p>要求找一条路能够不重不漏地通过树上的所有节点，那么什么时候才可能出现这样的路径呢</p>
<p><img src="/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0.assets/image-20250122141923225.png" alt="image-20250122141923225"></p>
<p>显然这棵树必须要是链状的才能满足</p>
<p>而要判断是不是链状的，我们只需要把这个树以图的方式储存下来，判断其的入度即可，只要度数大于 2，则树肯定非链状，直接输出-1 即可。</p>
<p>如果已经证明是链状的，只需要找到度数为 1 的点，根据上图可以看出，度数为 1 的点一定是起点或者终点，故而输出两个找到的点即可</p>
<p>这里的代码是用邻接表存的</p>
<h4 id="d"><a href="#d" class="headerlink" title="d."></a>d.</h4><p>这里 wa 了好几发的主要原因还是数据错位的问题，这里就不再多说了</p>
<p>只是这里再次说一下，关于数据出现的次数问题，用哈希表可以比较简便地记录，如果是记录出现次数就使用 intint 的哈希表即可，如果是记录是否出现过就直接用 intbool 的哈希表即可</p>
<h4 id="e"><a href="#e" class="headerlink" title="e."></a>e.</h4><p>非常有意思的一道题，其实在面对这种题的时候我一般都是很手足无措的，听完讲解后觉得可以这么想</p>
<p>对于这种经过操作构造目标，求操作次数的题，我们可以先关注结论，即预期的目标，再反推是怎么得来的，一般这种问题中秋最小操作次数都跟模拟无关，而是我们需要从中找到规律然后贪心地解决</p>
<p>对于这个题，不管怎么操作，最终数组都会变成 a…aaab..bbbb 的形式，即前半部分变为若干个 a 后半部分变为若干个 b，前后部分数目相同，并且这两部分变成多少（即 ab 的值）是无所谓的，我们只需要关注操作次数最小</p>
<p>分开考虑，那么问题就变成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数轴上有n个数，在数轴上找到一个数，使得数轴上的所有数移到该点所需的步数最少</span><br></pre></td></tr></table></figure>

<p>即变成了 <strong>货仓选址问题</strong> 也就是中位数定理</p>
<p><strong>中位数定理：给定一个数组，每次操作加 1 或者减 1，将所有元素变成相同的最小操作次数则是将所有元素变成中位数即可。</strong></p>
<p>有一个特判是可能两边的中位数相等，只需要任意一边改变一下即可，我们可以枚举几种改变取最优（枚举的方法非常优美）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    int n; cin &gt;&gt; n;</span><br><span class="line">    int a[n];</span><br><span class="line">    for(int i = 0;i &lt; n;i ++) cin &gt;&gt; a[i];</span><br><span class="line">    sort(a,a + n);</span><br><span class="line">    int l1 = a[(n / 2) / 2];</span><br><span class="line">    int l2 = a[n/2 + (n / 2) / 2];</span><br><span class="line">    ll ans = 1e18;</span><br><span class="line">    for(auto xl : &#123;l1,l1 - 1&#125;)&#123;</span><br><span class="line">        for(auto xr : &#123;l2,l2 + 1&#125;)&#123;</span><br><span class="line">            if(xl == xr) continue;</span><br><span class="line">            ll res = 0 ;</span><br><span class="line">            for(int i = 0;i &lt; n / 2;i ++) &#123;</span><br><span class="line">                res += abs(a[i] - xl);</span><br><span class="line">                res += abs(a[n / 2 + i] - xr);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = min(ans,res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t; cin &gt;&gt;  t;</span><br><span class="line">    while(t --)&#123;</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="g"><a href="#g" class="headerlink" title="g."></a>g.</h4><p>很经典的一种数组操作，即对左右加一减一，这样操作的关键点在于不管操作多少次数组中所有数的和都是不会发生改变的</p>
<p>故而第一个判断能不能成为排列只需要判断这个数组的和跟排列的和相等于否即可，如果相等的话就可能变为排列，不相等的话就不能</p>
<p>至于如何计算最小操作次数，一开始想的是排序数组后算出每一个位置上跟期望值之间的差是多少，但实际上这样有负有正不能算出来最小操作次数，相反，只需要算期望差中的正数或者负数即可，因为每一次操作加一和减一都是成对出现的，故而只关注一边即能计算出最小操作次数。</p>
<p>同样的思路，不管正负计算每个位置上差值的绝对值，最后除以二也能得到最小操作次数</p>
<h4 id="h"><a href="#h" class="headerlink" title="h."></a>h.</h4><p>其实是一个贪心问题，放置每一个数都需要选择一个区间，为了能够完全地构造，我们需要尽可能地在每次选择的时候都让剩余的区间能够放的数更多，例如现在能放 2 的区间有[2,7]和[2,4]那么最优的选择就是放在[2,4],因为另一个区间可以放的数字更多</p>
<p>那么问题就转化为了，首先选择所有可以放置的区间（左边界），然后按照右边界排序（最优选择），故而对于区间的排序应该以左边界为第一关键字，以右边界为第二关键字。</p>
<p>怎么做到每次选择都可以最优呢，就可以用优先队列（一个小根堆）按顺序储存完每一个区间，每次拿出再弹出即可</p>
<p>注意在优先队列里重载运算符（这道题你让我写得好苦啊！）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef pair&lt;int, int&gt; pp;</span><br><span class="line"></span><br><span class="line">//重载运算符使存放区间的vec按照左边界排好序</span><br><span class="line">struct node&#123;</span><br><span class="line">    pp fan;</span><br><span class="line">    int pos;</span><br><span class="line">    bool operator&lt;(const node &amp;a)&#123;</span><br><span class="line">        return fan.first &lt; a.fan.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//重载优先队列的比较器</span><br><span class="line">struct compare&#123;</span><br><span class="line">    bool operator()(pp a,pp b)&#123;</span><br><span class="line">        return a.first &gt; b.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;node&gt;a(n + 1);</span><br><span class="line">    vector&lt;int&gt; ans(n + 1, -1);</span><br><span class="line">    priority_queue&lt;pp, vector&lt;pp&gt;, compare&gt; b; //贪心，我们需要找到右区间最小的</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        int l,r; cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        a[i].fan = &#123;l,r&#125;;</span><br><span class="line">        a[i].pos = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a.begin(),a.end());</span><br><span class="line">    int cnt = 1;</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++)&#123;//从1到n开始放数</span><br><span class="line">        while(cnt &lt;= n &amp;&amp; a[cnt].fan.first &lt;= i) &#123; //左区间小于当前数就把这些区间放进去</span><br><span class="line">            b.push(&#123;a[cnt].fan.second,a[cnt].pos&#125;);</span><br><span class="line">            cnt ++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(b.empty()) &#123;</span><br><span class="line">            cout &lt;&lt; -1 &lt;&lt; endl;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        auto t = b.top(); b.pop();</span><br><span class="line">        if(t.first &lt; i) &#123;</span><br><span class="line">            cout &lt;&lt; - 1 &lt;&lt; endl;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            ans[t.second] = i; //把数字放到对应的位置上</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++) cout &lt;&lt; ans[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="18-牛客寒假训练营-2"><a href="#18-牛客寒假训练营-2" class="headerlink" title="18.牛客寒假训练营 2"></a>18.牛客寒假训练营 2</h3><h4 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h4><p>由于回老家的原因这场比赛没打，没想到这场比赛不会做的题还挺多的，感觉最大的问题还是确实不太会做字符串问题的题了。特别是关于子串之类的问题。</p>
<h4 id="a-1"><a href="#a-1" class="headerlink" title="a."></a>a.</h4><p>直接判断输入的数字里有没有不能出现的数字即可，注意如果是多组数据的话记得不能提前终止</p>
<h4 id="b-1"><a href="#b-1" class="headerlink" title="b."></a>b.</h4><p>一开始想偏了想到了二分，但后来发现，想要让它至少比一般的碗都小，直接找到中位数，然后中位数减 1 不就恰好能够满足条件吗，所以做题还是多从思维入手</p>
<h4 id="c"><a href="#c" class="headerlink" title="c."></a>c.</h4><h4 id="d-1"><a href="#d-1" class="headerlink" title="d."></a>d.</h4><p>一道字符串的贪心和构造问题，关键在于如何</p>
<h2 id="蓝桥杯真题补题"><a href="#蓝桥杯真题补题" class="headerlink" title="蓝桥杯真题补题"></a>蓝桥杯真题补题</h2><h3 id="十四届蓝桥杯-cb-省赛"><a href="#十四届蓝桥杯-cb-省赛" class="headerlink" title="十四届蓝桥杯 cb 省赛"></a>十四届蓝桥杯 cb 省赛</h3><h4 id="a-日期统计"><a href="#a-日期统计" class="headerlink" title="a 日期统计"></a>a 日期统计</h4><p>1.想法方面 直接八重循环去遍历所有的八位字符串显然是不现实的 所以应该先处理出所有的 2023 年的日期 然后对于每个日期都在原字符串中进行匹配</p>
<p>启发是当一个方法行不通的时候可以换一个角度想 比如这里就把从原字符串中找字符串变成了从原字符串中匹配字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int month[] = &#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;;</span><br><span class="line">char temp[8];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int ans = 0;</span><br><span class="line">	string s = &quot;5686916124919823647759503875815861830379270588570991944686338516346707827689565614010094809128502533&quot;;</span><br><span class="line">	for(int i = 1;i &lt;= 12;i ++) &#123;</span><br><span class="line">		for(int j = 1;j &lt;= month[i];j ++) &#123;</span><br><span class="line">			sprintf(temp,&quot;2023%02d%02d&quot;,i,j);</span><br><span class="line">			int id = 0;</span><br><span class="line">			for(int k = 0;k &lt; 100;k ++)&#123;</span><br><span class="line">				if(s[k] == temp[id]) &#123;</span><br><span class="line">					id ++;</span><br><span class="line">				&#125;</span><br><span class="line">				if(id == 8) &#123;</span><br><span class="line">					ans ++;</span><br><span class="line">					break; （因为如果日期一样的话只算作一个）</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="b01-串的熵"><a href="#b01-串的熵" class="headerlink" title="b01 串的熵"></a>b01 串的熵</h4><p>这道题还是想多了的缘故 其实对于填空题不用进行太复杂的数学推理论证 这里也是直接考虑暴力枚举即可 让计算机来完成大部分的运算量</p>
<p>可以做的一些优化是 由于 0 的数量要小于 1 的数量 所以 0 的数量肯定是要小于 n &#x2F; 2 的</p>
<p>还需要注意的是对于浮点数 在判断相等的时候不能直接用等于 要考虑精度的问题</p>
<p>(精度可以先默认成 0.01 如果这时输出的答案不止一个的话就可以考虑再提高精度)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	double ans = 11625907.5798;</span><br><span class="line">	double n = 23333333;</span><br><span class="line">	for(int i = 0;i &lt; n / 2;i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		double shang = 0;</span><br><span class="line">		shang -= i * (i / n) * log2(i / n) + (n - i) * ((n - i) / n ) * log2((n - i) / n);</span><br><span class="line">		if(abs(shang - ans) &lt; 0.01 ) &#123;</span><br><span class="line">			cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="c-冶炼金属"><a href="#c-冶炼金属" class="headerlink" title="c 冶炼金属"></a>c 冶炼金属</h4><p>其实是一个直接推导公式的题 关键是要根据题目推导出 v 的范围</p>
<p>1.根据题目有以下公式推导： 因为<br><strong>⌊𝐴&#x2F;𝑉⌋&#x3D;𝐵 有 𝐵&lt;&#x3D;𝐴&#x2F;𝑉&lt;𝐵+1</strong><br>取倒数有<br><strong>1&#x2F;(𝐵+1)&lt;𝑉&#x2F;𝐴&lt;&#x3D;1&#x2F;𝐵</strong><br>两边同时乘 𝐴:</p>
<p><strong>𝐴&#x2F;(𝐵+1)&lt;𝑉&lt;&#x3D;𝐴&#x2F;𝐵</strong> 2.这样，区间左边取<br><strong>𝐴&#x2F;(𝐵+1)+1 最大值</strong>（这里要加 1 是因为其实是取不到原数的，取到的应该是下一个整数），右边取 <strong>𝐴&#x2F;𝐵 最小值即可</strong></p>
<p>最后把每一个数据中 v 的范围取一个交集即可以满足所有的条件</p>
<p>注意在数轴上画一下区间取交集是怎么取的 应该是</p>
<p><strong>左边界取较大 右边界取较小</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int mn = 1; int mx = 1e9;</span><br><span class="line">	int n; cin &gt;&gt; n;</span><br><span class="line">	for(int i = 0;i &lt; n;i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		int a,b; cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		mn = max(mn,a / (b + 1) + 1);</span><br><span class="line">		mx = min(mx,a / b);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; mn &lt;&lt; &quot; &quot; &lt;&lt; mx;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反思一下可能后面看到这样的上下取整问题都可以这样推导一下下</p>
<h4 id="d-飞机降落"><a href="#d-飞机降落" class="headerlink" title="d 飞机降落"></a>d 飞机降落</h4><p>引发一个大问题 就是什么时候用 dfs 除了路径 迷宫这些问题外其实很少想到用 dfs</p>
<p>那什么时候可以用到 DFS 呢？总结来说，当问题需要枚举所有可能的解，并且问题的结构适合逐步构建解的时候，可以考虑 DFS。例如排列问题、组合问题、路径问题等。在这种情况下，DFS 通过递归或者栈的方式，尝试每一种可能的选择，并回溯到上一步尝试其他选择，直到找到解或者遍历完所有可能性。即如果我们想要枚举一下答案的某一种情况然后对于每一种情况判断其合法性的话我们就可以用 dfs</p>
<p>然后分析问题，其实是问我们有没有一种排列方式能够使得每一架飞机都能够成功平安降落 数据量要比较小 所以我们用 dfs 来枚举每一种排列方式 看看有没有合法的就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 15;</span><br><span class="line"></span><br><span class="line">struct plane&#123;</span><br><span class="line">  int t; int d; int l;</span><br><span class="line">&#125;p[N];</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">bool vis[N];</span><br><span class="line">bool flag;</span><br><span class="line"></span><br><span class="line">void  dfs(int u,int last)</span><br><span class="line">&#123;</span><br><span class="line">  if(u == n) &#123;</span><br><span class="line">    flag = true;</span><br><span class="line">    return ;</span><br><span class="line">  &#125;</span><br><span class="line">  for(int i = 0;i &lt; n;i ++) //开始遍历排列</span><br><span class="line">  &#123;</span><br><span class="line">    if(!vis[i] &amp;&amp; p[i].t + p[i].d &gt;= last)</span><br><span class="line">    &#123;</span><br><span class="line">      vis[i] = true;</span><br><span class="line">      dfs(u + 1,max(p[i].t,last) + p[i].l);</span><br><span class="line">      vis[i] = false; // 回溯</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int t; cin &gt;&gt; t;</span><br><span class="line">  while(t --)</span><br><span class="line">  &#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for(int i = 0;i &lt; n;i ++) cin &gt;&gt; p[i].t &gt;&gt; p[i].d &gt;&gt; p[i].l;</span><br><span class="line">    flag = false; dfs(0,0);</span><br><span class="line">    if(!flag) cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;</span><br><span class="line">    else cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="e-接龙数列"><a href="#e-接龙数列" class="headerlink" title="e 接龙数列"></a>e 接龙数列</h4><p>其实这是一道 dp 的题 我暂时还不会 就只把暴力 dfs 放在这里吧</p>
<p>但是其实这里要想一下为什么会想到 dfs</p>
<p>该题要求的是最少从中删除多少个数 可以使剩下的序列是接龙序列 但显然考虑删除是很难有解法的 所以不如换个思路想 这个问题的另一种说法不就是 <strong>最多能剩下几个数可以使得当前剩下的序列是一个接龙序列</strong> 也就是说 我们只需要 <strong>枚举出所有可能的接龙序列</strong> 然后取取这些接龙序列长度的最大值 l 那么最少需要删除的数字就是 n - l 了！</p>
<p>那么怎么枚举这些序列呢 可以作这样的思考</p>
<p>从某一个数开始 每一个数都面临着选或者不选的情况 所以最终可以形成这样一颗二叉树</p>
<p><img src="/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0.assets/image-20250305195433802.png" alt="image-20250305195433802"></p>
<p>现在就能看出来 想求出最终的排列其实就是一个树的遍历 也就是一个 dfs</p>
<p>当然 直接这样 dfs 的时间复杂度 是 <strong>2 ^ n</strong> 显然能过的测试点太少了 所以我们应该在搜索过程中再进行一个剪枝，即我们每一步都只需要符合题意的解 即后一位的首位为前一位的末位</p>
<p>最终这样就能过大概百分之五十的测试点 其实也应该比较够用了吧</p>
<h4 id="f-岛屿个数"><a href="#f-岛屿个数" class="headerlink" title="f 岛屿个数"></a>f 岛屿个数</h4><p>似乎是个 dfs + bfs 的题 有点太难了 看不懂思密达</p>
<h4 id="g-子串简写"><a href="#g-子串简写" class="headerlink" title="g 子串简写"></a>g 子串简写</h4><p>暴力拿了 14 分 后面运行超时了 其实仔细想一下优化还是挺简单的 用一个前缀和储存一下就好了</p>
<p>这道题的意思就是在字符串中找到一个长度至少为 k 的以 c1 开头 c2 结尾的子串</p>
<p>考虑优化我们可以先用前缀和记录每个位置和之前包含 c1 的数量 然后去遍历字符串找到为 c2 的点 如果距离大于 k 的话那么就将结果++</p>
<p><strong>记得开 long long</strong> 不然会错一个测试点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define int long long</span><br><span class="line">const int N = 5e5 + 10;</span><br><span class="line">int c[N];</span><br><span class="line">int cnt = 0;</span><br><span class="line"></span><br><span class="line">signed main()</span><br><span class="line">&#123;</span><br><span class="line">    int k; string s; char a,b; cin &gt;&gt; k &gt;&gt; s &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    int n = s.length();</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++) c[i] += c[i - 1] + (s[i - 1] == a ? 1 : 0);</span><br><span class="line">    for(int i = k;i &lt;= n;i ++) if(s[i - 1] == b) cnt += c[i - k + 1];</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但其实还在题解区看到了一个更妙妙的解法即用一个类似滑动窗口的思想 固定好子串的长度至少为 k</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int K;</span><br><span class="line">long long ans = 0, c1_sum = 0;</span><br><span class="line">string S;</span><br><span class="line">char c1, c2;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; K &gt;&gt; S &gt;&gt; c1 &gt;&gt; c2;</span><br><span class="line">    for (int i = K-1, j = 0; i &lt; S.length(); i++, j++) &#123; //注意循环的初始条件 这样可以使得子串的长度至少为k</span><br><span class="line">        if (S[j] == c1) c1_sum++;       // 记录当前起始位置j是否为c1 子串的起点</span><br><span class="line">        if (S[i] == c2) ans += c1_sum;  // 若i是c2，累加合法子串数 子串的终点</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于子串的起点是从左往右遍历的 所以当 if (S[i] &#x3D;&#x3D; c2) ans +&#x3D; c1_sum; 的时候 加上的 c1_sum 即子串可能的起点数目是 j 往前的所有点 所以保证了子串的长度 &gt;&#x3D; k</p>
<p>妙啊！</p>
<h4 id="h-整数删除"><a href="#h-整数删除" class="headerlink" title="h 整数删除"></a>h 整数删除</h4><p>这道题的难度其实在于每次动态地判断最小的整数 其实现在看来可以很快地想到用小根堆来实现</p>
<h2 id="天梯赛选拔模拟"><a href="#天梯赛选拔模拟" class="headerlink" title="天梯赛选拔模拟"></a>天梯赛选拔模拟</h2><h3 id="静静的推荐"><a href="#静静的推荐" class="headerlink" title="静静的推荐"></a>静静的推荐</h3><p><img src="/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0.assets/image-20250310162919117.png" alt="image-20250310162919117"></p>
<p>关键只在于对题意的理解</p>
<p>原则上一批推荐名单应该是严格单调递增（即不能有相同的） 但如果学生的分数一样但是 pat 成绩达标的话就不受影响 也可以加入名单</p>
<p>那么问题就转化成了这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、如果学生天梯赛分数不足175 不考虑</span><br><span class="line">2、如果学生天梯赛分数不小于175但是pat分数不够的话那么就应该遵循原则 即每个批次出现一次 最多只能出现k次（k个批次）</span><br><span class="line">3、日光学生天梯赛分数不小于175同时pat分数也够的话那么就可以无视原则 随便出现了 （因为批次内没有人数要求）</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 300;</span><br><span class="line">int ci[N];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n,k,s; cin &gt;&gt; n &gt;&gt; k &gt;&gt; s;</span><br><span class="line">	int ans = 0;</span><br><span class="line">	for(int i = 0;i &lt; n;i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		int t,p; cin &gt;&gt; t &gt;&gt; p;</span><br><span class="line"></span><br><span class="line">		if(t &gt;= 175)</span><br><span class="line">		&#123;</span><br><span class="line">			if(p &gt;= s) ans ++;</span><br><span class="line">			else  if(ci[t] &lt; k) &#123;</span><br><span class="line">					ci[t] ++;</span><br><span class="line">					ans ++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="病毒溯源"><a href="#病毒溯源" class="headerlink" title="病毒溯源"></a>病毒溯源</h3><p><img src="/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0.assets/image-20250310172705840.png" alt="image-20250310172705840"></p>
<p>理解一下题意其实意思就是在一颗有根的树里找到最长路径 如果路径一样长的话就输出编号较小的那条路径</p>
<p>应该从这个题里学到的知识点有 ： 单链表存图 根节点的找法 有根树的遍历</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 110;</span><br><span class="line">int n;</span><br><span class="line">int h[N],e[N],ne[N],idx;</span><br><span class="line">int son[N];</span><br><span class="line">bool st[N];</span><br><span class="line"></span><br><span class="line">void add(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">	e[idx] = b,ne[idx] = h[a],h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int dfs(int u)</span><br><span class="line">&#123;</span><br><span class="line">	son[u] = -1;</span><br><span class="line">	int len = 0;</span><br><span class="line">	for(int i = h[u];i != - 1;i = ne[i])</span><br><span class="line">	&#123;</span><br><span class="line">		int j = e[i];</span><br><span class="line">		int d = dfs(j);</span><br><span class="line">		if(len &lt; d) len = d,son[u] = j;</span><br><span class="line">		else if(len == d) son[u] = min(son[u],j);</span><br><span class="line">	&#125;</span><br><span class="line">	return len + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	memset(h,-1,sizeof h);</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	for(int i = 0;i &lt; n;i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		int k; cin &gt;&gt; k;</span><br><span class="line">		if(k == 0) continue;</span><br><span class="line">		for(int j = 0;j &lt; k;j ++)</span><br><span class="line">		&#123;</span><br><span class="line">			int x; cin &gt;&gt; x;</span><br><span class="line">			add(i,x);</span><br><span class="line">			st[x] = true;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int root = 0;</span><br><span class="line"></span><br><span class="line">	while(st[root]) root ++;</span><br><span class="line"></span><br><span class="line">	int mx = dfs(root);</span><br><span class="line">	cout &lt;&lt; mx &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; root ;</span><br><span class="line"></span><br><span class="line">	while(son[root] != -1)</span><br><span class="line">	&#123;</span><br><span class="line">		root = son[root];</span><br><span class="line">		cout &lt;&lt; &quot; &quot; &lt;&lt; root;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="清点代码"><a href="#清点代码" class="headerlink" title="清点代码"></a>清点代码</h3><p><img src="/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0.assets/image-20250310194915375.png" alt="image-20250310194915375"></p>
<p>stl 大模拟 需要注意的点可能是不要写昏头了</p>
<p>还有就是需要统计出现数量的时候可以用的几种数据结构 ： set map 哈希</p>
<p>但由于这里既要输出出现次数又要输出所有输出 所以用 map 最方便</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef pair&lt;int,vector&lt;int&gt;&gt; pp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">map&lt;vector&lt;int&gt;,int&gt; cnt;</span><br><span class="line">vector&lt;pp&gt; ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for(int i = 0;i &lt; n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;int&gt; temp;</span><br><span class="line">        for(int j = 0;j &lt; m;j ++) &#123;</span><br><span class="line">            int x; cin &gt;&gt; x;</span><br><span class="line">            temp.push_back(x);</span><br><span class="line">        &#125;</span><br><span class="line">        cnt[temp] ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(auto p : cnt) ans.push_back(&#123;-p.second,p.first&#125;); // 注意，排序是默认从小到大排序的 但我们需要按照出现次数从大到小排  所以我们直接放相反数进去 最后取相反数的话就能满足题意了</span><br><span class="line">    sort(ans.begin(),ans.end()); //pair的排序是默认先排first 再排 second 同时vector的排序是默认字典序的  所以用上面两个特性就很方便地按照题目要求输出了</span><br><span class="line">    cout &lt;&lt; cnt.size() &lt;&lt; endl;</span><br><span class="line">    for(auto p : ans)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; -p.first ;</span><br><span class="line">        for(auto x : p.second)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot; &quot; &lt;&lt; x;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="哲哲打游戏"><a href="#哲哲打游戏" class="headerlink" title="哲哲打游戏"></a>哲哲打游戏</h3><p><img src="/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0.assets/image-20250310205518112.png" alt="image-20250310205518112"></p>
<p>还是一道大模拟 比较恶心的一点在于所有的起点都是从 1 开始的 所以需要处理好索引问题防止出现越界的情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 110;</span><br><span class="line">const int M = 1e5 + 10;</span><br><span class="line">int cun[N];</span><br><span class="line">vector&lt;int&gt; a[M];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n,m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	for(int i = 1;i &lt;= n;i ++) //这里从1开始计数保证了是从1开始的</span><br><span class="line">	&#123;</span><br><span class="line">		int k; cin &gt;&gt; k;</span><br><span class="line">		for(int j = 1;j &lt;= k;j ++)</span><br><span class="line">		&#123;</span><br><span class="line">			int x; cin &gt;&gt; x;</span><br><span class="line">			a[i].push_back(x); //注意这里直接push_back的话元素是从0的位置开始的</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	int now = 1; //从1开始</span><br><span class="line">	for(int i = 1;i &lt;= m;i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		int num; cin &gt;&gt; num;</span><br><span class="line">		if(num == 0)</span><br><span class="line">		&#123;</span><br><span class="line">			int j; cin &gt;&gt; j;</span><br><span class="line">			now = a[now][j - 1]; //前面解释了 二维是从0开始的 所以这里需要-1</span><br><span class="line">		&#125;</span><br><span class="line">		else if(num == 1)</span><br><span class="line">		&#123;</span><br><span class="line">			int j; cin &gt;&gt; j;</span><br><span class="line">			cun[j] = now;</span><br><span class="line">			cout &lt;&lt; now &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(num == 2)</span><br><span class="line">		&#123;</span><br><span class="line">			int j; cin &gt;&gt; j;</span><br><span class="line">			now = cun[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; now &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完全二叉树的层序遍历"><a href="#完全二叉树的层序遍历" class="headerlink" title="完全二叉树的层序遍历"></a>完全二叉树的层序遍历</h3><p><img src="/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0.assets/image-20250310211442315.png" alt="image-20250310211442315"></p>
<p>之前找二叉树的几种遍历的时候其实自己用的方法就是递归吧 所以这里也应该想到要使用递归</p>
<p>特殊之处在于这里的输入是放在函数里面进行的 因为每次我们都只输入一下根</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">int tree[40];</span><br><span class="line"></span><br><span class="line">void create(int u)</span><br><span class="line">&#123;</span><br><span class="line">	if(u &lt;= n)&#123;</span><br><span class="line">		create(2 * u);</span><br><span class="line">		create(2 * u + 1);</span><br><span class="line">		cin &gt;&gt; tree[u];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	create(1);</span><br><span class="line">	for(int i = 1;i &lt;= n;i ++) cout &lt;&lt; tree[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">	cout &lt;&lt; tree[n] &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="杂题（具体代码都在杂题文件夹里）"><a href="#杂题（具体代码都在杂题文件夹里）" class="headerlink" title="杂题（具体代码都在杂题文件夹里）"></a>杂题（具体代码都在杂题文件夹里）</h2><h3 id="k-倍区间"><a href="#k-倍区间" class="headerlink" title="k 倍区间"></a>k 倍区间</h3><p><img src="/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0.assets/image-20250314083741933.png" alt="image-20250314083741933"></p>
<p><strong>前缀和+数学</strong></p>
<p>如果用前缀和直接暴力遍历的话 只能过两个测试点 但是这种做法也想不到其他的优化了 所以应该关注其他的性质</p>
<p><strong>数学性质推导</strong></p>
<p>假设一个数列为 a1,a2,a3,….,an，一个小的前缀区间 s1 为 a1,a2,a3,….,ap,还有一个大的前缀区间 s2 为 a1,a2,a3,…,a(p+m)，p,p+m&lt;n，</p>
<p>当我们对 s1、s2 的和分别取模，得到</p>
<p><strong>(a1+a2+a3+…+ap)%k 和(a1+a2+a3+…+ap+m)%k</strong>，</p>
<p>当这两个值相等的时候，我们则可以列出这个等式：</p>
<p><strong>(a1+a2+a3+…+ap)%k-(a1+a2+a3+…+ap+m)%k&#x3D;0</strong><code>，</code></p>
<p><strong>根据取模也具有分配律</strong>可得到，</p>
<p><strong>(a1+a2+a3+…+ap-a1-a2-a3-…-ap+m)%k&#x3D;0</strong></p>
<p>因此可以推出结论，<strong>s2-s1 得出的区间必定为 k 倍区间。</strong></p>
<p>那么我们可以记录每一个区间和对 k 取模的值 储存一下这些值的数量 即取模值相等的区间 在这些区间中任选两个相减的区间必定为 k 倍区间</p>
<p>所以问题就转换为了从 x 个取模值相等的区间中任选两个（组合数）</p>
<p>那 n 个中取任何两个区间都可以组成 k 倍区间，问有多少 k 倍区间，就转换成 n 个区间取两个的情况有多少个，就是 Cn2&#x3D;n*(n-1)&#x2F;2，所以对于每个%k 值相等的区间都添加一次组合就可以算出总共有多少 k 倍区间了</p>
<h3 id="分巧克力"><a href="#分巧克力" class="headerlink" title="分巧克力"></a>分巧克力</h3><p><img src="/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0.assets/image-20250314085801444.png" alt="image-20250314085801444"></p>
<p><strong>二分</strong></p>
<p>看到最值先想一下二分 然后想一下是否满足二分条件 如果二分边长的话<strong>sum +&#x3D; (h &#x2F; u) * (w &#x2F; u);</strong> 需要 sum &#x3D;&#x3D; k</p>
<p>k 越大 sum 越小 也就是说这个表达式是满足单调性的 所以可以二分</p>
<h3 id="玩三国杀"><a href="#玩三国杀" class="headerlink" title="玩三国杀"></a>玩三国杀</h3><p><img src="/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0.assets/image-20250314090738027.png" alt="image-20250314090738027"></p>
<p><strong>贪心</strong></p>
<p>关键在于理解题意 需要所有的事都确定发生与否 问最多发生多少个事件能使得某一国胜利 所以关键问题在于怎么去考虑每件事发生或没有发生的影响</p>
<p>如果单纯记录发生或者没有发生的状态 即写一个 dfs 暴搜 每个事件都有发生或没有发生两种情况 时间复杂度会是 2^n 次方 只能过两个测试点</p>
<p>所以不能暴力地去考虑状态 换个思路 我们只需要关注每件事情发生的贡献即可</p>
<p>以魏国获胜为例 即 X &gt; Y + Z 那么每次事件发生的贡献即为 <strong>ai - bi - ci</strong> 如果这个贡献大于 0 则是有利的 应该让它发生否则就不发生最好</p>
<p>对于每一个国家用 sum 来记录贡献和 如果 sum 还大于 0 则说明该国家此时还可以获胜</p>
<p>想要求得最多发生多少 可以算出三个国家分别获胜的最多事件 最后取一个 max 就行</p>
<h2 id="天梯赛选拔"><a href="#天梯赛选拔" class="headerlink" title="天梯赛选拔"></a>天梯赛选拔</h2><h3 id="比赛链接"><a href="#比赛链接" class="headerlink" title="比赛链接"></a>比赛链接</h3><p><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/105044">西南石油大学天梯赛选拔赛<em>ACM&#x2F;NOI&#x2F;CSP&#x2F;CCPC&#x2F;ICPC 算法编程高难度练习赛</em>牛客竞赛 OJ</a></p>
<h3 id="L1-A-进制"><a href="#L1-A-进制" class="headerlink" title="L1 - A 进制"></a>L1 - A 进制</h3><p>进制转化题 无限像豪豪历险记 想要任意转换只需要把大于 10 的部分用字母记录一下即可 用栈来储存余数</p>
<p><img src="/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0.assets/image-20250316111455471.png" alt="image-20250316111455471"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define int long long</span><br><span class="line"></span><br><span class="line">signed main()</span><br><span class="line">&#123;</span><br><span class="line">    int x,k; cin &gt;&gt; x &gt;&gt; k;</span><br><span class="line">    char c[17] = &#123;&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;&#125;;</span><br><span class="line">    stack&lt;int&gt; m;</span><br><span class="line"></span><br><span class="line">    if(x == 0) &#123;</span><br><span class="line">        cout &lt;&lt; 0 &lt;&lt; endl;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while(x)</span><br><span class="line">    &#123;</span><br><span class="line">        m.push(x % k);</span><br><span class="line">        x /= k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while(!m.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        int n = m.top();</span><br><span class="line">        cout &lt;&lt; c[n];</span><br><span class="line">        m.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="L1-麻将"><a href="#L1-麻将" class="headerlink" title="L1-麻将"></a>L1-麻将</h3><p>除了能跟着题意写大模拟之外 现在应该更多地考虑优化简化代码 赛时写的代码太冗长了 容易出错 debug 还很麻烦</p>
<p>注意写的时候一定一定要冷静 然后就是每次都需要查找值 所以应该用数组记录 因为只需要找到胜者 所以直接用 max 记录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a[33];</span><br><span class="line">	for(int i = 1;i &lt;= 32;i ++) cin &gt;&gt; a[i];</span><br><span class="line">	int t = a[1];</span><br><span class="line">	for(int i = 1;i &lt;= 32;i += 4) sort(a + i,a + i + 4);</span><br><span class="line">	if(t == a[1] || a[2] == t) &#123;</span><br><span class="line">		cout &lt;&lt; 17 &lt;&lt; endl;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int b[9];</span><br><span class="line">	b[1] = max(a[4],a[7]);</span><br><span class="line">	b[2] = max(a[12],a[15]);</span><br><span class="line">	b[3] = max(a[20],a[23]);</span><br><span class="line">	b[4] = max(a[28],a[31]);</span><br><span class="line">	b[5] = max(a[8],a[3]);</span><br><span class="line">	b[6] = max(a[16],a[11]);</span><br><span class="line">	b[7] = max(a[24],a[19]);</span><br><span class="line">	b[8] = max(a[32],a[27]);</span><br><span class="line"></span><br><span class="line">	bool flag = false;</span><br><span class="line">	for(int i = 1;i &lt;= 8;i ++)&#123;</span><br><span class="line">		if(t == b[i]) &#123;</span><br><span class="line">			flag = true;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if(!flag) &#123;</span><br><span class="line">		cout &lt;&lt; 9 &lt;&lt; endl;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	flag = false;</span><br><span class="line"></span><br><span class="line">	int c[5];</span><br><span class="line">	c[1] = max(b[1],b[2]);</span><br><span class="line">	c[2] = max(b[3],b[4]);</span><br><span class="line">	c[3] = max(b[5],b[6]);</span><br><span class="line">	c[4] = max(b[7],b[8]);</span><br><span class="line"></span><br><span class="line">	for(int i = 1;i &lt;= 4;i ++)&#123;</span><br><span class="line">		if(t == c[i]) &#123;</span><br><span class="line">			flag = true;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if(!flag) &#123;</span><br><span class="line">		cout &lt;&lt; 5 &lt;&lt; endl;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int c1,c2;</span><br><span class="line">	c1 = max(c[1],c[2]); c2 = max(c[3],c[4]);</span><br><span class="line"></span><br><span class="line">	if(t != c1 &amp;&amp; t != c2) &#123;</span><br><span class="line">		cout &lt;&lt; 3 &lt;&lt; endl;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if(c1 &gt; c2) &#123;</span><br><span class="line">		if(t == c1) cout &lt;&lt; 1 &lt;&lt; endl;</span><br><span class="line">		else cout &lt;&lt; 2 &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	else if(c2 &gt; c1)&#123;</span><br><span class="line">		if(t == c2) cout &lt;&lt; 1 &lt;&lt; endl;</span><br><span class="line">		else cout &lt;&lt; 2 &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="L1-位运算"><a href="#L1-位运算" class="headerlink" title="L1-位运算"></a>L1-位运算</h3><p>关于位运算的题目 一个小要点是位运算没有进位 所以应该按位考虑 每一位的计算和贡献都是独立的</p>
<p>如果题目的数据范围是 2 的多少次方就应该考虑转换为 2 进制用位运算解决问题</p>
<p>位运算题目的重点是对题目给出式子的分析和推导</p>
<p>对于该题</p>
<p><img src="/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0.assets/image-20250317111310192.png" alt="image-20250317111310192"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,k; cin &gt;&gt; n &gt;&gt; k; <span class="type">int</span> x = <span class="number">2</span>;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数字转化为2进制表示</span></span><br><span class="line">	<span class="keyword">while</span>(n)&#123;</span><br><span class="line">		s.<span class="built_in">push_back</span>(n &amp; <span class="number">1</span>);</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(s.<span class="built_in">size</span>() &lt; k)&#123;</span><br><span class="line">		s.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每一位的可能组合之间应该相乘</span></span><br><span class="line">	<span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; s.<span class="built_in">size</span>();i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(s[i] == <span class="number">0</span>) ans *= <span class="number">4</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="number">1</span>) ans *= <span class="number">12</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t --)&#123;</span><br><span class="line">		<span class="built_in">solve</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="L2-查无此号"><a href="#L2-查无此号" class="headerlink" title="L2-查无此号"></a>L2-查无此号</h3><p>一道字符串加数据结构大模拟 需要注意两个点</p>
<p><strong>1、耐心读题 把题读懂先</strong></p>
<p>邮箱地址由邮箱用户名和域名构成 只要邮箱用户名相同 就能登录相同的 dd 账号</p>
<p>所以 由邮箱用户名和账号名来确定一个账号</p>
<p>只需要判断这个账号的登录次数即可</p>
<p><strong>2.字符串函数和 stl 的使用</strong></p>
<p>由于就连昵称中都有可能出现空格 所以只能把邮箱 昵称 ip 地址整体<strong>getline</strong>进来</p>
<p>用 <strong>substr</strong> 来分割出我们所需要的部分</p>
<p>我们用 pair 来储存一个账号 用 map 来记录 ip 登录的种数</p>
<p>这里有一个之前没想到的问题是如果用 pair int 的 map 来记录的话 需要再给 ip 开一个 string bool 的 map 但是这样就没法把 ip 跟账号对应出来 会导致出错 所以我们应该开一个 pair set<string>的 map 来记录对应账号的 ip 情况 根据 set 的大小来判断登录次数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef pair&lt;string,string&gt; pp;</span><br><span class="line"></span><br><span class="line">map&lt;pp, set&lt;string&gt; &gt; cnt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(nullptr);</span><br><span class="line">    cout.tie(nullptr);</span><br><span class="line">    int n,k; cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    string ch; getline(cin,ch);</span><br><span class="line">    for(int i = 0;i &lt; n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        string s; getline(cin,s);</span><br><span class="line">        string mail = s.substr(0,s.find(&#x27;@&#x27;));</span><br><span class="line">        string ip = s.substr(s.size() - 15);</span><br><span class="line">        string name = s.substr(s.find(&quot;.com&quot;) + 5);</span><br><span class="line">        name = name.substr(0,name.size() - 15);</span><br><span class="line">        set&lt;string&gt; &amp;temp = cnt[&#123;mail, name&#125;];  // 注意这里应该直接取地址 这样的话 对temp的改变会直接改变map的键值 如果重新定义一个set的话每次清空再插入就会超时</span><br><span class="line">        int ts = temp.size();</span><br><span class="line">        if(temp.find(ip) == temp.end())&#123;</span><br><span class="line">            temp.insert(ip);</span><br><span class="line">            if(ts + 1 &lt; k) &#123;</span><br><span class="line">                cout &lt;&lt; &quot;zheng chang deng lu&quot; &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(ts + 1 == k) &#123;</span><br><span class="line">                cout &lt;&lt; &quot;zui hou yi ci la!!! xiao xin yi dian!!!&quot; &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(ts + 1 == k + 1) &#123;</span><br><span class="line">                cout &lt;&lt; &quot;hahaha bei feng hao le ba!!!&quot; &lt;&lt; endl;</span><br><span class="line">                temp.insert(&quot;123456&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else cout &lt;&lt; &quot;cha wu ci hao&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            if(ts &lt;= k) cout &lt;&lt; &quot;zheng chang deng lu&quot; &lt;&lt; endl;</span><br><span class="line">            else cout &lt;&lt; &quot;cha wu ci hao&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="天梯赛准备"><a href="#天梯赛准备" class="headerlink" title="天梯赛准备"></a>天梯赛准备</h2><h3 id="敲笨钟"><a href="#敲笨钟" class="headerlink" title="敲笨钟"></a>敲笨钟</h3><p><img src="/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0.assets/image-20250317205457959.png" alt="image-20250317205457959"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n; cin &gt;&gt; n;</span><br><span class="line">    string ch; getline(cin,ch);  // 在用getline前 吸收掉cin产生的换行符</span><br><span class="line">    while(n --)&#123;</span><br><span class="line">        string s;  getline(cin,s);</span><br><span class="line">        string s2 = s.substr(s.find(&#x27;,&#x27;) + 1);</span><br><span class="line">        string s1 = s.substr(0,s.size() - s2.size() - 1);</span><br><span class="line">        string wei1 = (s1.size() &gt;= 3) ? s1.substr(s1.size() - 3, 3) : &quot;&quot;;</span><br><span class="line">        string wei2 = (s2.size() &gt;= 4) ? s2.substr(s2.size() - 4, 3) : &quot;&quot;;</span><br><span class="line">        //注意这里的判断条件 防止因为字符串长度不够造成越界访问 一开始就是这里没改导致了运行错误！！！</span><br><span class="line">        if(wei2 == &quot;ong&quot; &amp;&amp; wei1 == &quot;ong&quot;) &#123;</span><br><span class="line">            int cnt2 = 0;</span><br><span class="line">            int cnt0 = 0;</span><br><span class="line">            cout &lt;&lt; s1 &lt;&lt; &quot;,&quot;;</span><br><span class="line">            for(int i = s2.size() - 1;i &gt;= 0;i --)&#123;</span><br><span class="line">                cnt2 ++;</span><br><span class="line">                if(s2[i] == &#x27; &#x27;) cnt0 ++;</span><br><span class="line">                if(cnt0 == 3) break;</span><br><span class="line">            &#125;</span><br><span class="line">            //小知识点 当出现这种中间有空格的句子型的字符串的时候 可以用一个指针找空格出现的次数就可以达到分割单词的效果</span><br><span class="line">            s2.erase(s2.size() - cnt2);</span><br><span class="line">            cout &lt;&lt; s2 &lt;&lt; &quot; &quot; &lt;&lt; &quot;qiao ben zhong&quot; &lt;&lt; &quot;.&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        else cout &lt;&lt; &quot;Skipped&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里重温一下字符串中 substr 和 erase 和 find 函数的应用</p>
<p><strong>substr 函数 用于从原字符串中提取指定长度的子字符串</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string substr (size_t pos = 0, size_t len = npos) const;</span><br><span class="line">//应用时</span><br><span class="line">string s1;</span><br><span class="line">string s2 = s.substr(s.find(&#x27;,&#x27;) + 1);</span><br><span class="line">string s1 = s.substr(0,s.size() - s2.size() - 1);</span><br></pre></td></tr></table></figure>

<p>◦ pos：表示子字符串<strong>开始的位置</strong>，索引从 0 开始。<br>◦ len：表示子字符串的<strong>长度</strong>。若省略该参数，就会提取从 pos 开始直到字符串末尾的所有字符。</p>
<p><strong>erase 函数 用于在原字符串中删除指定长度的子字符串</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">erase(size_t pos = 0, size_t len = npos)</span><br><span class="line">// 应用时</span><br><span class="line">  s2.erase(s2.size() - cnt2);</span><br></pre></td></tr></table></figure>

<p>◦ pos：表示子字符串<strong>开始的位置</strong>，索引从 0 开始。<br>◦ len：表示子字符串的<strong>长度</strong>。若省略该参数，就会提取从 pos 开始删除直到字符串末尾的所有字符。</p>
<p><strong>find 函数 用于在原字符串中寻找某个字符或某个子串的位置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line">int pos1 = s.find(&#x27;,&#x27;);</span><br><span class="line">int pos2 = s.find(&quot;NJY&quot;);</span><br></pre></td></tr></table></figure>

<p>查找子字符串的时候 返回的位置是这个字符串的第一个字符出现的位置</p>
<p>如果没有找到 会返回 <strong>-1</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">NJY</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/04/28/%E6%9C%AA%E5%91%BD%E5%90%8D%201/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0/">http://example.com/2025/04/28/%E6%9C%AA%E5%91%BD%E5%90%8D%201/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">NJYgocrazy</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/cpp/">cpp</a></div><div class="post-share"><div class="social-share" data-image="https://s21.ax1x.com/2025/04/28/pE7libq.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/04/28/%E6%9C%AA%E5%91%BD%E5%90%8D%201/1.HTML/" title="HTML笔记"><img class="cover" src="https://s21.ax1x.com/2025/04/28/pE7lm24.md.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">HTML笔记</div></div><div class="info-2"><div class="info-item-1">1.HTML基本框架12345678&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;&lt;/body&gt;&lt;/html&gt;  其中 title 为当前网页的名称 各类标签由标签和内容组成的就叫元素，放在 body 内注意元素之间的换行是由换行标签实现的 元素包含可能出现的图片文字超链接等等 注释标签1&lt;!-- 我是注释！！！ --》  注意这里的标签里不要有奇奇怪怪的空格出现 大致框架中的标签12345678910111213141516171819&lt;body&gt; ...</div></div></div></a><a class="pagination-related" href="/2025/04/28/%E6%9C%AA%E5%91%BD%E5%90%8D%201/%E6%A0%91/" title="树"><img class="cover" src="https://s21.ax1x.com/2025/04/28/pE7exCd.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">树</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/04/28/%E6%9C%AA%E5%91%BD%E5%90%8D%201/%E7%AE%97%E6%B3%95/" title="算法--从入门到出门"><img class="cover" src="https://s21.ax1x.com/2025/04/28/pE7eXUe.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-28</div><div class="info-item-2">算法--从入门到出门</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/ava.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">NJY</div><div class="author-info-description">LEC SWPU 前端</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93"><span class="toc-number">1.</span> <span class="toc-text">刷题总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.</span> <span class="toc-text">方法技巧总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%8F%A5%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%AF%B9%E5%8D%95%E8%AF%8D%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">1.2.1.</span> <span class="toc-text">在句子字符串中对单词的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%85%A5%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">读入问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%90%E4%B8%AA%E5%88%86%E6%9E%90%E5%8D%95%E8%AF%8D"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">逐个分析单词</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string-%E4%B8%AD-find-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">string 中 find 函数的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A0%BC%E5%9B%BE%E5%B0%8F%E6%8A%80%E5%B7%A7"><span class="toc-number">1.2.3.</span> <span class="toc-text">方格图小技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%86%E6%9E%90%E4%B8%8A%E4%B8%8B%E5%B7%A6%E5%8F%B3"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">1.分析上下左右</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AF%B9%E8%A7%92%E7%BA%BF%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">2.对角线的表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%96%B9%E6%A0%BC%E5%9B%BE%E4%B8%AD%E4%BF%A1%E6%81%AF%E5%8F%98%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">3.方格图中信息变字符串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%A7%E4%BB%93%E9%80%89%E5%9D%80%E5%B0%8F%E7%BB%93%E8%AE%BA"><span class="toc-number">1.2.4.</span> <span class="toc-text">货仓选址小结论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8-DFS"><span class="toc-number">1.2.5.</span> <span class="toc-text">什么时候用 DFS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0"><span class="toc-number">1.2.6.</span> <span class="toc-text">统计出现次数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%80%8D%E6%95%B0%E9%97%AE%E9%A2%98%E7%9A%84%E5%B0%8F%E7%BB%93%E8%AE%BA"><span class="toc-number">1.2.7.</span> <span class="toc-text">关于倍数问题的小结论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DFS-%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%BA%94%E7%94%A8"><span class="toc-number">1.2.8.</span> <span class="toc-text">DFS 的两种应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DFS-%E6%B1%82%E8%BF%9E%E9%80%9A%E5%9D%97"><span class="toc-number">1.2.8.1.</span> <span class="toc-text">DFS 求连通块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DFS-%E6%B1%82%E6%89%80%E6%9C%89%E6%8E%92%E5%88%97"><span class="toc-number">1.2.8.2.</span> <span class="toc-text">DFS 求所有排列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E5%9B%9E%E6%BA%AF"><span class="toc-number">1.2.8.3.</span> <span class="toc-text">是否需要回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BD%95%E6%97%B6%E9%9C%80%E8%A6%81%E6%98%BE%E5%BC%8F%E7%BB%93%E6%9D%9F%E6%9D%A1%E4%BB%B6%EF%BC%9F"><span class="toc-number">1.2.8.3.1.</span> <span class="toc-text">1. 何时需要显式结束条件？</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.8.3.1.1.</span> <span class="toc-text">示例：全排列问题</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BD%95%E6%97%B6%E4%B8%8D%E9%9C%80%E8%A6%81%E6%98%BE%E5%BC%8F%E7%BB%93%E6%9D%9F%E6%9D%A1%E4%BB%B6%EF%BC%9F"><span class="toc-number">1.2.8.3.2.</span> <span class="toc-text">2. 何时不需要显式结束条件？</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.8.3.2.1.</span> <span class="toc-text">示例：字符串拼接问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%85%B3%E9%94%AE%E5%8C%BA%E5%88%86%E5%8E%9F%E5%88%99"><span class="toc-number">1.2.8.4.</span> <span class="toc-text">3. 关键区分原则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BFS"><span class="toc-number">1.2.9.</span> <span class="toc-text">BFS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%95%B0%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.10.</span> <span class="toc-text">选数问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%98%E5%B0%8F%E8%AE%B0"><span class="toc-number">1.3.</span> <span class="toc-text">洛谷刷题小记</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#P1083-%E5%80%9F%E6%95%99%E5%AE%A4"><span class="toc-number">1.3.1.</span> <span class="toc-text">P1083 借教室</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P1030-%E6%B1%82%E5%85%88%E5%BA%8F%E6%8E%92%E5%88%97"><span class="toc-number">1.3.2.</span> <span class="toc-text">P1030 求先序排列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88Pre-order-Traversal%EF%BC%89"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">1. 先序遍历（Pre-order Traversal）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88In-order-Traversal%EF%BC%89"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">2. 中序遍历（In-order Traversal）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88Post-order-Traversal%EF%BC%89"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">3. 后序遍历（Post-order Traversal）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E5%9B%BE%E8%A7%A3"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">示例图解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P10905-%E8%93%9D%E6%A1%A5%E6%9D%AF-2024-%E7%9C%81-C-%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.3.3.</span> <span class="toc-text">P10905 [蓝桥杯 2024 省 C] 回文字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P1044-%E6%A0%88"><span class="toc-number">1.3.4.</span> <span class="toc-text">P1044 栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P1359-%E7%A7%9F%E7%94%A8%E6%B8%B8%E8%89%87"><span class="toc-number">1.3.5.</span> <span class="toc-text">P1359 租用游艇</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P3131%EF%BC%88%E5%AF%B9%E4%BA%8E%E5%80%8D%E6%95%B0%E9%97%AE%E9%A2%98%E7%9A%84%E4%BC%98%E5%8C%96%EF%BC%89"><span class="toc-number">1.3.6.</span> <span class="toc-text">P3131（对于倍数问题的优化）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P2036"><span class="toc-number">1.3.7.</span> <span class="toc-text">P2036</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P2196-%E6%8C%96%E5%9C%B0%E9%9B%B7%EF%BC%88%E5%9B%BE%E4%B8%8A-DFS%EF%BC%89"><span class="toc-number">1.3.8.</span> <span class="toc-text">P2196 挖地雷（图上 DFS）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#acm-%E6%96%B0%E7%94%9F%E8%B5%9B"><span class="toc-number">1.4.</span> <span class="toc-text">acm 新生赛</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-%E5%B0%8F%E5%88%98%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="toc-number">1.4.1.</span> <span class="toc-text">A 小刘的最短路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E5%BB%BA%E9%80%A0%E6%96%B0%E5%AE%B6"><span class="toc-number">1.4.2.</span> <span class="toc-text">B 建造新家</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E5%90%88%E6%88%90%E5%A4%A7%E9%9B%AA%E7%90%83"><span class="toc-number">1.4.3.</span> <span class="toc-text">C 合成大雪球</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#D-%E7%BE%BD%E6%AF%9B%E7%90%83%E6%AF%94%E8%B5%9B"><span class="toc-number">1.4.4.</span> <span class="toc-text">D 羽毛球比赛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#E-%E5%B0%8F%E9%9D%92%E6%89%BE%E5%AE%9D%E8%97%8F"><span class="toc-number">1.4.5.</span> <span class="toc-text">E 小青找宝藏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#F-%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF"><span class="toc-number">1.4.6.</span> <span class="toc-text">F 矩形面积</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#K-%E8%B5%9A%E5%B7%AE%E4%BB%B7"><span class="toc-number">1.4.7.</span> <span class="toc-text">K 赚差价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#L-%E7%BC%96%E8%BE%91%E5%99%A8"><span class="toc-number">1.4.8.</span> <span class="toc-text">L 编辑器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%9B%E5%AE%A2%E5%88%B7%E9%A2%98%E5%B0%8F%E8%AE%B0"><span class="toc-number">1.5.</span> <span class="toc-text">牛客刷题小记</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%A1%E5%A4%96%E7%9A%84%E6%A0%91"><span class="toc-number">1.5.1.</span> <span class="toc-text">校外的树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%EF%BC%88%E8%BF%99%E4%B8%AA%E9%A2%98%E8%B7%9F%E4%BA%8C%E5%88%86%E6%97%A0%E5%85%B3%EF%BC%89"><span class="toc-number">1.5.2.</span> <span class="toc-text">二分（这个题跟二分无关）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98%E5%B0%8F%E8%AE%B0"><span class="toc-number">1.6.</span> <span class="toc-text">寒假刷题小记</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-number">1.6.1.</span> <span class="toc-text">1.全排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-N-%E7%9A%87%E5%90%8E"><span class="toc-number">1.6.2.</span> <span class="toc-text">2.N 皇后</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%A9%AC%E8%B5%B0%E6%97%A5"><span class="toc-number">1.6.3.</span> <span class="toc-text">3.马走日</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%95%B0%E7%8B%AC"><span class="toc-number">1.6.4.</span> <span class="toc-text">4. 数独</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dfs-%E5%B0%8F%E7%BB%93"><span class="toc-number">1.6.5.</span> <span class="toc-text">dfs 小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%BF%99%E9%87%8C%E6%9C%89%E5%9B%9B%E9%81%93%E9%A2%98-%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B"><span class="toc-number">1.6.6.</span> <span class="toc-text">5.(这里有四道题)牛客周赛</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#q1"><span class="toc-number">1.6.6.1.</span> <span class="toc-text">q1 :</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#q2-%EF%BC%9A"><span class="toc-number">1.6.6.2.</span> <span class="toc-text">q2 ：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#q3"><span class="toc-number">1.6.6.3.</span> <span class="toc-text">q3 :</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#q4"><span class="toc-number">1.6.6.4.</span> <span class="toc-text">q4 :</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%8F%8C%E4%BA%BA%E8%BF%B7%E5%AE%AB%E7%9B%B8%E9%81%87%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.7.</span> <span class="toc-text">6.双人迷宫相遇问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%9C%B0%E9%9B%B7%E9%80%92%E6%8E%A8"><span class="toc-number">1.6.8.</span> <span class="toc-text">7.地雷递推</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E8%B4%AA%E5%BF%83%E6%8B%BC%E6%95%B0"><span class="toc-number">1.6.9.</span> <span class="toc-text">8.贪心拼数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E8%B4%AA%E5%BF%83%E6%8E%92%E5%BA%A7%E6%A4%85"><span class="toc-number">1.6.10.</span> <span class="toc-text">9.贪心排座椅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E8%B4%AA%E5%BF%83%E5%9B%BD%E7%8E%8B%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.11.</span> <span class="toc-text">10.贪心国王的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E5%B0%8F%E7%BB%93"><span class="toc-number">1.6.12.</span> <span class="toc-text">贪心小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%85%88%E5%BA%8F%E6%8E%92%E5%88%97"><span class="toc-number">1.6.13.</span> <span class="toc-text">11.先序排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E4%BA%8C%E5%88%86%E6%99%BE%E8%A1%A3%E6%9C%8D"><span class="toc-number">1.6.14.</span> <span class="toc-text">12.二分晾衣服</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-number">1.6.15.</span> <span class="toc-text">13.表达式求值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">1.6.16.</span> <span class="toc-text">14.并查集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-a-b%EF%BC%882%EF%BC%89"><span class="toc-number">1.6.17.</span> <span class="toc-text">15.牛客周赛 a+b（2）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-cfdiv2%EF%BC%882%EF%BC%89"><span class="toc-number">1.6.18.</span> <span class="toc-text">16.cfdiv2（2）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E8%AE%AD%E7%BB%83%E8%90%A5-1"><span class="toc-number">1.6.19.</span> <span class="toc-text">17.牛客寒假训练营 1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E8%A8%80-1"><span class="toc-number">1.6.19.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#a"><span class="toc-number">1.6.19.2.</span> <span class="toc-text">a.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b"><span class="toc-number">1.6.19.3.</span> <span class="toc-text">b.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d"><span class="toc-number">1.6.19.4.</span> <span class="toc-text">d.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#e"><span class="toc-number">1.6.19.5.</span> <span class="toc-text">e.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#g"><span class="toc-number">1.6.19.6.</span> <span class="toc-text">g.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#h"><span class="toc-number">1.6.19.7.</span> <span class="toc-text">h.</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E8%AE%AD%E7%BB%83%E8%90%A5-2"><span class="toc-number">1.6.20.</span> <span class="toc-text">18.牛客寒假训练营 2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E8%A8%80-2"><span class="toc-number">1.6.20.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#a-1"><span class="toc-number">1.6.20.2.</span> <span class="toc-text">a.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-1"><span class="toc-number">1.6.20.3.</span> <span class="toc-text">b.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c"><span class="toc-number">1.6.20.4.</span> <span class="toc-text">c.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d-1"><span class="toc-number">1.6.20.5.</span> <span class="toc-text">d.</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98%E8%A1%A5%E9%A2%98"><span class="toc-number">1.7.</span> <span class="toc-text">蓝桥杯真题补题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF-cb-%E7%9C%81%E8%B5%9B"><span class="toc-number">1.7.1.</span> <span class="toc-text">十四届蓝桥杯 cb 省赛</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E6%97%A5%E6%9C%9F%E7%BB%9F%E8%AE%A1"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">a 日期统计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b01-%E4%B8%B2%E7%9A%84%E7%86%B5"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">b01 串的熵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-%E5%86%B6%E7%82%BC%E9%87%91%E5%B1%9E"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">c 冶炼金属</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d-%E9%A3%9E%E6%9C%BA%E9%99%8D%E8%90%BD"><span class="toc-number">1.7.1.4.</span> <span class="toc-text">d 飞机降落</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#e-%E6%8E%A5%E9%BE%99%E6%95%B0%E5%88%97"><span class="toc-number">1.7.1.5.</span> <span class="toc-text">e 接龙数列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#f-%E5%B2%9B%E5%B1%BF%E4%B8%AA%E6%95%B0"><span class="toc-number">1.7.1.6.</span> <span class="toc-text">f 岛屿个数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#g-%E5%AD%90%E4%B8%B2%E7%AE%80%E5%86%99"><span class="toc-number">1.7.1.7.</span> <span class="toc-text">g 子串简写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#h-%E6%95%B4%E6%95%B0%E5%88%A0%E9%99%A4"><span class="toc-number">1.7.1.8.</span> <span class="toc-text">h 整数删除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A9%E6%A2%AF%E8%B5%9B%E9%80%89%E6%8B%94%E6%A8%A1%E6%8B%9F"><span class="toc-number">1.8.</span> <span class="toc-text">天梯赛选拔模拟</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E9%9D%99%E7%9A%84%E6%8E%A8%E8%8D%90"><span class="toc-number">1.8.1.</span> <span class="toc-text">静静的推荐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%97%85%E6%AF%92%E6%BA%AF%E6%BA%90"><span class="toc-number">1.8.2.</span> <span class="toc-text">病毒溯源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%85%E7%82%B9%E4%BB%A3%E7%A0%81"><span class="toc-number">1.8.3.</span> <span class="toc-text">清点代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%B2%E5%93%B2%E6%89%93%E6%B8%B8%E6%88%8F"><span class="toc-number">1.8.4.</span> <span class="toc-text">哲哲打游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.8.5.</span> <span class="toc-text">完全二叉树的层序遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%82%E9%A2%98%EF%BC%88%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81%E9%83%BD%E5%9C%A8%E6%9D%82%E9%A2%98%E6%96%87%E4%BB%B6%E5%A4%B9%E9%87%8C%EF%BC%89"><span class="toc-number">1.9.</span> <span class="toc-text">杂题（具体代码都在杂题文件夹里）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#k-%E5%80%8D%E5%8C%BA%E9%97%B4"><span class="toc-number">1.9.1.</span> <span class="toc-text">k 倍区间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B7%A7%E5%85%8B%E5%8A%9B"><span class="toc-number">1.9.2.</span> <span class="toc-text">分巧克力</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%A9%E4%B8%89%E5%9B%BD%E6%9D%80"><span class="toc-number">1.9.3.</span> <span class="toc-text">玩三国杀</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A9%E6%A2%AF%E8%B5%9B%E9%80%89%E6%8B%94"><span class="toc-number">1.10.</span> <span class="toc-text">天梯赛选拔</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%B5%9B%E9%93%BE%E6%8E%A5"><span class="toc-number">1.10.1.</span> <span class="toc-text">比赛链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#L1-A-%E8%BF%9B%E5%88%B6"><span class="toc-number">1.10.2.</span> <span class="toc-text">L1 - A 进制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#L1-%E9%BA%BB%E5%B0%86"><span class="toc-number">1.10.3.</span> <span class="toc-text">L1-麻将</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#L1-%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">1.10.4.</span> <span class="toc-text">L1-位运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#L2-%E6%9F%A5%E6%97%A0%E6%AD%A4%E5%8F%B7"><span class="toc-number">1.10.5.</span> <span class="toc-text">L2-查无此号</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A9%E6%A2%AF%E8%B5%9B%E5%87%86%E5%A4%87"><span class="toc-number">1.11.</span> <span class="toc-text">天梯赛准备</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B2%E7%AC%A8%E9%92%9F"><span class="toc-number">1.11.1.</span> <span class="toc-text">敲笨钟</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/04/28/%E6%9C%AA%E5%91%BD%E5%90%8D%201/%E6%A0%91/" title="树"><img src="https://s21.ax1x.com/2025/04/28/pE7exCd.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="树"/></a><div class="content"><a class="title" href="/2025/04/28/%E6%9C%AA%E5%91%BD%E5%90%8D%201/%E6%A0%91/" title="树">树</a><time datetime="2025-04-28T14:00:14.821Z" title="发表于 2025-04-28 14:00:14">2025-04-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/28/%E6%9C%AA%E5%91%BD%E5%90%8D%201/%E7%AE%97%E6%B3%95/" title="算法--从入门到出门"><img src="https://s21.ax1x.com/2025/04/28/pE7eXUe.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法--从入门到出门"/></a><div class="content"><a class="title" href="/2025/04/28/%E6%9C%AA%E5%91%BD%E5%90%8D%201/%E7%AE%97%E6%B3%95/" title="算法--从入门到出门">算法--从入门到出门</a><time datetime="2025-04-28T14:00:14.821Z" title="发表于 2025-04-28 14:00:14">2025-04-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/28/%E6%9C%AA%E5%91%BD%E5%90%8D%201/1.HTML/" title="HTML笔记"><img src="https://s21.ax1x.com/2025/04/28/pE7lm24.md.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HTML笔记"/></a><div class="content"><a class="title" href="/2025/04/28/%E6%9C%AA%E5%91%BD%E5%90%8D%201/1.HTML/" title="HTML笔记">HTML笔记</a><time datetime="2025-04-28T14:00:14.820Z" title="发表于 2025-04-28 14:00:14">2025-04-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/28/%E6%9C%AA%E5%91%BD%E5%90%8D%201/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0/" title="刷题小记--从下笔到遗忘"><img src="https://s21.ax1x.com/2025/04/28/pE7libq.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="刷题小记--从下笔到遗忘"/></a><div class="content"><a class="title" href="/2025/04/28/%E6%9C%AA%E5%91%BD%E5%90%8D%201/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0/" title="刷题小记--从下笔到遗忘">刷题小记--从下笔到遗忘</a><time datetime="2025-04-28T14:00:14.820Z" title="发表于 2025-04-28 14:00:14">2025-04-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By NJY</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script> $(".category-list-count").prepend("<i class=\"fas fa-book\"></i>");</script><script> $(".category-list-item").eq(0).insertAfter($(".gallery-group-name").eq(0))</script><script> $(".category-list-item").eq(1).insertAfter($(".gallery-group-name").eq(1))</script><script> $(".category-list-item").eq(2).insertAfter($(".gallery-group-name").eq(2))</script><script> $(".category-list-item").eq(3).insertAfter($(".gallery-group-name").eq(3))</script><script> $(".category-list-item").eq(4).insertAfter($(".gallery-group-name").eq(4))</script><script> $(".category-list-item").eq(5).insertAfter($(".gallery-group-name").eq(5))</script><script> $(".category-list-item a").hide();</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="N,LOVE,T" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://s21.ax1x.com/2025/04/28/pE7l3a6.md.jpg);"> <a class="categoryBar-list-link" href="categories/前端/">前端</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">算法</span></li><li class="categoryBar-list-item" style="background:url(https://s21.ax1x.com/2025/04/28/pE7l1Vx.md.jpg);"> <a class="categoryBar-list-link" href="categories/苦吟/">苦吟</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">苦吟</span></li><li class="categoryBar-list-item" style="background:url(https://s21.ax1x.com/2025/04/28/pE7libq.md.jpg);"> <a class="categoryBar-list-link" href="categories/算法/">算法</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">前端</span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><!-- hexo injector body_end end --></body></html>