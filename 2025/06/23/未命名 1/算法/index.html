<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>算法--从入门到出门 | NJYgocrazy</title><meta name="author" content="NJY"><meta name="copyright" content="NJY"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="算法模板 &amp;&amp; 一些题目">
<meta property="og:type" content="article">
<meta property="og:title" content="算法--从入门到出门">
<meta property="og:url" content="http://example.com/2025/06/23/%E6%9C%AA%E5%91%BD%E5%90%8D%201/%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="NJYgocrazy">
<meta property="og:description" content="算法模板 &amp;&amp; 一些题目">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s21.ax1x.com/2025/06/23/pVZxcaF.png">
<meta property="article:published_time" content="2025-06-23T14:34:49.296Z">
<meta property="article:modified_time" content="2025-06-23T14:34:49.297Z">
<meta property="article:author" content="NJY">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="cpp">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s21.ax1x.com/2025/06/23/pVZxcaF.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "算法--从入门到出门",
  "url": "http://example.com/2025/06/23/%E6%9C%AA%E5%91%BD%E5%90%8D%201/%E7%AE%97%E6%B3%95/",
  "image": "https://s21.ax1x.com/2025/06/23/pVZxcaF.png",
  "datePublished": "2025-06-23T14:34:49.296Z",
  "dateModified": "2025-06-23T14:34:49.297Z",
  "author": [
    {
      "@type": "Person",
      "name": "NJY",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/06/23/%E6%9C%AA%E5%91%BD%E5%90%8D%201/%E7%AE%97%E6%B3%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '算法--从入门到出门',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/top.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/ava.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://s21.ax1x.com/2025/06/23/pVZxcaF.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">NJYgocrazy</span></a><a class="nav-page-title" href="/"><span class="site-name">算法--从入门到出门</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">算法--从入门到出门</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-23T14:34:49.296Z" title="发表于 2025-06-23 14:34:49">2025-06-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-23T14:34:49.297Z" title="更新于 2025-06-23 14:34:49">2025-06-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>翻笔记的时候发现一不留神写了这么多字，所以想到来汇总一下所有的算法笔记，也算是记录自己的大一吧。</p>
<p>真正的败狗之路也就是在写了这么多笔记后竟然有望得到0个奖项。</p>
<p>祝笔试算法全过。🙌</p>
<h2 id="第一章基础算法"><a href="#第一章基础算法" class="headerlink" title="第一章基础算法"></a>第一章基础算法</h2><h3 id="快速排序与快速选择"><a href="#快速排序与快速选择" class="headerlink" title="快速排序与快速选择"></a>快速排序与快速选择</h3><p><strong>快排</strong>的基本思想是分治</p>
<p>假设有一串左边界为l右边界为r的数组，用快排对其排序需要三步</p>
<h4 id="1-确定一个数组内的值用来划分数组"><a href="#1-确定一个数组内的值用来划分数组" class="headerlink" title="1.确定一个数组内的值用来划分数组"></a>1.确定一个数组内的值用来划分数组</h4><p>这个数一般选用a[l],a[r],a[(l+r)&#x2F;2]这三种（即左边界右边界和中间值）</p>
<h4 id="2-对于原数组进行划分。"><a href="#2-对于原数组进行划分。" class="headerlink" title="2.对于原数组进行划分。"></a>2.对于原数组进行划分。</h4><p>即以某一个位置为界限，该位置左边全都是小于分界值的，右边的数全都是大于分界值的。</p>
<p>在这一步中需要两个指针i和j分别从左右开始遍历数组。</p>
<p>以i从左边开始遍历，j从右边开始遍历为例。</p>
<p>如果i指向的数字小于分界值，则i右移一位继续判断；如果j指向的数大于分界值，则j左移一位继续判断</p>
<p>如果两边都不再执行指针的移动，则说明两边的指针指向的数与需要的条件恰恰相反，故交换这两个数，然后继续判断。</p>
<p>这样的过程保证了i指针左侧的值全是小于分界值的，j指针右侧的指针全是大于分界值的，故而当ij指针相遇或者ij指针互相穿过的时候，整个数组就完成了排序。</p>
<h4 id="3-对分出的两个区域进行递归处理"><a href="#3-对分出的两个区域进行递归处理" class="headerlink" title="3.对分出的两个区域进行递归处理"></a>3.对分出的两个区域进行递归处理</h4><p>即是对每一个区域再次进行步骤2的过程直到最后区域被缩减到一个即完成了排序</p>
<p>给出快排函数的模板</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> x=q[l],i=l<span class="number">-1</span>,j=r<span class="number">+1</span>;<span class="comment">//是因为后面用了dowhile循环，是先移动再判断，故两个指针恰好在左右边界的两侧</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i++ ;<span class="keyword">while</span> (q[i]&lt;x);</span><br><span class="line">        <span class="keyword">do</span> j-- ;<span class="keyword">while</span>(q[j]&gt;x);</span><br><span class="line">        <span class="comment">//实现左指针左边全小于，右指针右侧全大于</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;j) <span class="built_in">swap</span>(q[i],q[j]);<span class="comment">//如果不再进行指针加减则交换两个数就可以继续了</span></span><br><span class="line">    &#125;</span><br><span class="line">    当结束这个循环时说明两个指针恰好相遇或者已经穿过，第一次结束</span><br><span class="line">    <span class="built_in">quick_sort</span>(q,l,j);<span class="comment">//从左边界到右指针，即对左部分再次进行排序</span></span><br><span class="line">    <span class="built_in">quick_sort</span>(q,j<span class="number">+1</span>,r);<span class="comment">//即对右部分再次进行排序</span></span><br><span class="line">    <span class="comment">//根据以上代码可知，j不断向左移动后最终变为左边界-1，此时对于第一个递归l&gt;j，会直接返回</span></span><br><span class="line">    排序结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-快速选择"><a href="#4-快速选择" class="headerlink" title="4.快速选择"></a>4.快速选择</h4><p><strong>快选</strong>是在快排的基础上进行的，用于从中选出第k小（大同理）</p>
<p>根据快排的原理可以看出，每次左分区的数一定都小于右边界的数，故而想要选出第k小的数可以通过每个分区的长度去简化排序的次数</p>
<p>比如左边界的长度l1大于等于k，那么k一定会在左边界中，故只需要在左边界中进行递归，最终找到这个点数</p>
<p>如果左边界l1的长度小于k，那么k一定会在右边界中，故只需要在右边界中进行递归，但需要注意的是，在右边界中，应该是k-l2小的数。</p>
<p>需要注意的是，在每一次递归中都需要更新长度。</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">quick_choice</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> a[l];<span class="comment">//最后区间缩小到只含一个数了那么这个数肯定就是答案</span></span><br><span class="line">   <span class="comment">//以下与快排相同</span></span><br><span class="line">    <span class="type">int</span> x=a[l],i=l<span class="number">-1</span>,j=r<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i++;<span class="keyword">while</span> (a[i]&lt;x);</span><br><span class="line">        <span class="keyword">do</span> j--;<span class="keyword">while</span> (a[j]&gt;x);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j) <span class="built_in">swap</span>(a[i],a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> s1=j-l<span class="number">+1</span>;<span class="comment">//计算左边界长度</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//上面已经解释过为什么这么递归了</span></span><br><span class="line">    <span class="keyword">if</span>(s1&gt;=k) <span class="keyword">return</span> <span class="built_in">quick_choice</span>(l,j,k);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">quick_choice</span>(j<span class="number">+1</span>,r,k-s1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序的基本思想也是分治，但不同于快排的是分界线就是数组的中间位置</p>
<h4 id="1-基本步骤"><a href="#1-基本步骤" class="headerlink" title="1. 基本步骤"></a>1. 基本步骤</h4><p>1.以中间位置为分界线，将数组分成两部分</p>
<p>2.递归两部分，使这两部分都变成有序序列</p>
<p>3.将这两部分有序序列合并成一个有序数组，从而完成排序</p>
<p>在合并的过程中需要使用双指针算法</p>
<p>即对于两个有序序列，分别设置一个指针指向最左侧（即指向最小的数字）</p>
<p>每次都判断两个指针指向的数字，哪边的数字小就把这个数字写进最终数组，并将这个指针移动，另一个指针依然不动</p>
<p>其中含有一种特殊情况是其中一个数组的指针已经指到了右边界，那么这个时候只需将另一个数组的剩余部分全部写入即可</p>
<p>现给出代码部分</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> ;<span class="comment">//一样的，是递归最后一次结束的判断</span></span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;<span class="comment">//以中间为分界线分割</span></span><br><span class="line">    <span class="built_in">merge_sort</span>(a,l,mid); <span class="built_in">merge_sort</span>(a,mid<span class="number">+1</span>,r);<span class="comment">//分别递归左右两部分使其有序</span></span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>,i=l,j=mid<span class="number">+1</span>;<span class="comment">//k用于储存临时的答案数组的遍历，i为第一部分的指针，j为第二部分的指针</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=a[j]) temp[k++]=a[i++];</span><br><span class="line">        <span class="keyword">else</span> temp[k++]=a[j++];</span><br><span class="line">    &#125;<span class="comment">//该段与上面排序原理的解释一致</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) temp[k++]=a[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r) temp[k++]=a[j++];<span class="comment">//这一段代码使得一部分结束循环后，剩余的数组的部分被全部写入答案</span></span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(i=l,j=<span class="number">0</span>;i&lt;=r;i++,j++) a[i]=temp[j];</span><br><span class="line">    <span class="comment">//将临时答案里的每个数复制到原数组里去 最后结束这个函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>回归头来进一步地看，其实归并排序中最重要的点还是它归并时候的思路即我们使用双指针去遍历两个数组不断比较指针指向的值使得答案数组有序的过程。</p>
<p>在很多关于两个序列合成一个序列的问题中都可以得到应用。</p>
<h4 id="2-归并排序中求逆序对"><a href="#2-归并排序中求逆序对" class="headerlink" title="2.归并排序中求逆序对"></a>2.归并排序中求逆序对</h4><p>假设一个数组中的每个数都与其位置组成一个二元数对&lt;a[i],i&gt;，那么逆序对的定义即是a[i]&gt;a[j]&amp;&amp;i&lt;j</p>
<p>可以知道，在归并排序的第三步合并数组时，对两个数组进行指针遍历的过程中，判断大小的过程中恰好可以用来判断逆序对。</p>
<p>在归并的过程中，最小的数字先写入，那么当我们在第一个序列里找到了一个a[i]&gt;a[j]（第二序列中的一个数）时，先写入a[j]，那么a[i]后面的所有数都可以与a[j]构成一个逆序对（因为两个序列已经是有序的了）</p>
<p>所以我们只需要在归并过程中对大于的情况多加一条计算逆序对的即可</p>
<p>具体代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> re=<span class="built_in">merge_sort</span>(a,l,mid)+<span class="built_in">merge_sort</span>(a,mid<span class="number">+1</span>,r);<span class="comment">//递归到最后得到所有逆序对对数</span></span><br><span class="line">    <span class="type">int</span> i=l,j=mid<span class="number">+1</span>,k=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> temp[<span class="number">10000</span>];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=a[j]) &#123;</span><br><span class="line">            temp[k++]=a[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[k++]=a[j++];</span><br><span class="line">            re+=mid-i<span class="number">+1</span>;<span class="comment">//实现上面解释的逆序对查找方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) temp[k++]=a[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r) temp[k++]=a[j++];</span><br><span class="line">    <span class="keyword">for</span>(i=l,k=<span class="number">0</span>;i&lt;=r;i++,k++) a[i]=temp[k];<span class="comment">//注意虽然这里的目的是求逆序对对数，但每次依然要更新a数组因为要递归得到，所以每一次都要递归到正确的数组</span></span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h3><p>整数二分法的目的是通过不断二分整数所在的范围从而最后得到整数所在的位置。</p>
<p>二分的原理是以中间值将序列分为两部分，然后通过判断mid与条件的关系来逐渐缩小需要判断的范围，使得最后范围缩小到整数所在的位置。（同样地最后返回的值为l或r，因为最后它们相等或差别很小）</p>
<h4 id="1-整数二分"><a href="#1-整数二分" class="headerlink" title="1.整数二分"></a>1.整数二分</h4><p>通过对判断条件的选择，二分法的模板分为两种，以一个例子来看，比如我们需要在一段数组中找到x的范围，我们先确定mid（即中间值），如果mid&gt;&#x3D;x，那么可知x的范围一定在mid的左侧，那么就把右边界更新为mid，x的范围肯定就在l到mid之间；反之mid&lt;x的话，可知一定在mid的右侧，所以将左边界更新为mid+1，x的范围肯定就在mid+1到r之间。</p>
<p>故而两种模板就分别是更新左边界和右边界的问题，根据更新的不同中间值的定义也不同，这一点在下面的代码中详细解释</p>
<p>注意二分法的前提是我们需要写一个判断的条件，现在我们假设这个判断条件是</p>
<p>在使用二分法解题时，首先要确定左右边界，然后最重要的一定是check判断条件的选择，要根据题意找出这个条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bool check(int x)</span><br><span class="line">&#123;</span><br><span class="line">    if(x&gt;k) return true;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">//此处的k是需要输入的，即需要判断的数</span><br><span class="line">//即这个数大就为真，小就为假</span><br></pre></td></tr></table></figure>

<h5 id="模板1"><a href="#模板1" class="headerlink" title="模板1"></a>模板1</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch1</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;<span class="comment">//一定要注意mid的计算一定是要在while循环中进行的，才能每次更新</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(a[mid])) r = mid;<span class="comment">//这段即是上面判断的中间值比所找值大，所找值一定在左侧</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="模板2"><a href="#模板2" class="headerlink" title="模板2"></a>模板2</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int bsearch(int l,int r)</span><br><span class="line">&#123;</span><br><span class="line">	while(l&lt;r)</span><br><span class="line">	&#123;</span><br><span class="line">		int mid=(l+r+1)/2;</span><br><span class="line">		if(check(a[mid])) l=mid;</span><br><span class="line">		else r=mid-1;</span><br><span class="line">	&#125;</span><br><span class="line">	return l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出来，整数二分的while条件是l&lt;r，即这个序列中还含有元素</p>
<p>现在我们来看浮点数二分，最大的区别是我们需要用while条件去判断精度，一般地，题目要求保留几位小数我们就在while条件中多加两位，譬如说题目要求精度为两位小数，那么我们可以写r-l&gt;0.0001</p>
<h4 id="2-浮点二分："><a href="#2-浮点二分：" class="headerlink" title="2.浮点二分："></a>2.浮点二分：</h4><p>同时还要注意的是，浮点二分中不存在复杂的边界问题，所以在更新边界的时候不用考虑加一减一的问题，模板如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">double bsearch(double ans)</span><br><span class="line">&#123;</span><br><span class="line">	while(r-l&lt;”精度的位数加2“)</span><br><span class="line">	&#123;</span><br><span class="line">		double mid=(l+r)/2;</span><br><span class="line">		if(check(mid)) l=mid;</span><br><span class="line">		else r=mid;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;//当然具体怎么换边界还是根据check函数以及题意来确定</span><br></pre></td></tr></table></figure>

<p>现给出一道例题来展示浮点二分</p>
<p><img src="C:\Users\Lenovo\Desktop\笔记\第一章基础算法.assets\image-20241023165205249.png" alt="image-20241023165205249"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">double a,b,c,d;</span><br><span class="line">double hanshu(double x)</span><br><span class="line">&#123;</span><br><span class="line">    return a*pow(x,3)+b*pow(x,2)+c*x+d;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">    int cnt=0;</span><br><span class="line">    for(int  i=-100;i&lt;=100;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        double l=i;</span><br><span class="line">        double r=i+1;//由于两根的差的绝对值大于等于1，故而每个长度为1的区间至多只有一个根，故基准的左右边界就是遍历的i和i+1</span><br><span class="line">        double x1=hanshu(l);</span><br><span class="line">        double x2=hanshu(r);</span><br><span class="line">        if(x1==0) &#123;</span><br><span class="line">            printf(&quot;%.2f &quot;,l);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(x1*x2&lt;0)//零点存在定理</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            while(r-l&gt;=0.001)//通过while条件来控制二分法的精度</span><br><span class="line">            &#123;</span><br><span class="line">                double  mid=(l+r)/2;</span><br><span class="line">                if(hanshu(mid)*hanshu(l)&lt;0) r=mid;</span><br><span class="line">                else l=mid; //依旧是零点存在定理来更新，但注意这里mid的精度，不用+1，直接使用即可</span><br><span class="line">            &#125;</span><br><span class="line">            printf(&quot;%.2f &quot;,r);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(cnt==3) break;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-二分答案"><a href="#3-二分答案" class="headerlink" title="3.二分答案"></a>3.二分答案</h4><p>二分答案即是用二分的方法枚举取得答案，很像是对二分的逆过程，不断对范围的左边界或右边界进行调整，以逐渐找到最满足要求的答案。</p>
<p>二分答案实际上也是一种枚举，但其使用需要条件，即序列必须是单调的闭区间。</p>
<p>二分答案实际上就是一个求最优解的过程，“最优解一定可行，但可行解不一定最优”，每次满足check函数就相当于找到了一个可行解，那么由于序列是有序的，所以知道这个可行解的前面（或后面）一定也都是可行解，从而缩小可行解的范围，最终得到那个最优解。</p>
<p>用一道例题说明问题</p>
<p><img src="C:\Users\Lenovo\Desktop\笔记\第一章基础算法.assets\image-20241023172621700.png" alt="image-20241023172621700"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1000100;</span><br><span class="line">int a[N];</span><br><span class="line">int n,k;</span><br><span class="line"></span><br><span class="line">bool find(long long x)</span><br><span class="line">&#123;</span><br><span class="line">    long long ans=0;</span><br><span class="line">    for(int i=0;i&lt;n;i++) &#123;</span><br><span class="line">        ans+=a[i]/x;</span><br><span class="line">    &#125;</span><br><span class="line">    if(ans&gt;=k) return true;</span><br><span class="line">    else return false;</span><br><span class="line">&#125;</span><br><span class="line">//这里是寻找的更新边界的判断条件，即加和每一根木料可以分割多少个，判断最后的总值是否满足条件</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    long long l=0,r=100000001;//此题的数据范围是木材长度的最大值是100000000，所以不妨设一开始的范围是这个最值加1</span><br><span class="line">    这也是二分找答案的初始步骤，即先找出最大的极限位置</span><br><span class="line">    while(l+1&lt;r)//即题目所说的，如果小于1cm则不切割直接输出0（这也是为什么要定义l为0，这样如果不进入循环的话就不用做一个特判，直接能输出0</span><br><span class="line">    &#123;</span><br><span class="line">        long long mid=(l+r)/2;</span><br><span class="line">        if(find(mid)) l=mid;//如果现在的长度已经大于或等于k了，就尝试能不能让长度再大一些，把起始值改成mid       </span><br><span class="line">        else r=mid;//如果现在的长度还小于k，则应该减短长度，把最大值改成mid</span><br><span class="line">    &#125;</span><br><span class="line">    //这里实际上就是不断更新不断尝试直到尝试不动（木块的长度越小就能切割越多块，反之越大块数越少）</span><br><span class="line">    cout&lt;&lt; l &lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然其实二分答案法的最大难度还是在于check的寻找，一些经验是顾名思义地去枚举答案，再反过来看这个答案会影响什么，从而反推回去看某一个变量是否与题目限制冲突了。</p>
<h3 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h3><p>高精度是针对特别大的数字之间的加法，数字的长度甚至可能是数字的位数小于等于十的九次方。</p>
<p>注意，高精度的四则运算的基本方法就是<strong>让计算机像人一样去计算</strong>！</p>
<p>由于数字可能特别大，所以我们以字符串的形式读入数字，并将每一位都扣出来储存进数组中，由于在进行高精度的运算时可能会有进位的问题出现，所以我们用动态长度的vector去储存</p>
<p>为了方便，正好在这里介绍一下<strong>vector的用法</strong></p>
<p>vector是一种容器，区别于普通数组，vector的区别主要有二，一是可以储存管理不限于数的多种类型的数据，二是它的大小是根据需要实时更新，动态更新的，（因而也有人称其为动态数组），所以用vector一遍不会有溢出的风险，在使用中更加的灵活易用					</p>
<p>1.vector的定义</p>
<p>首先需要加上一个头文件 #include <vector></p>
<p>vector&lt;储存的类型&gt;容器名 如vector<double>v;</p>
<p>同时也可以用vector储存数组，如vector<int>v[n];</p>
<p>2.vector的常用函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//这些都是必会的成员函数</span><br><span class="line">size()//返回返回容器中元素个数</span><br><span class="line">begin()//返回头部迭代器</span><br><span class="line">end()//返回尾部+1迭代器</span><br><span class="line">rbegin()//返回逆首部迭代器</span><br><span class="line">rend()//返回逆尾部-1迭代器</span><br><span class="line">front()//返回首个元素</span><br><span class="line">back()//返回尾部元素</span><br><span class="line">push_back()//在末尾添加一个元素</span><br><span class="line">emplace_back()//和push_back()是一样的作用</span><br><span class="line">pop_back()//弹出最后一个元素</span><br><span class="line">empty()//判断是否为空</span><br><span class="line">insert()//在指定位置插入元素</span><br><span class="line">erase()//在指定位置删除元素</span><br><span class="line">clear()//清空容器</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>size函数可以用来判断vector的长度，不用单独用变量储存同时还可以适配变化的长度</p>
<p>push_back函数用来给vector加上元素（加在最后）</p>
<p>而其余的函数要用再去查吧</p>
<p>遍历vector就用与数组一样的方式即可</p>
<h4 id="1-高精度加法"><a href="#1-高精度加法" class="headerlink" title="1.高精度加法"></a>1.高精度加法</h4><pre><code>         一，用数组储存大数，用第一位储存个位数然后依此类推，可以便于在后续进位中直接加一位数（因为vector加元素是从最后一位开始的。

        二，用竖式加法的原理来
</code></pre>
<p>计算，即每一位相加，然后再判断是否需要进位，最后放在结果位的是加和对10取的模，然后进位是加和结果&#x2F;10</p>
<p> 所以我们需要三个vector，分别是第一个数，第二个数，和最终的结果，同时还需要一个变量t来记录每次的进位</p>
<p>现在看代码模板</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">//add函数表示c=a+b</span><br><span class="line">vector&lt;int&gt;add(vector&lt;int&gt; &amp;a,vector&lt;int&gt; &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; c;</span><br><span class="line">    int t=0;</span><br><span class="line">    for(int i=0;i&lt;a.size()||i&lt;b.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(i&lt;a.size()) t+=a[i];</span><br><span class="line">        if(i&lt;b.size()) t+=b[i];</span><br><span class="line">        c.push_back(t%10);//取模结果</span><br><span class="line">        t/=10;//记录进位</span><br><span class="line">    &#125;</span><br><span class="line">    if(t!=0) c.push_back(1);//如果最后一位还有进位，就在前面加1</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;//大数用字符串读入</span><br><span class="line">    vector&lt;int&gt;m,n;</span><br><span class="line">    for(int i=a.size()-1;i&gt;=0;i--) m.push_back(a[i]-&#x27;0&#x27;);</span><br><span class="line">    for(int i=b.size()-1;i&gt;=0;i--) n.push_back(b[i]-&#x27;0&#x27;);//逆遍历储存进vector</span><br><span class="line"></span><br><span class="line">    auto c=add(m,n); //auto变量编译器会自动推导属于哪种变量</span><br><span class="line"></span><br><span class="line">    for(int i=c.size()-1;i&gt;=0;i--) cout&lt;&lt;c[i];//逆遍历输出</span><br><span class="line">    return 0;</span><br><span class="line">&#125;                                 </span><br></pre></td></tr></table></figure>

<h4 id="2-高精度减法"><a href="#2-高精度减法" class="headerlink" title="2.高精度减法"></a>2.高精度减法</h4><p> 一，高精度减法的大数储存方式与加法完全相同（可以确保在进行复合运算时的一致性） </p>
<p> 二，一样是采用竖式相减，需要注意的就是不够借1的问题，那么实际上我们只需要用一个变量来记录借的这个数，在每次相减的时候都减去这个数即可</p>
<p>另外，在相减的过程中，由于可能借1可能不借1（可能够减可能不够减），所以我们用一种写法来统一这两种情况，即(t+10)%10</p>
<p>可以进行一些模拟计算来验证可以发现是全面的</p>
<p>还需要注意的一点是减法中我们需要考虑减数与被减数之间的大小关系，从而来判断最后的结果要不要加负号</p>
<p>现在直接来看代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">bool cmp(vector&lt;int&gt; &amp;a,vector&lt;int&gt; &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">     if(a.size()!=b.size()) return a.size() &gt; b.size(); //如果位数不同就比较位数</span><br><span class="line">     for(int i=a.size();i&gt;=0;i--)</span><br><span class="line">     &#123;</span><br><span class="line">         if(a[i]!=b[i]) return a[i]&gt;b[i]; //如果位数相同，就从最高位开始比起</span><br><span class="line">     &#125;</span><br><span class="line">     return true;</span><br><span class="line">&#125;</span><br><span class="line">//return 后加的条件意为如果这个条件为真则返回true</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; sub(vector &lt;int&gt; &amp;a,vector&lt;int&gt; &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; c;</span><br><span class="line">    for(int i=0,t=0;i&lt;a.size();i++) //t为借的位数</span><br><span class="line">    &#123;</span><br><span class="line">        t = a[i] - t; //首先要减去借位</span><br><span class="line">        if(i&lt;b.size()) t -= b[i];//如果b还有位数则还要减去b的那一位数</span><br><span class="line">        c.push_back((t+10)%10);  //这一步就是综合了数借1与否的情况</span><br><span class="line">        if(t&lt;0) t=1;	//如果t小于0说明是借了位的，所以下一位要减一</span><br><span class="line">        else t=0; //没有借位</span><br><span class="line">    &#125;</span><br><span class="line">    while(c.size()&gt;1 &amp;&amp; c.back() == 0) c.pop_back(); //去掉前导0，让最后的输出结果为数字的形式</span><br><span class="line">    //如果c的长度只有一位且为0那么就不能去掉</span><br><span class="line">    //因为vector中加入的数都在最后面，所以去掉数前面的0应该是从最后一位看起,pop_back用于弹出最后一位数即去掉它，以此可以把数字前所有0去掉</span><br><span class="line">    return  c;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> int main()</span><br><span class="line"> &#123;</span><br><span class="line">    string m,n;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    vector&lt;int&gt;a,b;</span><br><span class="line">    for(int i = m.length()-1;i&gt;=0;i--) a.push_back(m[i]-&#x27;0&#x27;);</span><br><span class="line">    for(int i = n.length()-1;i&gt;=0;i--) b.push_back(n[i]-&#x27;0&#x27;);</span><br><span class="line">    if(cmp(a,b)) &#123;</span><br><span class="line">        auto c=sub(a,b);</span><br><span class="line">        for(int i=c.size()-1;i&gt;=0;i--) printf(&quot;%d&quot;,c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        auto c=sub(b,a);</span><br><span class="line">        cout &lt;&lt; &quot;-&quot;;//如果a&lt;b的话，就算b-a并且在前面加上一个负号</span><br><span class="line">        for(int i=c.size()-1;i&gt;=0;i--) printf(&quot;%d&quot;,c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-高精度乘法"><a href="#3-高精度乘法" class="headerlink" title="3.高精度乘法"></a>3.高精度乘法</h4><p>这里讨论的是一个高精度的特别大的数去乘以一个相对小的数（可以用int存下），基本思路是大数的每一位都乘以这个小数，然后放在该位的数是这个乘积被10取模的过程，而进位的则是这个乘积除以10的结果</p>
<p>代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; mul(vector&lt;int&gt; &amp;a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; c;</span><br><span class="line">    int t=0;</span><br><span class="line">    for(int i=0;i&lt;a.size()||t;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(i&lt;a.size()) t+=a[i]*b;</span><br><span class="line">        c.push_back(t%10);</span><br><span class="line">        t/=10;</span><br><span class="line">    &#125;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line">//可以看出来跟加法的模板挺像的 是不是可以说乘法跟加法是同源的？？</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string m; int b;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; b;</span><br><span class="line">    vector&lt;int&gt;  a;</span><br><span class="line">    for(int i=m.length()-1;i&gt;=0;i--) a.push_back(m[i]-&#x27;0&#x27;);</span><br><span class="line">    auto  c=mul(a,b);</span><br><span class="line">    for(int i=c.size()-1;i&gt;=0;i--) cout&lt;&lt;c[i];</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="大数×大数的高精度乘法"><a href="#大数×大数的高精度乘法" class="headerlink" title="大数×大数的高精度乘法"></a>大数×大数的高精度乘法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn=1e6+7;</span><br><span class="line">char a1[maxn],b1[maxn];</span><br><span class="line">int a[maxn],b[maxn],c[maxn*10],lena,lenb,lenc,x;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%s&quot;,a1);</span><br><span class="line">    scanf(&quot;%s&quot;,b1);</span><br><span class="line">    lena=strlen(a1);</span><br><span class="line">    lenb=strlen(b1);</span><br><span class="line">    for(int i=0;i&lt;lena;i++)a[lena-i]=a1[i]-&#x27;0&#x27;;</span><br><span class="line">    for(int i=0;i&lt;lenb;i++)b[lenb-i]=b1[i]-&#x27;0&#x27;;</span><br><span class="line">    for(int i=1;i&lt;=lena;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        x=0;</span><br><span class="line">        for(int j=1;j&lt;=lenb;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            c[i+j-1]=a[i]*b[j]+x+c[i+j-1];</span><br><span class="line">            x=c[i+j-1]/10;</span><br><span class="line">            c[i+j-1]%=10;</span><br><span class="line">        &#125;</span><br><span class="line">        c[i+lenb]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    lenc=lena+lenb;</span><br><span class="line">    while(c[lenc]==0&amp;&amp;lenc&gt;1) lenc--;</span><br><span class="line">    for(int i=lenc;i&gt;=1;i--) cout&lt;&lt;c[i];</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化<br>for (int i &#x3D; 1; i &lt;&#x3D; lena; i++) {：外层循环遍历第一个整数 a 的每一位，从最低有效位（个位）开始，直到最高有效位。<br>x &#x3D; 0;：每次内层循环开始时，将进位 x 重置为 0。<br>内层循环<br>for (int j &#x3D; 1; j &lt;&#x3D; lenb; j++) {：内层循环遍历第二个整数 b 的每一位，同样从最低有效位开始。<br>c[i + j - 1] &#x3D; a[i] * b[j] + x + c[i + j - 1];：计算当前位的乘积 a[i] * b[j]，加上之前的进位 x 和已经存在的 c[i + j - 1] 的值。这是因为高精度乘法的结果可能跨越多个位，需要累加之前的结果。<br>x &#x3D; c[i + j - 1] &#x2F; 10;：计算新的进位。如果 c[i + j - 1] 大于或等于 10，那么需要将十位以上的部分进位到更高一位。<br>c[i + j - 1] %&#x3D; 10;：更新当前位，只保留个位上的数字。<br>处理最后的进位<br>c[i + lenb] &#x3D; x;：在内层循环结束后，如果还有进位 x，则将其添加到 c 数组的下一个位置。<br>示例<br>假设 a &#x3D; 123 和 b &#x3D; 89，那么 lena &#x3D; 3 和 lenb &#x3D; ⅔。我们用数组表示这两个数，从最低有效位开始：</p>
<p>a 数组: [3, 2, 1]<br>b 数组: [9, 8]<br>乘法过程如下：</p>
<p>对于 a[1]（即 3）：<br>c[1 + 1 - 1] &#x3D; 3 * 9 + 0 + 0 &#x3D; 27，x &#x3D; 27 &#x2F; 10 &#x3D; 2，c[1] &#x3D; 27 % 10 &#x3D; 7<br>c[1 + 2 - 1] &#x3D; ¾ * 8 + 2 + 0 &#x3D; 26，x &#x3D; 26 &#x2F; 10 &#x3D; 2，c[2] &#x3D; 26 % 10 &#x3D; 6<br>c[1 + 2] &#x3D; 2（处理最后的进位）<br>对于 a[2]（即 2）：<br>c[2 + 1 - 1] &#x3D; 2 * 9 + 0 + 7 &#x3D; 25，x &#x3D; 25 &#x2F; 10 &#x3D; 2，c[2] &#x3D; 25 % 10 &#x3D; 5<br>c[2 + 2 - 1] &#x3D; 2 * 8 + 2 + 6 &#x3D; 24，x &#x3D; 24 &#x2F; 10 &#x3D; 2，c[3] &#x3D; 24 % 10 &#x3D; 4<br>c[2 + 2] &#x3D; 2（处理最后的进位）<br>对于 a[3]（即 1）：<br>c[3 + 1 - 1] &#x3D; 1 * 9 + 0 + 5 &#x3D; 14，x &#x3D; 14 &#x2F; 10 &#x3D; 1，c[3] &#x3D; 14 % 10 &#x3D; 4<br>c[3 + 2 - 1] &#x3D; 1 * 8 + 1 + 4 &#x3D; 13，x &#x3D; 13 &#x2F; 10 &#x3D; 1，c[4] &#x3D; 13 % 10 &#x3D; 3<br>c[3 + 2] &#x3D; 1（处理最后的进位）<br>最终，c 数组为 [7, 6, 4, 3, 1]，倒序输出就是 10947，这是 123 * 89 的结果。</p>
<p>总结<br>这段代码通过模拟手工乘法的方式，逐步计算每一位的结果，并处理进位，最终得到高精度的乘法结果</p>
<h4 id="4-高精度除法"><a href="#4-高精度除法" class="headerlink" title="4.高精度除法"></a>4.高精度除法</h4><p>与乘法类似的，这里讨论的高精度除法中，被除数是高精度的大数，而除数是一个相对小的数，同样可以用int去除</p>
<p>还需要说明的是，这里的除法还是整数除法，在此种我们输出商和余数</p>
<p>直接看代码吧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; div(vector&lt;int&gt; &amp;a,int b,int &amp;r)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; c;</span><br><span class="line">    for(int i=a.size()-1;i&gt;=0;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        r=r*10+a[i];</span><br><span class="line">        c.push_back(r/b);</span><br><span class="line">        r=r%b;</span><br><span class="line">    &#125;</span><br><span class="line">    //这一段直接自己拿两个数字模拟一下就可以理解了</span><br><span class="line">    reverse(c.begin(),c.end());//在上面的运行过程中，对于c储存的数，高位的数是储存在第一位的，与高精度运算中储存大数的方式相反，故而我们用reverse将其翻转，以达到统一</span><br><span class="line">    while(c.size()&gt;1 &amp;&amp; c.back()==0) c.pop_back();//去掉前导0</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string m; int b;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; b;</span><br><span class="line">    vector&lt;int&gt;  a;</span><br><span class="line">    for(int i=m.length()-1;i&gt;=0;i--) a.push_back(m[i]-&#x27;0&#x27;);</span><br><span class="line">    int r=0;</span><br><span class="line">    auto  c=div(a,b,r); //这个函数返回的是c，但是也会改变r</span><br><span class="line">    for(int i=c.size()-1;i&gt;=0;i--) cout&lt;&lt;c[i];</span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;r;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>高精度的四则运算就大概如此，需要注意的就是让计算机像人一样处理数据的一种思想，同时要多熟练和理解这几个模板</p>
<h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><h4 id="1-一维前缀和"><a href="#1-一维前缀和" class="headerlink" title="1.一维前缀和"></a>1.<strong>一维前缀和</strong></h4><p>首先我们定义一个数组a1,a2,a3,…,an，对于这个数组，有对应的前缀和数组s0,s1,s2,s3,…,sn，其中sn&#x3D;a1+a2+…+an；</p>
<p>即前n个数的和即是sn</p>
<p>需要注意的是，前缀和对应的数组的下标志必须是从1开始数的，且s0是自定义的其为0</p>
<p>前缀和的<strong>求法</strong></p>
<pre><code>        一般的，对于si，si=s[i-1]+a[i]                   （不得不说，就是数列的前n项和那一套东西啊）
</code></pre>
<p>前缀和的<strong>应用</strong>，</p>
<pre><code>        前缀和一般用于快速地得到某一个区间的和           **对于[l,r]的区间和，用s[r]-s[l-1]求得**
</code></pre>
<p>这也就解释了为什么数组的下标要从1开始，并且需要我们自己去定义s0&#x3D;0，因为当我们求[1,10]的和时，实际上就是s10，但为了符合一般规律公式，我们应该写成s[10]-s[0]，其中s[o]&#x3D;0，即就为s10</p>
<p>对前缀和数组的预处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s[0]=0;</span><br><span class="line">for(int i=1;i&lt;=n;i++) s[i]=s[i-1]+a[i];</span><br></pre></td></tr></table></figure>

<p>一维的前缀和十分简单就略过例题吧</p>
<h4 id="2-二维前缀和"><a href="#2-二维前缀和" class="headerlink" title="2.二维前缀和"></a>2.<strong>二维前缀和</strong></h4><p>二维前缀和实际上是在矩阵中求子矩阵的和 对于一个行列都从1开始的二维数组a[i,j]，对应地有s[i,j]来表示子矩阵的和</p>
<p><img src="C:\Users\Lenovo\Desktop\笔记\第一章基础算法.assets\image-20241030210410949.png" alt="image-20241030210410949"></p>
<p>例如，如图是s[3,3]所表示的范围，就是所有被标黄的方格内的数字的和，所以可以看出s[i,j]就是以11为左上角，ij为右下角的矩形</p>
<p>由于矩阵之间可能互相重叠，所以存在多加和多减的问题，需要就情况进行加减</p>
<p><strong>计算前缀和数组</strong></p>
<p><em><strong>s[i,j]&#x3D;s[i-1,j]+s[i,j-1]-s[i-1,j-1]+a[i,j]</strong></em></p>
<p><strong>计算(x1,y1)(x2,y2)这一子矩阵中所有和的值</strong></p>
<p><em><strong>s[x2,y2]-s[x-1,y2]-s[x2,y1-1]+s[x1-1,y1-1]</strong></em></p>
<p>可以画图动态地理解一下，这里太麻烦了就不画了</p>
<h3 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h3><p>差分其实就是前缀和的逆运算</p>
<h4 id="1-一维差分"><a href="#1-一维差分" class="headerlink" title="1.一维差分"></a>1.<strong>一维差分</strong></h4><p>假设有两个数组分别是a1,a2,a3,…,an和b1,b2,b3,…bn，使得ai&#x3D;b1+b2+b3+…+bi</p>
<p>则称a数组是b数组的前缀和，b数组是a数组的差分</p>
<h5 id="差分的应用"><a href="#差分的应用" class="headerlink" title="差分的应用"></a>差分的<strong>应用</strong></h5><p>差分可以运用在需要对a数组中的一段数同时进行加减操作，比如我们要对a数组的l到r都加上一个c</p>
<p>由于a数组是b数组的前缀和，所以，如果我们让b[l]+c就会让a[l]到a[n]的所有数都加上c（因为这个阶段的数实际上都加了这个b[l]），那么为了保证r之后的数没有加c，同理只需要再进行一个操作，即b[r+1]-c,使得r+1到n的数最终没有发生变化。</p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void insert(int l,int r,int c)</span><br><span class="line">&#123;</span><br><span class="line">	b[l]+=c;</span><br><span class="line">	b[r+1]-=c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="差分数组的构造"><a href="#差分数组的构造" class="headerlink" title="差分数组的构造"></a>差分数组的<strong>构造</strong></h5><p>在差分中我们不用去考虑具体是怎么构造的，因为我们如果假设a数组全部为0，那么对应的b数组也全为0，当a数组的每一位i的值发生变化时，就相当于在i与i之间插入了一个值，所以构造差分数组的方法就是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(int i=1;i&lt;=n;i++) insert(i,i,a[i]);</span><br></pre></td></tr></table></figure>

<p>好不容易弄懂了，啰嗦两句，为什么这样插入就能够构造出差分数组呢</p>
<p>因为实际上差分数组的构造是b[i]&#x3D;a[i]-[i-1]，相当于对于每一个位数来说都加了一次减了一次，而这个insert函数中恰好就是一个先加后减的过程，因为左右边界是一样的，所以这次的r+1就会变成下一次的l，同时插入的数又发生了改变，所以这个过程会完全等价于b[i]&#x3D;a[i]-[i-1]</p>
<p>在这里补充一点，如何使差分数组变成它对应的前缀和数组，只需要</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(int i=1;i&lt;=n;i++) b[i]+=b[i-1];</span><br></pre></td></tr></table></figure>

<p>当然啦，也可以继续用a数组去计算，用前缀和的公式即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(int i=1;i&lt;=n;i++) a[i]=a[i-1]+b[i];</span><br></pre></td></tr></table></figure>



<h4 id="2-二维差分"><a href="#2-二维差分" class="headerlink" title="2.二维差分"></a>2.<strong>二维差分</strong></h4><p>同样的，有两个二维数组即两个矩阵，使得a矩阵是b矩阵的前缀和矩阵，那么b矩阵则是a矩阵的差分矩阵</p>
<p>可以与二维前缀和类比，其实就是同样的把运算变成整个矩阵的运算，所以不解释太多</p>
<h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a><strong>应用</strong></h5><p>对于差分矩阵中的b[i,j]+c就相当于把a[[i,j]为左上角的那个矩阵全部加c，与前缀和一维到二维的转化方式是相同的，不赘述了</p>
<p>让前缀和数组中以x1，y1为左上角，x2，y2为右下角的矩阵中的所有数加上c</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void insert(int x1,int y1,int x2,int y2,int c)</span><br><span class="line">&#123;</span><br><span class="line">	b[x1,y1]+=c;</span><br><span class="line">	b[x1,y2+1]-=c;</span><br><span class="line">	b[x2+1,y1]-=c;</span><br><span class="line">	b[x2+1,y2+1]+=c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="构造"><a href="#构造" class="headerlink" title="构造"></a><strong>构造</strong></h5><p>同样进行n，m次插入操作即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(int i =  1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">	for(int j=1;j&lt;=m;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		insert(i,j,i,j,c);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>最后计算前缀和数组某点矩阵的和的形式与前面的前缀和数组中方法完全相同，略过</p>
<h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><p>首先清楚什么是离散化，离散化是指将一个连续的区间转化为一系列离散的点的过程</p>
<p>可以理解为一种思想，即我们在处理大量的连续的区间内的问题时，很多时候其实只有其中的一些点是需要的，那么这时我们就可以把这个连续的区间问题转化为求这些点的问题</p>
<p>那么我们如何处理这些离散的点就是此算法的关键，我们的想法是把这些离散的点（或这些点的坐标）映射成从1到n的有序的区间，从而在这个更小更简单的区间里去分析问题，同时由于其有序性也就可以在这个区间里使用遍历去解决问题</p>
<p>但需要注意的是，映射的过程中，待离散化的元素是可能重复的，比如进行操作的和区间的点重复了，所以每次还需要对这些离散的点进行去重，从而使得映射的值是唯一的。</p>
<p>然后来讨论如何求这个映射的问题，这里的映射实际就是找这些点在区间内的位置，所以可以用二分查找的方法去找到每一个值对应的点的位置</p>
<h4 id="区间和"><a href="#区间和" class="headerlink" title="区间和"></a>区间和</h4><p><img src="C:\Users\Lenovo\Desktop\笔记\第一章基础算法.assets\image-20241105101301168.png" alt="image-20241105101301168"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">typedef pair&lt;int,int&gt; pa; //自定义 pair对 的名称，</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; all;//储存所有需要离散化的值</span><br><span class="line">vector&lt;pa&gt; add,qiu;//储存每次进行的操作，和每一次访问需要求的区间</span><br><span class="line"></span><br><span class="line">const int N = 300010;</span><br><span class="line">int n,m;</span><br><span class="line">int a[N],s[N];</span><br><span class="line">//用于找出需要离散的值的映射</span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">    int l = 0,r = all.size()-1;</span><br><span class="line">    while(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid = l + r &gt;&gt; 1;</span><br><span class="line">        if(all[mid] &gt;= x)  r = mid;</span><br><span class="line">        else l = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return r+1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">//完成读入操作</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for(int i = 0 ; i &lt; n ;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        int x, c;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; c;</span><br><span class="line">        add.push_back(&#123;x,c&#125;);</span><br><span class="line">        all.push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 0 ; i &lt; m ; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        int l,r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        qiu.push_back(&#123;l,r&#125;);</span><br><span class="line">        all.push_back(l);</span><br><span class="line">        all.push_back(r);</span><br><span class="line">    &#125;</span><br><span class="line">//</span><br><span class="line">    sort(all.begin(),all.end());</span><br><span class="line">    all.erase(unique(all.begin(),all.end()),all.end());</span><br><span class="line"></span><br><span class="line">    for(auto item:add)</span><br><span class="line">    &#123;</span><br><span class="line">        int x = find(item.first);</span><br><span class="line">        a[x]+=item.second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i = 1;i &lt;= all.size() ; i ++) s[i]=s[i-1]+a[i];</span><br><span class="line"></span><br><span class="line">    for(auto item : qiu)</span><br><span class="line">    &#123;</span><br><span class="line">        int l = find(item.first);int r = find(item.second);</span><br><span class="line">        cout &lt;&lt; s[r] - s[l-1] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h4><p>区间和并实际上就是一个求并集的过程</p>
<p>即每次当两个区间有交集的时候我们就对这两个区间取并集，把右边界更新成较大的那个</p>
<p><img src="C:\Users\Lenovo\Desktop\笔记\第一章基础算法.assets\image-20241109181504217.png" alt="image-20241109181504217"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef pair&lt;int, int&gt; pp;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">const int N = 400020;  // 这里不需要这么大的常量，可以根据实际情况调整</span><br><span class="line">vector&lt;pp&gt; all;</span><br><span class="line"></span><br><span class="line">// 合并重叠区间</span><br><span class="line">void merge(vector&lt;pp&gt; &amp;all) &#123;</span><br><span class="line">    if (all.empty()) return;</span><br><span class="line"></span><br><span class="line">    // 首先按起点排序</span><br><span class="line">    sort(all.begin(), all.end());</span><br><span class="line"></span><br><span class="line">    vector&lt;pp&gt; res;</span><br><span class="line">    int l = all[0].first, r = all[0].second;</span><br><span class="line"></span><br><span class="line">    for (size_t i = 1; i &lt; all.size(); ++i) &#123;</span><br><span class="line">        if (all[i].first &lt;= r) &#123;</span><br><span class="line">            // 当前区间与之前的区间重叠，更新右端点</span><br><span class="line">            r = max(r, all[i].second);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 当前区间与之前的区间不重叠，将之前的区间加入结果</span><br><span class="line">            res.push_back(&#123;l, r&#125;);</span><br><span class="line">            l = all[i].first;</span><br><span class="line">            r = all[i].second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 加入最后一个区间</span><br><span class="line">    res.push_back(&#123;l, r&#125;);</span><br><span class="line"></span><br><span class="line">    all = res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        int q, p;</span><br><span class="line">        cin &gt;&gt; q &gt;&gt; p;</span><br><span class="line">        all.push_back(&#123;q, p&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 合并重叠区间</span><br><span class="line">    merge(all);</span><br><span class="line"></span><br><span class="line">    // 计算所有燃烧位置的总长度</span><br><span class="line">    int total_length = 0;</span><br><span class="line">    for (const auto &amp;interval : all) &#123;</span><br><span class="line">        total_length += interval.second - interval.first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 输出总长度</span><br><span class="line">    cout &lt;&lt; total_length &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然有些时候我们合并区间后还会添加前缀和等使用，视情况而定即可</p>
<h2 id="第二章数据结构"><a href="#第二章数据结构" class="headerlink" title="第二章数据结构"></a>第二章数据结构</h2><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p>栈和队列都是一种容器。其不同点在于存放的顺序和取用顺序的不同</p>
<p><img src="/%E7%AE%97%E6%B3%95.assets/image-20241112112018641.png" alt="image-20241112112018641"></p>
<p>栈如图1，其元素只能从上口取出，所以先进去的元素会在最后才出来</p>
<p>队列如图2，其元素是从下端掉出的，所以先进去的元素会最先掉出来</p>
<p><strong>用数组模拟栈和队列</strong></p>
<h3 id="1-栈"><a href="#1-栈" class="headerlink" title="1.栈"></a><em>1.栈</em></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//栈的定义</span><br><span class="line">int skt[N];//数组定义栈    int tt; //tt充当记录栈底的指针</span><br><span class="line">//往栈中插入元素</span><br><span class="line">skt[++tt] = x;      //因为元素是从下面涨到上面的</span><br><span class="line">//弹出元素</span><br><span class="line">tt --;</span><br><span class="line">//判断栈是否为空</span><br><span class="line">if(tt&gt;0) not empty</span><br><span class="line">else empty            //即当栈顶还存在时就不为空</span><br><span class="line">//栈顶</span><br><span class="line">skt[tt];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/%E7%AE%97%E6%B3%95.assets/image-20241112164657033.png" alt="image-20241112164657033"></p>
<h3 id="2-队列"><a href="#2-队列" class="headerlink" title="2.队列"></a><em>2.队列</em></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//队列的定义</span><br><span class="line">int q[N]//数组定义队列      int hh,tt//分别表示头和尾，（就是习惯定义上的上和下哦，结合上面的图）,注意队列实在队尾插入其元素，在队头弹出元素</span><br><span class="line">//插入</span><br><span class="line">qq[++tt] = x //队尾，故而指针向下变大</span><br><span class="line">//弹出元素</span><br><span class="line">hh++  //指针右移，前面的元素就被弹出</span><br><span class="line">//判断队列是否为空</span><br><span class="line">if(hh&lt;=tt) not empty</span><br><span class="line">else empty</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/%E7%AE%97%E6%B3%95.assets/image-20241112164440317.png" alt="image-20241112164440317"></p>
<h3 id="3-使用场景的总结"><a href="#3-使用场景的总结" class="headerlink" title="3.使用场景的总结"></a>3.使用场景的总结</h3><p><em><strong>如何在题目背景中抽离出栈和队列的背景？</strong></em></p>
<pre><code>    着重关注题目中元素的剔除方式：如果是先进先出则用队列储存，如果先进后出则用栈储存。
</code></pre>
<h3 id="4-单调栈和单调队列"><a href="#4-单调栈和单调队列" class="headerlink" title="4.单调栈和单调队列"></a><strong>4.单调栈和单调队列</strong></h3><h4 id="1-单调栈"><a href="#1-单调栈" class="headerlink" title="1.单调栈"></a><em>1.单调栈</em></h4><p>单调栈适用的模型是求出数轴上左侧小于x且离x最近的数（右侧同理），<img src="/%E7%AE%97%E6%B3%95.assets/image-20241113154629298.png" alt="image-20241113154629298"></p>
<p>栈元素从顶端弹出，所以我们每次判断顶元素是否大于x，如果大于x就直接弹出，这样可以简便地使整个栈中地元素都是单调递增的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 100020;</span><br><span class="line">int skt[N], tt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for (int i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        while (tt != 0 &amp;&amp; skt[tt] &gt;= x)</span><br><span class="line">            tt--;</span><br><span class="line">        if (tt != 0)</span><br><span class="line">            cout &lt;&lt; skt[tt] &lt;&lt; &quot; &quot;;</span><br><span class="line">        else</span><br><span class="line">            cout &lt;&lt; -1 &lt;&lt; &quot; &quot;;</span><br><span class="line">        skt[++tt] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-单调队列"><a href="#2-单调队列" class="headerlink" title="2.单调队列"></a><em>2.单调队列</em></h4><p><img src="/%E7%AE%97%E6%B3%95.assets/Pig.png"></p>
<h2 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h2><p>Trie树是一种高效存储和查找字符串集合的数据结构，其用类似树枝的方式来储存字符串元素，即每一个节点后可能有若干个子节点，（最初的一个节点称为根节点），最后每一条路径就代表一个储存的字符串，同时，对于每一个字符串结束的节点可以做一个标记方便进行查询操作</p>
<p>大概的图示如下</p>
<p><img src="/%E7%AE%97%E6%B3%95.assets/image-20241118102053450.png" alt="image-20241118102053450"></p>
<p> 一道应用的例题，维护一个字符串集合，支持插入字符串x和查询字符串出现次数的操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//对于一个字母组成的字符串，可以考虑将字母a~z映射成数字的0~25</span><br><span class="line">//我们用p来记录当前节点，son数组来记录这个节点上的元素，idx用来记录当前使用的下标，下标是0的点既是根节点又是空节点</span><br><span class="line">const int N = 100010;</span><br><span class="line">int son[N][26], cnt[N], idx;</span><br><span class="line"></span><br><span class="line">//插入操作</span><br><span class="line">void insert(char str[])</span><br><span class="line">&#123;</span><br><span class="line">    int p = 0;//从根节点开始</span><br><span class="line">    for (int i = 0; str[i];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int u = str[i] - &#x27;a&#x27;;//映射过程</span><br><span class="line">        if(!son[p][u])//如果不存在这个子节点</span><br><span class="line">            son[p][u] = ++idx;//那么就创造一个子节点，++idx让它有儿子</span><br><span class="line">        p = son[p][u];//遍历到下一个字母节点的下标去</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]++;//最后结束循环时的终点就是出现了一次，打上一个标记</span><br><span class="line">&#125;</span><br><span class="line">//查询操作</span><br><span class="line">int  query(char str[])</span><br><span class="line">&#123;</span><br><span class="line">    int p = 0;</span><br><span class="line">    for (int i = 0; str[i];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int u = str[i] - &#x27;a&#x27;;</span><br><span class="line">        if(!son[p][u])</span><br><span class="line">            return 0;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>从这里可以看出trie树高效的原因在于其让前缀相同的字符串共用前缀从而提高了效率</p>
<p>在这里介绍一个有意思的地方，根据树的性质会发现它在储存二进制数字时有优势（相当于只由01构成的字符串）所以从某种程度上来讲，树能够用来储存计算机中的一切信息</p>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>trie树的另一个重要的操作是并查集，即两种操作，一是将编号为a和b的两个数所在的集合合并到有个集合中，二是查询编号为a，b的两个数是否在同一个集合中</p>
<p><img src="/%E7%AE%97%E6%B3%95.assets/image-20241118171513171.png" alt="image-20241118171513171"></p>
<p><strong>问题4：针对问题2的路径压缩优化 ：</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">	if(p[x]!=x) p[x] = find(p[x]);</span><br><span class="line">	return p[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>由上可以看出树中元素的关系是相互的，对于任意一个元素，我们既可以去寻找它的子节点也可以寻找它的父节点，区别是一个是创造路径，一个是对已有的树集合进行查找。–&gt;<em>见并查集操作</em></p>
<p>trie树可以用来作为集合来便于研究，一般地我们用根节点来做它的编号–&gt;<em>见合并集合</em></p>
<h3 id="种类并查集"><a href="#种类并查集" class="headerlink" title="种类并查集"></a>种类并查集</h3><p>当题目中的元素之间有不同的关系时（如敌人和朋友），我们可以将原始的并查集扩大n倍（如果有n种关系），那么每一种并查集的含义都不一样，最后我们通过对每一个节点的父节点的比较来确定它们是什么关系。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//假设有n个元素,关系分为本身，猎物，天敌</span><br><span class="line">for(int i = 1 ;i &lt;= 3*n;i++)</span><br><span class="line">&#123;</span><br><span class="line">	p[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">//假设这里的三种关系分别是本身，猎物与天敌，那么x为本身，x+n为猎物，x+2*n即为天敌</span><br></pre></td></tr></table></figure>

<h4 id="注意对关系之间的处理"><a href="#注意对关系之间的处理" class="headerlink" title="注意对关系之间的处理"></a>注意对关系之间的处理</h4><p>关系一般是相互的，当我们确定了两种元素的关系之后，就要去合并对应的两棵树从而满足关系</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//比如我们已知了x吃y，那么需要合并的关系如下</span><br><span class="line">merge(x,y+2*n);//x是y的天敌</span><br><span class="line">merge(x+n,y);//x的猎物是y</span><br><span class="line">merge(x+2*n,y+n);//x的天敌是y的猎物（环形关系）</span><br></pre></td></tr></table></figure>





<h3 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h3><h4 id="Q1-定义"><a href="#Q1-定义" class="headerlink" title="Q1 定义"></a>Q1 定义</h4><p>在对并查集进行路径压缩和合并操作时，这些权值具有一定属性，即可将他们与父节点的关系，变化为与所在树的根结点关系。</p>
<p>也就是说。权值代表着当前节点和父节点之前的关系（即使经过了路径压缩），所以我们可以通过该节点与父节点这几件的关系来表示同一棵树下两个节点的关系。</p>
<h4 id="Q3权值到底代表了什么"><a href="#Q3权值到底代表了什么" class="headerlink" title="Q3权值到底代表了什么"></a>Q3权值到底代表了什么</h4><p>在题目对元素进行了种类的划分后，我们可以用权值的不同来区分种类的不同从而完成对种类的分辨。</p>
<p>故而这也是对种类并查集的一种处理方法。</p>
<h4 id="Q2权值的转移"><a href="#Q2权值的转移" class="headerlink" title="Q2权值的转移"></a>Q2权值的转移</h4><p>在合并操作中不能把权值直接进行赋值，而应该先推出需合并的两个节点a，b各自与根之间的关系才能实现树权值的连接</p>
<p><img src="/%E7%AE%97%E6%B3%95.assets/image-20241130142002673.png" alt="image-20241130142002673"></p>
<p>而权值应该根据题目的要求而确定。</p>
<blockquote>
<p>是的</p>
<p>好无聊</p>
<p>现在只能看你的笔记了</p>
<p>还可以帮你改改错</p>
</blockquote>
<h4 id="详见洛谷P2024食物链"><a href="#详见洛谷P2024食物链" class="headerlink" title="详见洛谷P2024食物链"></a>详见洛谷P2024食物链</h4><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="1-堆的定义"><a href="#1-堆的定义" class="headerlink" title="1.堆的定义"></a>1.堆的定义</h3><p>堆实际上是一个完全二叉树，完全二叉树的意思是除了最后一排节点之外，每一个节点都不为空并且每一个节点都含有两个子节点，并且最后一排节点从左到右顺序排列</p>
<p>堆分为小根堆和大根堆，小根堆的含义为根节点为整个堆中的最小值，并且从上到下元素逐渐变大；大根堆的含义是根节点为整个堆中的最大值，并且从上到下元素逐渐变小</p>
<h3 id="2-根的存储"><a href="#2-根的存储" class="headerlink" title="2.根的存储"></a>2.根的存储</h3><p>根是用一维数组储存的，存储规则如下</p>
<p><img src="/%E7%AE%97%E6%B3%95.assets/image-20241119112637430.png" alt="image-20241119112637430"></p>
<p>故对于每一个堆我们用一维数组h[n]来定义，用size来记录这个堆或者说这个数组的长度</p>
<p>这种特殊的存储方式决定了堆的更改，添加，删除操作，即在数组的末尾进行元素的更改即可，详见下</p>
<h3 id="3-堆的操作"><a href="#3-堆的操作" class="headerlink" title="3.堆的操作"></a>3.堆的操作</h3><pre><code> 首先介绍实现堆的各种操作的*两个基本操作*，up和down  ，up即是让某个元素（或节点）向上调整，down即是让某个元素（或节点）向下调整
</code></pre>
<p><strong>Q1如何实现down操作：</strong></p>
<p>为了维护小根堆的从上到下元素从小到大的性质，我们在每一次down之前先找到该节点和它的两个子节点之间的最小值，再把这个最小值和这个元素交换，一直到无法操作即最小值就是这个元素为止</p>
<p>需要注意的是每次down操作的索引是脚标而不是元素的值哦</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void down(int u)</span><br><span class="line">&#123;</span><br><span class="line">	int t = u;</span><br><span class="line">	if(u*2&lt;=size&amp;&amp;h[u*2]&lt;h[t]) t = u*2;</span><br><span class="line">	if(u*2+1&lt;=size&amp;&amp;h[u*2+1]&lt;h[t]) t = u*2 + 1;</span><br><span class="line">	if(u != t)</span><br><span class="line">	&#123;</span><br><span class="line">		swap(h[u],h[t]);</span><br><span class="line">		down(t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p><strong>Q2如何实现up操作</strong>：</p>
<p>基本逻辑原理同上，唯一不同的是，我们要让小的数往上走，需要判断往上走到什么时候</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void up(int u)</span><br><span class="line">&#123;</span><br><span class="line">	while(u / 2 &amp;&amp; h[u / 2]&gt;h[u])</span><br><span class="line">	&#123;</span><br><span class="line">		swap(h[u/2],h[u]);</span><br><span class="line">		u/=2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-堆中的一些元素处理"><a href="#4-堆中的一些元素处理" class="headerlink" title="4.堆中的一些元素处理"></a>4.堆中的一些元素处理</h3><p>Q1插入一个数   </p>
<p>由于在数组中储存，所以加在末位最方便</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">heap[++size] = x;</span><br><span class="line">up(size);</span><br></pre></td></tr></table></figure>

<p>Q2求集合中的最小值</p>
<p>对于小根堆当然最小值就是根节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heap[1];</span><br></pre></td></tr></table></figure>

<p>Q3删除最小值</p>
<p>这里的删除其实是用覆盖来实现的，即我们让最后一个值覆盖第一个值，然后再把原来的最后一个值删去，就达到了删除最小值的要求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">heap[1] = h[size];</span><br><span class="line">size -- ;</span><br><span class="line">down(1);</span><br></pre></td></tr></table></figure>

<p>Q4删除任意一个元素</p>
<p>同理用覆盖法实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">heap[k] = heap[size];</span><br><span class="line">size -- ;</span><br><span class="line">down(k);</span><br></pre></td></tr></table></figure>

<p>Q5修改任意一个元素</p>
<p>与前面不同的点在于，前面的点用最后一个值覆盖，故一定比原数大，为维护堆的性质只需要down一遍就可以了</p>
<p>而这里任意的修改大小不一定，所以我们选择down一遍再up一遍，其二只会执行一个，这样不管如何都会维持堆的性质</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">heap[k] = x;</span><br><span class="line">dowm(k);</span><br><span class="line">up(k);</span><br></pre></td></tr></table></figure>



<p>特殊情况是当我们需要对第k个插入的元素进行处理时，需要额外维护两个数组，第一个数组用来记录插入顺序k指向的堆中的位置（即元素的下标），第二个数组用来记录堆中的元素的值对应的插入顺序</p>
<p>必须用两个相互的数组记录的原因是为了让堆在进行down和up操作的时候不会扰乱插入顺序与元素之间的关系</p>
<p>因此，在这样的情况下需要自己定义一个swap来进行交换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void heap_swap(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">	swap(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">	swap(hp[a],hp[b]);</span><br><span class="line">	swap(h[a],h[b]);</span><br><span class="line">&#125;</span><br><span class="line">//在上述的各种操作中将swap转化为heap_swap即可</span><br></pre></td></tr></table></figure>

<p>还需要补充一下在插入过程中怎么维护这几个数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int size,m = 0;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">ph[m] = size; hp[size] = m;</span><br><span class="line">h[size] = x;</span><br><span class="line">up(size);</span><br></pre></td></tr></table></figure>

<h3 id="对顶堆"><a href="#对顶堆" class="headerlink" title="对顶堆"></a>对顶堆</h3><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>  顾名思义，链表就像一条链子一样排布，故特点是每一个节点与前后的关系，并且可以单独分析每一个节点</p>
<h3 id="链表的主要作用"><a href="#链表的主要作用" class="headerlink" title="链表的主要作用"></a>链表的主要作用</h3><h4 id="1-单链表-邻接表-用来储存树和图"><a href="#1-单链表-邻接表-用来储存树和图" class="headerlink" title="1.单链表-&gt;邻接表-&gt;用来储存树和图"></a>1.单链表-&gt;邻接表-&gt;用来储存树和图</h4><h4 id="2-双链表-用来优化某些问题"><a href="#2-双链表-用来优化某些问题" class="headerlink" title="2.双链表-&gt;用来优化某些问题"></a>2.双链表-&gt;用来优化某些问题</h4><p>链表上给的数据存储结构单元就是<strong>节点</strong>，类似于数组中的位置。</p>
<p>每一个节点会包含：</p>
<p>1.它自身储存的数据</p>
<p>2.一个或两个用来指向下一个或上一个节点位置的链接</p>
<p>（在单向链表中，节点只记录后一节点的链接，而双向链表则前后都有）</p>
<h3 id="用指针实现的链表"><a href="#用指针实现的链表" class="headerlink" title="用指针实现的链表"></a>用指针实现的链表</h3><p>我们一般用struct结构体 来存储链表节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node&#123;</span><br><span class="line">	int value;</span><br><span class="line">	Node *next;//指针来记录链接</span><br><span class="line">	//如果是双向链表的话</span><br><span class="line">	Node *prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="一，单向链表"><a href="#一，单向链表" class="headerlink" title="一，单向链表"></a><strong>一，单向链表</strong></h4><h4 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h4><p>头节点指针赋值为空</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node *head = NULL;//NULL指针表示空节点，时标准库中值为0的一个常量</span><br></pre></td></tr></table></figure>

<h4 id="2-单向链表的方式"><a href="#2-单向链表的方式" class="headerlink" title="2.单向链表的方式"></a>2.单向链表的方式</h4><p>是从head节点开始到NULL指针结束，每个节点记录下一个节点是谁的数据结构</p>
<h4 id="3-单向链表的插入"><a href="#3-单向链表的插入" class="headerlink" title="3.单向链表的插入"></a>3.单向链表的插入</h4><p>Q1如何在某个节点后添加一个节点</p>
<p>与上面说的同理，其实就是在两个链接间重建新的链接给它们搭一个桥，由于是单向的故我们只需要改变next指针即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void Insert(Node *p.Node *now)//在p节点后插入now节点</span><br><span class="line">&#123;</span><br><span class="line">	now-&gt;next = p-&gt;next;</span><br><span class="line">	p-&gt;next = now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Q2如何在头节点前插入节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void Insert(Node *now)</span><br><span class="line">&#123;</span><br><span class="line">	now-&gt;next = head;</span><br><span class="line">	head = now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-单链表的删除"><a href="#4-单链表的删除" class="headerlink" title="4.单链表的删除"></a>4.单链表的删除</h4><p>Q1在p节点之后删除now节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void Delete(Node *p.Node *now)</span><br><span class="line">&#123;</span><br><span class="line">	p-&gt;next = now-&gt;next;</span><br><span class="line">	now-&gt;next = NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Q2删除第一个节点（头节点）</p>
<p>直接改变头指针即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void Delete()</span><br><span class="line">&#123;</span><br><span class="line">		head = head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-链表的构建"><a href="#5-链表的构建" class="headerlink" title="5.链表的构建"></a><strong>5.链表的构建</strong></h4><p>现在以按顺序排列几个数字为例子来用链表解决问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Node&#123;</span><br><span class="line">    int value;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125; a[81], *head;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for (int i = 0; i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i].value;</span><br><span class="line">        if(head == NULL || a[i].value &lt; head-&gt;value)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i].next = head;</span><br><span class="line">            head = &amp;a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            for (Node *p = head; p; p = p-&gt;next)</span><br><span class="line">            &#123;</span><br><span class="line">                if(p-&gt;value&lt;a[i].value&amp;&amp;(p-&gt;next == NULL || p-&gt;next-&gt;value&gt;a[i].value))</span><br><span class="line">                &#123;</span><br><span class="line">                    a[i].next = p-&gt;next;</span><br><span class="line">                    p-&gt;next = &amp;a[i];</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (Node *p = head; p;p = p-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; p-&gt;value &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在用指针实现链表的时候重要的还是厘清指针与数值之间的关系以及指向，并且恰当地表示</p>
<h3 id="二，双向链表"><a href="#二，双向链表" class="headerlink" title="二，双向链表"></a>二，双向链表</h3><p>与单向链表最大的区别就是它会记录指向后面的指针和指向前面的指针</p>
<p>双向链表的所有操作中与单项联编不同的点就是需要额外去维护这个节点指向前面的prev指针，其他是完全同理的操作</p>
<h4 id="1-初始化-1"><a href="#1-初始化-1" class="headerlink" title="1.初始化"></a>1.<strong>初始化</strong></h4><p>除了头节点指针赋值为空外，也需要维护尾节点指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node *head = NULL,*tail = NULL;</span><br></pre></td></tr></table></figure>

<h4 id="2-在p节点后插入now节点"><a href="#2-在p节点后插入now节点" class="headerlink" title="2.在p节点后插入now节点"></a><strong>2.在p节点后插入now节点</strong></h4><p>与单链表插入的区别只在于要重新维护一个prev指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void Insert(Node *p,Node *now)</span><br><span class="line">&#123;</span><br><span class="line">	Node *q = p-&gt;next;</span><br><span class="line">	p-&gt;next = now; now-&gt;prev = p;</span><br><span class="line">	now-&gt;next = q;q-&gt;prev = now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在头节点前插入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void Insert(Node *now)</span><br><span class="line">&#123;</span><br><span class="line">	now-&gt;next = head;</span><br><span class="line">    head-&gt;prev = now;</span><br><span class="line">    head = now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在尾节点后插入也是完全同理的操作，只是维护的顺序不一样而已（一个插在前面一个插在后面）</p>
<h4 id="3-删除一个now节点"><a href="#3-删除一个now节点" class="headerlink" title="3.删除一个now节点"></a>3.删除一个now节点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void Delete(Node *now)</span><br><span class="line">&#123;</span><br><span class="line">	Node *p = now-&gt;prev,*q = now-&gt;next;</span><br><span class="line">	p-&gt;next = q;</span><br><span class="line">	q-&gt;prev = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除尾节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void Delete(Node *now)</span><br><span class="line">&#123;</span><br><span class="line">	tail = now-&gt;prev;</span><br><span class="line">	tail-&gt;next = NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除头节点也完全同理，只是改变的是它的next指针而已</p>
<h3 id="三，循环链表"><a href="#三，循环链表" class="headerlink" title="三，循环链表"></a>三，循环链表</h3><p>即在单向链表的基础上将最后一个节点的next指针指向头节点，如果是双向链表的话就再将头节点的prev指向最后一个节点，从而行成的一个环状结构</p>
<p>循环链表正如其形状，最适用在环形问题上，如约瑟夫环</p>
<h3 id="用数组模拟实现的链表"><a href="#用数组模拟实现的链表" class="headerlink" title="用数组模拟实现的链表"></a>用数组模拟实现的链表</h3><h4 id="一，单向链表-1"><a href="#一，单向链表-1" class="headerlink" title="一，单向链表"></a>一，单向链表</h4><h5 id="1-模拟方式"><a href="#1-模拟方式" class="headerlink" title="1.模拟方式"></a>1.模拟方式</h5><p>同样地需要定义头节点，每个节点的value，和指向下一项的指针，但不同的是value和指针我们都分别用数组来实现，它们之间的联系用下标来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const int N = 100010;</span><br><span class="line">int head,e[N],ne[N],idx;</span><br><span class="line">//head表示链表的头节点，数组e用来储存每个点的值，数组ne用来记录每个节点的next指针，idx作为一个索引指针，表示现在用到了哪一个点</span><br></pre></td></tr></table></figure>

<p>从head指向的第一个节点开始，从0开始计数，这个计数就是这个节点的下标。最后一个节点指向的空节点令为-1.</p>
<p>对于头节点head来说，它的值即是它指向的节点的下标，所以初始化为-1是因为此时指向的是空节点。在对head进行赋值时，一般使用的是索引指针idx。</p>
<h5 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2.初始化"></a>2.初始化</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void chu()</span><br><span class="line">&#123;</span><br><span class="line">	head = -1;</span><br><span class="line">	idx = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-插入操作"><a href="#3-插入操作" class="headerlink" title="3.插入操作"></a>3.插入操作</h5><p>   <strong>在头节点后插入一个节点</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void addtohead(int x)</span><br><span class="line">&#123;</span><br><span class="line">	e[idx] = x;</span><br><span class="line">	ne[idx] = head;</span><br><span class="line">	head = idx;</span><br><span class="line">	idx ++;//表示当前节点已经使用过了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>**在下标为k的点后插入一个点**
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void add(int k,int x)</span><br><span class="line">&#123;</span><br><span class="line">	e[idx] = x;</span><br><span class="line">	ne[idx] = ne[k];</span><br><span class="line">	ne[k] = idx;</span><br><span class="line">	idx ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-删除操作"><a href="#4-删除操作" class="headerlink" title="4.删除操作"></a>4.删除操作</h5><pre><code>**在下标为k的点后删除节点**
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void delete(int k)</span><br><span class="line">&#123;</span><br><span class="line">	ne[k] = ne[ne[k]];//让它直接指向下下个就行了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二，双向链表-1"><a href="#二，双向链表-1" class="headerlink" title="二，双向链表"></a>二，双向链表</h4><p>同样地，双向链表与单向链表的差别就是会同时维护左指针和右指针，我们只需要多开一个数组来表示左指针（前指针即可）</p>
<h5 id="1-模拟方式-1"><a href="#1-模拟方式-1" class="headerlink" title="1.模拟方式"></a>1.模拟方式</h5><p>在这里为了方便，就不单独定义头节点和尾节点，而是用下标为0和1的两个点来表示边界即头节点和尾节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const int N = 100010;</span><br><span class="line">int e[N],l[N],r[N],idx;</span><br><span class="line">//数组e用来储存每个点的值，数组r用来记录每个节点的next指针，数组l用来记录每个节点的prev指针，idx作为一个索引指针，表示现在用到了哪一个点</span><br></pre></td></tr></table></figure>

<h5 id="2-初始化-1"><a href="#2-初始化-1" class="headerlink" title="2.初始化"></a>2.初始化</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void chu()</span><br><span class="line">&#123;</span><br><span class="line">	//0表示左端点，1表示右端点</span><br><span class="line">	r[0] = 1,l[1] = 0;</span><br><span class="line">	idx = 2;//01已经被占用了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于在这里没有单独去令头尾节点，所以后面的几种操作我们都只介绍在下标为k的点左右进行操作进行即可。</p>
<h5 id="3-插入操作-1"><a href="#3-插入操作-1" class="headerlink" title="3.插入操作"></a>3.插入操作</h5><pre><code>**在下标为k的点右边插入一个点**
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void add(int k,int x)</span><br><span class="line">&#123;</span><br><span class="line">	e[idx] = x;</span><br><span class="line">	r[idx] = r[k];</span><br><span class="line">	l[idx] = k;</span><br><span class="line">	l[r[k]] = idx;</span><br><span class="line">	r[k] = idx;</span><br><span class="line">//一定要注意改变的顺序</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们只需要调用这个函数就可以实现<strong>在这个节点 的左边插入一个点</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void add(l[k],int x);</span><br></pre></td></tr></table></figure>



<h5 id="4-删除操作-1"><a href="#4-删除操作-1" class="headerlink" title="4.删除操作"></a>4.删除操作</h5><pre><code>**在下标为k的点后删除节点**
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void delete(int k)</span><br><span class="line">&#123;</span><br><span class="line">	r[l[k]] = r[k];</span><br><span class="line">	l[r[k]] = l[k];</span><br><span class="line">	//同样地，只需要忽略被删除的点即可</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在做链表相关的问题中，我们画出链表的图，就能理解以上这些操作的逻辑，也能便于自己写出来这些操作了。</p>
<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>哈希函数实际上就是把一些想要查询的东西映射成一些更便于查找（一般就是数字）的函数</p>
<p>可以将想要查询的那个大集合映射到一个小集合中，这个小集合储存到数组中，就称为哈希表</p>
<h3 id="2-值冲突解决方法"><a href="#2-值冲突解决方法" class="headerlink" title="2.值冲突解决方法"></a>2.值冲突解决方法</h3><p>由于哈希是用某种关系让值映射到一个数组，故而有可能不同的数字会映射到同一个结果上去，故而需要处理这样的值冲突</p>
<h4 id="Plan-A-跳过法"><a href="#Plan-A-跳过法" class="headerlink" title="Plan A 跳过法"></a>Plan A 跳过法</h4><p>发生冲突后往后找到第一个空位置插入值。可以定义这样的函数没让每次插入的位置往后＋任意的固定值</p>
<p>但这样的方法在面对一个很满的哈希表时，会耗费大量的时间复杂度在搜素空值上，这也就失去了哈希表的意义，所以一般我们不采用这样的方法</p>
<h4 id="Plan-B-容器法"><a href="#Plan-B-容器法" class="headerlink" title="Plan B  容器法"></a>Plan B  容器法</h4><p>为了让哈希表里的每个位置都能储存多个值，可以在每个位置都开一个容器来使得位置上可以储存多个值，这里可以开一张链表，更好地，可以开一个vector简单地处理这种动态储存空间</p>
<h3 id="3-哈希函数的设计"><a href="#3-哈希函数的设计" class="headerlink" title="3.哈希函数的设计"></a>3.哈希函数的设计</h3><p>（偏理论，看看得了）</p>
<p><img src="/%E7%AE%97%E6%B3%95.assets/image-20241125201633226.png" alt="image-20241125201633226"></p>
<h3 id="4-字符串哈希"><a href="#4-字符串哈希" class="headerlink" title="4.字符串哈希"></a>4.字符串哈希</h3><h4 id="1-用哈希函数将字符串转化为数字"><a href="#1-用哈希函数将字符串转化为数字" class="headerlink" title="1.用哈希函数将字符串转化为数字"></a>1.用哈希函数将字符串转化为数字</h4><p>对于字符串<img src="/%E7%AE%97%E6%B3%95.assets/image-20241125203146729.png" alt="image-20241125203146729"></p>
<p>哈希函数如下</p>
<p><img src="/%E7%AE%97%E6%B3%95.assets/image-20241125203118362.png" alt="image-20241125203118362"></p>
<p>代码实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int Hash(char s[],int n)</span><br><span class="line">&#123;</span><br><span class="line">	int res = 0;</span><br><span class="line">	for(int i = 1;i&lt;=n;i++) res = (res * base + (s[i]-&#x27;a&#x27;+1))%p;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-函数的解释"><a href="#2-函数的解释" class="headerlink" title="2.函数的解释"></a>2.函数的解释</h4><p>ci跟字符串每个位置上字母有关的数字，一般地我们可以把a到z地数字映射到1~26（这也就是为什么上面会(s[i]-‘a’+1)）</p>
<p> base是指定的数1，一般是一个大于字符串中字符数量（大于ci的最大值）的素数，一般可以取101，137等等</p>
<p>p也是一个自己指定的数，一般是一个比较大的数，如可以取9999954</p>
<p>一般地，当两个字符串的哈希值相同的时候，我们可以认为这两个字符串相同，不用一位一位地进行比较，可以节省时间</p>
<h4 id="3-求任意片段子串的哈希值"><a href="#3-求任意片段子串的哈希值" class="headerlink" title="3.求任意片段子串的哈希值"></a>3.求任意片段子串的哈希值</h4><p>以上哈希函数的定义的好处是我们可以使用类似于前缀和的思想快速地得到任意子串的哈希值</p>
<p>First </p>
<p>用a数组记录下计算Hash（c）的中间过程。即</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i] = 	Hash(s1s2...si);</span><br></pre></td></tr></table></figure>

<p>那么对于任意子串 s[l,r] &#x3D; s[l] s[l+1]…s[r] 的哈希值为</p>
<p><img src="/%E7%AE%97%E6%B3%95.assets/image-20241125205712064.png" alt="image-20241125205712064"></p>
<p>代码实现如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int Hash(char s[],int n)</span><br><span class="line">&#123;</span><br><span class="line">	int res = 0;</span><br><span class="line">	for(int i = 0;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		res = (res * base + (s[i]-&#x27;a&#x27;+1))%p;</span><br><span class="line">		a[i] = res;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int partHash(int l ,int r)</span><br><span class="line">&#123;</span><br><span class="line">	int t = a[l-1] * pow(base,r-l+1)%p;</span><br><span class="line">	return (a[r]-t+p)%p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-stl库中的hash"><a href="#5-stl库中的hash" class="headerlink" title="5.stl库中的hash"></a>5.stl库中的hash</h3><p>在cpp的stl库中有一个数据结构unordered_map可以用来实现大多数的哈希表操作，主要原因是它可以很方便的在两个不同类型的元素之间建立起映射关系</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;K.V&gt; hash//这里是自定义的名称</span><br></pre></td></tr></table></figure>

<p>其中K为要储存的关键字信息的类型，V为与它相关联的一些信息的类型（即映射到的）</p>
<p>比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;string,int&gt; hash;</span><br><span class="line"></span><br><span class="line">int query(string name)&#123; //查询被查找人的映射值</span><br><span class="line">	if(hash.find(name) == hash.end) ...//这说明在hash表中没有这个人</span><br><span class="line">	return hash[name]; //会返回映射值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	hash[&quot;ningning&quot;] = 22;</span><br><span class="line">	hash[&quot;tutu&quot;] = 33;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>unordered_map中的key值默认支持int double char string key vector等类型。（其他的类型可以自己先写一些函数来处理，在这里不做扩展了）</p>
<h2 id="stl库中的数据结构"><a href="#stl库中的数据结构" class="headerlink" title="stl库中的数据结构"></a>stl库中的数据结构</h2><p><img src="/%E7%AE%97%E6%B3%95.assets/image-20241130162439962-17449471603344.png" alt="image-20241130162439962"></p>
<h2 id="第三章搜索与图论"><a href="#第三章搜索与图论" class="headerlink" title="第三章搜索与图论"></a>第三章搜索与图论</h2><h2 id="树和图的存储（邻接表）"><a href="#树和图的存储（邻接表）" class="headerlink" title="树和图的存储（邻接表）"></a>树和图的存储（邻接表）</h2><p>这里不多说</p>
<p>主要就是在一个数组中存储多个链表</p>
<p>后面题目会涉及到存储</p>
<p><strong>存储方式主要是头插法</strong></p>
<p> #include <iostream>  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;  </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;<span class="comment">// h为头指针，因为有多个链表所以有多个头  </span></span><br><span class="line"><span class="comment">// 这个链表表示某个数可以直接到哪个数  </span></span><br><span class="line"><span class="comment">//比如1可以直接到3，4在链表表示1-&gt;3-&gt;4  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;<span class="comment">// a为头，b为存的值  </span></span><br><span class="line">    e[idx] = b;  </span><br><span class="line">    ne[idx] = h[a];  </span><br><span class="line">    h[a] = idx++;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);  </span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>



<h2 id="1-DFS"><a href="#1-DFS" class="headerlink" title="1.DFS"></a>1.DFS</h2><p>什么是DFS？</p>
<p>DFS 通常指的是深度优先搜索（Depth-First Search），这是一种用于遍历或搜索树或图的算法。这种算法从根节点（在图的情况下，可以从任意一个顶点开始）开始，尽可能深地探索每个分支，直到达到无法继续深入为止，然后回溯到上一个节点并探索新的路径。这个过程会一直重复，直到所有的节点都被访问过。</p>
<p>有点递归的感觉</p>
<p>将过程想象成一棵树，每种情况都是一个分支</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/844/">842. 排列数字 - AcWing题库</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10</span>;  </span><br><span class="line"><span class="type">int</span> n;  </span><br><span class="line"><span class="type">int</span> path[N];  </span><br><span class="line"><span class="type">bool</span> st[N];  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="comment">//输出  </span></span><br><span class="line">    <span class="keyword">if</span>(u==n)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,path[i]);  </span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line"></span><br><span class="line"><span class="comment">//多分枝搜索  </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span>(!st[i])  </span><br><span class="line">    &#123;  </span><br><span class="line">        path[u]=i;  </span><br><span class="line">        st[i]=<span class="literal">true</span>;  </span><br><span class="line">        <span class="comment">//往下递归  </span></span><br><span class="line">        <span class="built_in">dfs</span>(u<span class="number">+1</span>);  </span><br><span class="line">        <span class="comment">//恢复现场  </span></span><br><span class="line">        st[i]=<span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    cin&gt;&gt;n;  </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-BFS"><a href="#2-BFS" class="headerlink" title="2.BFS"></a>2.BFS</h2><p>BFS是广度优先搜索（Breadth-First Search）的缩写，它是一种用于遍历或搜索树或图的算法。这种算法从根节点（在图的情况下，可以是从任意一个顶点开始）开始，然后探索所有与之相邻的节点，之后再对这些节点中未被访问过的邻居进行同样的操作，直到遍历完所有可达的节点。</p>
<p>也就是说对一个点相邻的未被访问过的点进同样的操作，直到遍历完所有点</p>
<p>bfs有一个队列的性质</p>
<p>把每个点存进去然后找这个点的相邻未访问过的点存到队列里然后把队头出队 如此反复</p>
<p>可以看看b站视频演示<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1uCH1eoEYP?t=119.9">https://www.bilibili.com/video/BV1uCH1eoEYP?t=119.9</a></p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/846/">844. 走迷宫 - AcWing题库</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;   </span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">110</span>;  </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;  </span><br><span class="line"><span class="type">int</span> g[N][N];<span class="comment">// g是给的地图  </span></span><br><span class="line"><span class="type">int</span> d[N][N];<span class="comment">// d表示到初始位置的“距离”  </span></span><br><span class="line">PII q[N*N];<span class="comment">// q存的是点的位置的一个队列  </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;  </span><br><span class="line">    q[<span class="number">0</span>]=&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;  </span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);  </span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">// 初始位置（0，0）的距离是0  </span></span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;<span class="comment">// 走迷宫走的四个方向的x， y变化的所有可能性  </span></span><br><span class="line">    <span class="keyword">while</span> (hh&lt;=tt)   </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">auto</span> t = q[hh++];  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++)   </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="type">int</span> x = t.first + dx[i], y = t.second + dy[i];<span class="comment">// 求出下一个点的坐标  </span></span><br><span class="line">            <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m &amp;&amp; g[x][y] == <span class="number">0</span> &amp;&amp; d[x][y] == <span class="number">-1</span>)   </span><br><span class="line">                <span class="comment">// d[x][y] == -1表示当前点未被访问过  </span></span><br><span class="line">            &#123;  </span><br><span class="line">                d[x][y] = d[t.first][t.second] + <span class="number">1</span>;  </span><br><span class="line">                q[++tt] = &#123;x, y&#125;;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> d[n<span class="number">-1</span>][m<span class="number">-1</span>];  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++)cin &gt;&gt; g[i][j]; <span class="comment">// 读入  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-拓扑排序"><a href="#3-拓扑排序" class="headerlink" title="3.拓扑排序"></a>3.拓扑排序</h2><p>每条边起点在终点的前面的序列就是拓扑序列</p>
<p>此时1 2 3就是拓扑序列</p>
<p><strong>有向无环图（也叫做拓扑图）一定存在拓扑序列</strong></p>
<p>度数的概念：</p>
<p><strong>入度就是一个点有多少条边指向自己，出度就是一个点有几条边出去</strong></p>
<p>本题就是求出其中的拓扑序列</p>
<p>这里主要用BFS实现</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/850/">848. 有向图的拓扑序列 - AcWing题库</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;  </span><br><span class="line"><span class="type">int</span> n, m;  </span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;<span class="comment">// 这里跟下面的add函数就是邻接表用于存储一个图  </span></span><br><span class="line"><span class="type">int</span> q[N], d[N];<span class="comment">// d表示每个点入度的个数  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    e[idx] = b;  </span><br><span class="line">    ne[idx] = h[a];  </span><br><span class="line">    h[a] = idx++;  </span><br><span class="line"> &#125;   </span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">topsort</span> <span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(!d[i])q[tt++] = i;<span class="comment">// 将每一个入度为0的点存进来从入度为零的点开始找，相当于头  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="type">int</span> t = q[hh++];  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])&#123;<span class="comment">// 邻接表的遍历  </span></span><br><span class="line">            <span class="type">int</span> j = e[i];  </span><br><span class="line">            d[j] --;<span class="comment">// 删去一个入度因为int t = q[hh++];  </span></span><br><span class="line">            <span class="keyword">if</span> (d[j] == <span class="number">0</span>)q[tt++] = j;<span class="comment">// 如果入度为0，相当于q队列的用法，存进来  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> tt == n;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;  </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);  </span><br><span class="line">    <span class="comment">// while循环里先用头插将点存进来点从a指向b，因此存进来的点入度加一  </span></span><br><span class="line">    <span class="keyword">while</span>(m --)&#123;  </span><br><span class="line">        <span class="type">int</span> a, b;  </span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;  </span><br><span class="line">        <span class="built_in">add</span>(a, b);  </span><br><span class="line">        d[b] ++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">topsort</span>())  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)cout &lt;&lt; q[i] &lt;&lt; <span class="string">&quot; &quot;</span>;  </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);  </span><br><span class="line">      </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>



<h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><h3 id="√4-Dijkstra"><a href="#√4-Dijkstra" class="headerlink" title="√4.Dijkstra"></a>√4.Dijkstra</h3><p><strong>题目一定不能存在负权边！！</strong></p>
<p>就是一个一个往下递推</p>
<p>0x3f3f3f3f大约是1x10^9用来定义一个很大的数</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/852/">850. Dijkstra求最短路 II - AcWing题库</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"> #include &lt;iostream&gt;  </span><br><span class="line"> #include &lt;cstring&gt;  </span><br><span class="line"></span><br><span class="line"> using namespace std;  </span><br><span class="line"></span><br><span class="line"> const int N = 510;  </span><br><span class="line"></span><br><span class="line"> int n, m;  </span><br><span class="line"> int g[N][N];// g为邻接矩阵   </span><br><span class="line"> int dist[N];// dist为某点到该点的距离   </span><br><span class="line"> bool st[N];// st为该点是否已经被确定最短路   </span><br><span class="line"></span><br><span class="line"> int dijkstra()  </span><br><span class="line"> &#123;  </span><br><span class="line">     memset(dist, 0x3f, sizeof(dist));// memset按单字节填充int每个字节被设置为0x3f则每个整数被定为0x3f3f3f3f  </span><br><span class="line">     dist[1] = 0;// 1到自己距离为0  </span><br><span class="line">       </span><br><span class="line"></span><br><span class="line"> for(int i = 0; i &lt; n; i ++)// 遍历每一个点求出所有可能  </span><br><span class="line"> &#123;  </span><br><span class="line">     int t = -1;  </span><br><span class="line">     for(int j = 1; j &lt;= n; j ++)  </span><br><span class="line">     &#123;  </span><br><span class="line">         if(!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))// 找到未被确定的距离1最小的点(依据贪心，其实也好理解)  </span><br><span class="line">         &#123;  </span><br><span class="line">             t = j;  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">     st[t] = true;// 这点最短距离确定  </span><br><span class="line">     // 以这点为基准判断其他点的最短路  </span><br><span class="line">     for(int j = 1; j &lt;= n; j ++)  </span><br><span class="line">     &#123;  </span><br><span class="line">         dist[j] = min(dist[j], dist[t] + g[t][j]);  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> if(dist[n] == 0x3f3f3f3f)return -1;// dist[n] == 0x3f3f3f3f表示该点未被确定也就是没有路从1到该点  </span><br><span class="line"> return dist[n];// 返回最短路  </span><br><span class="line"></span><br><span class="line"> &#125;  </span><br><span class="line"> int main()  </span><br><span class="line"> &#123;  </span><br><span class="line">     scanf(&quot;%d%d&quot;, &amp;n, &amp;m);  </span><br><span class="line">     memset(g, 0x3f, sizeof(g));  </span><br><span class="line">     while (m --)  </span><br><span class="line">     &#123;  </span><br><span class="line">         int x, y, z;  </span><br><span class="line">         scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z);  </span><br><span class="line">         g[x][y] = min(g[x][y], z);// 如果遇到重边选择最短的那个(依据题意)  </span><br><span class="line">      &#125;   </span><br><span class="line">     int t = dijkstra();  </span><br><span class="line">       </span><br><span class="line"></span><br><span class="line"> printf(&quot;%d&quot;, t);  </span><br><span class="line"></span><br><span class="line"> return 0;  </span><br><span class="line"></span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">而当数据量很大的时候用邻接矩阵N*N会报错</span><br><span class="line"></span><br><span class="line">这时候我们可以优化使用邻接表和优先队列的形式</span><br><span class="line"></span><br><span class="line"> #include &lt;iostream&gt;  </span><br><span class="line"> #include &lt;cstring&gt;  </span><br><span class="line"> #include &lt;queue&gt;  </span><br><span class="line"></span><br><span class="line"> using namespace std;  </span><br><span class="line"></span><br><span class="line"> typedef pair&lt;int, int &gt; PII;  </span><br><span class="line"> const int N = 1e5 + 10;  </span><br><span class="line"></span><br><span class="line"> int n, m;  </span><br><span class="line"> int h[N], e[N], w[N], ne[N], idx;// h为每个头，e为值，w为每个权重  </span><br><span class="line"> int dist[N];// dist为某点到该点的距离   </span><br><span class="line"> bool st[N];// st为该点是否已经被确定最短路   </span><br><span class="line"></span><br><span class="line"> void add(int a, int b, int c)// 邻接表的头插  </span><br><span class="line"> &#123;  </span><br><span class="line">     e[idx] = b;  </span><br><span class="line">     w[idx] = c;  </span><br><span class="line">     ne[idx] = h[a];  </span><br><span class="line">     h[a] = idx++;  </span><br><span class="line"> &#125;  </span><br><span class="line"> int dijkstra()  </span><br><span class="line"> &#123;  </span><br><span class="line">     memset(dist, 0x3f, sizeof(dist));// memset按单字节填充int每个字节被设置为0x3f则每个整数被定为0x3f3f3f3f  </span><br><span class="line">     dist[1] = 0;// 1到自己距离为0  </span><br><span class="line">       </span><br><span class="line"></span><br><span class="line"> priority_queue&lt;PII, vector&lt;PII&gt;,greater&lt;PII&gt;&gt;heap;// 创建一个升序的优先队列  </span><br><span class="line"> heap.push(&#123;0, 1&#125;);// 插入第一个元素,fist为距离second为编号  </span><br><span class="line"></span><br><span class="line"> while(heap.size())&#123;// 若非空  </span><br><span class="line">     auto t = heap.top();  </span><br><span class="line">     heap.pop();  </span><br><span class="line">       </span><br><span class="line">     int ver = t.second, distance = t.first;// ver是该点，distance是到起始点的距离  </span><br><span class="line">       </span><br><span class="line">     if(st[ver]) continue;// 如果该点已经得出最短路  </span><br><span class="line">     st[ver] = true;  </span><br><span class="line">       </span><br><span class="line">     for(int i = h[ver]; i != -1; i = ne[i])// 以这点为基准判断其他点的最短路  </span><br><span class="line">     &#123;  </span><br><span class="line">         int j = e[i];  </span><br><span class="line">         if(dist[j] &gt; distance + w[i])  </span><br><span class="line">         &#123;  </span><br><span class="line">             dist[j] = distance + w[i];  </span><br><span class="line">             heap.push(&#123;dist[j],j&#125;);  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> if(dist[n] == 0x3f3f3f3f)return -1;// dist[n] == 0x3f3f3f3f表示该点未被确定也就是没有路从1到该点  </span><br><span class="line"> return dist[n];// 返回最短路  </span><br><span class="line"></span><br><span class="line"> &#125;  </span><br><span class="line"> int main()  </span><br><span class="line"> &#123;  </span><br><span class="line">     scanf(&quot;%d%d&quot;, &amp;n, &amp;m);  </span><br><span class="line">       </span><br><span class="line"></span><br><span class="line"> memset(h, -1, sizeof(h));// 邻接表的初始化  </span><br><span class="line"></span><br><span class="line"> while (m --)  </span><br><span class="line"> &#123;  </span><br><span class="line">     int x, y, z;  </span><br><span class="line">     scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z);  </span><br><span class="line">     add(x, y, z);  </span><br><span class="line">  &#125;   </span><br><span class="line"> int t = dijkstra();  </span><br><span class="line"></span><br><span class="line"> printf(&quot;%d&quot;, t);  </span><br><span class="line"></span><br><span class="line"> return 0;  </span><br><span class="line"></span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure>



<h3 id="√5-bellman-ford"><a href="#√5-bellman-ford" class="headerlink" title="√5.bellman-ford"></a>√5.bellman-ford</h3><p><strong>当存在负权边时可以使用</strong></p>
<p><strong>有边数限制的时候可以用</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = <span class="number">10010</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;  </span><br><span class="line">    <span class="type">int</span> a, b, w;  </span><br><span class="line">&#125;edges[M];  </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k;  </span><br><span class="line"><span class="type">int</span> dist[N], backcup[N];  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bellman_ford</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);  </span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;  </span><br><span class="line">      </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i ++)<span class="comment">// 处理最多走k条边时的最短路  </span></span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">memcpy</span>(backcup, dist, <span class="keyword">sizeof</span> dist);<span class="comment">// 备份，因为这里走的边有限所以mei走一条边要用上一次的距离来计算下面的  </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="type">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;  </span><br><span class="line">        dist[b] = <span class="built_in">min</span>(dist[b], backcup[a] + w);   </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>)<span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line"><span class="keyword">return</span> dist[n];  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);  </span><br><span class="line">      </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> a, b, w;  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);  </span><br><span class="line">    edges[i] = &#123;a, b, w&#125;;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t = <span class="built_in">bellman_ford</span>();  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(t == <span class="number">-1</span>)<span class="built_in">printf</span>(<span class="string">&quot;impossible&quot;</span>);  </span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, t);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>



<h3 id="6-spfa"><a href="#6-spfa" class="headerlink" title="6.spfa"></a>6.spfa</h3><ul>
<li><h4 id="判断最短路"><a href="#判断最短路" class="headerlink" title="判断最短路"></a>判断最短路</h4><p>  主要是对bellman-ford一个优化</p>
<p>  dist[b] &#x3D; min(dist[b], dist[a] + w); 当dist[a]不变时dist[b]就不会变小</p>
<p>  spfa就是用队列对这一部分进行优化</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;  </span><br><span class="line">#include &lt;cstring&gt;  </span><br><span class="line">#include &lt;queue&gt;  </span><br><span class="line">    </span><br><span class="line">using namespace std;  </span><br><span class="line">    </span><br><span class="line">typedef pair&lt;int, int &gt; PII;  </span><br><span class="line">const int N = 1e5 + 10;  </span><br><span class="line">    </span><br><span class="line">int n, m;  </span><br><span class="line">int h[N], e[N], w[N], ne[N], idx;// h为每个头，e为值，w为每个权重  </span><br><span class="line">int dist[N];// dist为某点到该点的距离   </span><br><span class="line">bool st[N];// st为该点是否在队列中  </span><br><span class="line">    </span><br><span class="line">void add(int a, int b, int c)// 邻接表的头插  </span><br><span class="line">&#123;  </span><br><span class="line">    e[idx] = b;  </span><br><span class="line">    w[idx] = c;  </span><br><span class="line">    ne[idx] = h[a];  </span><br><span class="line">    h[a] = idx++;  </span><br><span class="line">&#125;  </span><br><span class="line">int spfa()  </span><br><span class="line">&#123;  </span><br><span class="line">    memset(dist, 0x3f, sizeof dist);  </span><br><span class="line">    dist[1] = 0;  </span><br><span class="line">      </span><br><span class="line">    </span><br><span class="line">queue&lt;int&gt; q;// q队列存储改变的那个点，因为这个点改变才会导致后面的点变化  </span><br><span class="line">    </span><br><span class="line">q.push(1);  </span><br><span class="line">st[1] = true;  </span><br><span class="line">    </span><br><span class="line">while(q.size())  </span><br><span class="line">&#123;  </span><br><span class="line">    int t = q.front();  </span><br><span class="line">    q.pop();  </span><br><span class="line">    st[t] = false;  </span><br><span class="line">      </span><br><span class="line">    for(int i = h[t]; i != -1; i = ne[i])  </span><br><span class="line">    &#123;  </span><br><span class="line">        int j = e[i];  </span><br><span class="line">        if(dist[j] &gt; dist[t] + w[i])  </span><br><span class="line">        &#123;  </span><br><span class="line">            dist[j] = dist[t] + w[i];  </span><br><span class="line">            if(!st[j])  </span><br><span class="line">            &#123;  </span><br><span class="line">                q.push(j);  </span><br><span class="line">                st[j] = true;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">    </span><br><span class="line">if(dist[n] == 0x3f3f3f3f)return -1;// -1依据题目  </span><br><span class="line">return dist[n];  </span><br><span class="line">    </span><br><span class="line">&#125;  </span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);  </span><br><span class="line">      </span><br><span class="line">    </span><br><span class="line">memset(h, -1, sizeof(h));// 邻接表的初始化  </span><br><span class="line">    </span><br><span class="line">while (m --)  </span><br><span class="line">&#123;  </span><br><span class="line">    int x, y, z;  </span><br><span class="line">    scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z);  </span><br><span class="line">    add(x, y, z);  </span><br><span class="line"> &#125;   </span><br><span class="line">int t = spfa();  </span><br><span class="line">    </span><br><span class="line">if(t == -1)printf(&quot;impossible&quot;);  </span><br><span class="line">else printf(&quot;%d&quot;, t);  </span><br><span class="line">    </span><br><span class="line">return 0;  </span><br><span class="line">    </span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="spfa判断负环"><a href="#spfa判断负环" class="headerlink" title="spfa判断负环"></a>spfa判断负环</h4><p>  创建一个cnt数组来记录边数</p>
<p>  当cnt数组&gt;&#x3D;n就代表当前边存在自环且一定是负环（只有负环才会往下更新）</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span>  </span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span> &gt; PII;  </span><br><span class="line"> <span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;  </span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> n, m;  </span><br><span class="line"> <span class="type">int</span> h[N], e[N], w[N], ne[N], idx;<span class="comment">// h为每个头，e为值，w为每个权重  </span></span><br><span class="line"> <span class="type">int</span> dist[N], cnt[N];<span class="comment">// dist为某点到该点的距离，cnt记录边数  </span></span><br><span class="line"> <span class="type">bool</span> st[N];<span class="comment">// st为该点是否在队列中  </span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span><span class="comment">// 邻接表的头插  </span></span></span><br><span class="line"><span class="function"> </span>&#123;  </span><br><span class="line">     e[idx] = b;  </span><br><span class="line">     w[idx] = c;  </span><br><span class="line">     ne[idx] = h[a];  </span><br><span class="line">     h[a] = idx++;  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"> </span>&#123;  </span><br><span class="line">     queue&lt;<span class="type">int</span>&gt; q;<span class="comment">// q队列存储改变的那个点，因为这个点改变才会导致后面的点变化  </span></span><br><span class="line">       </span><br><span class="line"></span><br><span class="line"> <span class="comment">// 将所以点都入队，防止第一个点与后面不相连  </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)  </span><br><span class="line">&#123;  </span><br><span class="line">    st[i] = <span class="literal">true</span>;  </span><br><span class="line">    q.<span class="built_in">push</span>(i);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span>(q.<span class="built_in">size</span>())  </span><br><span class="line"> &#123;  </span><br><span class="line">     <span class="type">int</span> t = q.<span class="built_in">front</span>();  </span><br><span class="line">     q.<span class="built_in">pop</span>();  </span><br><span class="line">     st[t] = <span class="literal">false</span>;  </span><br><span class="line">       </span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])  </span><br><span class="line">     &#123;  </span><br><span class="line">         <span class="type">int</span> j = e[i];  </span><br><span class="line">         <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])  </span><br><span class="line">         &#123;  </span><br><span class="line">             dist[j] = dist[t] + w[i];  </span><br><span class="line">             cnt[j] = cnt[t] + <span class="number">1</span>;  </span><br><span class="line">               </span><br><span class="line">             <span class="keyword">if</span>(cnt[j] &gt;= n)<span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">             <span class="keyword">if</span>(!st[j])  </span><br><span class="line">             &#123;  </span><br><span class="line">                 q.<span class="built_in">push</span>(j);  </span><br><span class="line">                 st[j] = <span class="literal">true</span>;  </span><br><span class="line">             &#125;  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line"></span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"> </span>&#123;  </span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);  </span><br><span class="line">       </span><br><span class="line"></span><br><span class="line"> <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));<span class="comment">// 邻接表的初始化  </span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> (m --)  </span><br><span class="line"> &#123;  </span><br><span class="line">     <span class="type">int</span> x, y, z;  </span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);  </span><br><span class="line">     <span class="built_in">add</span>(x, y, z);  </span><br><span class="line">  &#125;   </span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(<span class="built_in">spfa</span>())<span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);  </span><br><span class="line"> <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);  </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="√7-Floyd"><a href="#√7-Floyd" class="headerlink" title="√7.Floyd"></a>√7.Floyd</h3><p>一个比较简单的算法</p>
<p>可以想象成向量相加的形式</p>
<p><strong>floyd里面三个for循环循序不能变！！！ 否则可能会把没有求出最短路的边拿来用导致出错</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/856/">854. Floyd求最短路 - AcWing题库</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"></span><br><span class="line"> <span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>, INF = <span class="number">1e9</span>;  </span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> n, m, Q;  </span><br><span class="line"> <span class="type">int</span> d[N][N];  </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Floyd</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"> </span>&#123;  </span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++)  </span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)  </span><br><span class="line">             <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)  </span><br><span class="line">                 d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);<span class="comment">// d[i][k] + d[k][j]“向量相加”  </span></span><br><span class="line">       </span><br><span class="line"> &#125;  </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"> </span>&#123;  </span><br><span class="line">     cin &gt;&gt; n &gt;&gt; m &gt;&gt; Q;  </span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)  </span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)  </span><br><span class="line">             <span class="keyword">if</span>(i == j)d[i][j] = <span class="number">0</span>;  </span><br><span class="line">             <span class="keyword">else</span> d[i][j] = INF;  </span><br><span class="line">       </span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span>(m --)  </span><br><span class="line"> &#123;  </span><br><span class="line">     <span class="type">int</span> x, y, z;  </span><br><span class="line">     cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;  </span><br><span class="line">     d[x][y] = <span class="built_in">min</span>(d[x][y], z);  </span><br><span class="line"> &#125;  </span><br><span class="line"></span><br><span class="line"> <span class="built_in">Floyd</span>();  </span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span>(Q --)  </span><br><span class="line"> &#123;  </span><br><span class="line">     <span class="type">int</span> x, y;  </span><br><span class="line">     cin &gt;&gt; x &gt;&gt; y;  </span><br><span class="line">       </span><br><span class="line">     <span class="keyword">if</span>(d[x][y] &gt; INF / <span class="number">2</span>)<span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);  </span><br><span class="line">     <span class="keyword">else</span> cout &lt;&lt; d[x][y] &lt;&lt; endl;  </span><br><span class="line"> &#125;  </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure>



<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="8-Prim"><a href="#8-Prim" class="headerlink" title="8.Prim"></a>8.Prim</h3><p>主要解决最小生成树的问题</p>
<p>跟Dijkstra类似但此时求的是到集合的距离</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/860/">858. Prim算法求最小生成树 - AcWing题库</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"> #include &lt;iostream&gt;  </span><br><span class="line"> #include &lt;cstring&gt;  </span><br><span class="line"></span><br><span class="line"> using namespace std;  </span><br><span class="line"></span><br><span class="line"> const int N = 510, INF = 0x3f3f3f3f;  </span><br><span class="line">    </span><br><span class="line"> int n, m;  </span><br><span class="line"> int g[N][N];  </span><br><span class="line"> int dist[N];// dist存到集合的最短距离  </span><br><span class="line"> bool st[N];  </span><br><span class="line"></span><br><span class="line"> int prim()  </span><br><span class="line"> &#123;  </span><br><span class="line">     memset(dist, 0x3f, sizeof dist);  </span><br><span class="line">       </span><br><span class="line"></span><br><span class="line"> int res = 0;  </span><br><span class="line"></span><br><span class="line"> for(int i = 0; i &lt; n; i ++)  </span><br><span class="line"> &#123;  </span><br><span class="line">     int t = -1;  </span><br><span class="line">     //在集合外找到到集合距离最小的点  </span><br><span class="line">     for(int j = 1; j &lt;= n; j ++)  </span><br><span class="line">     &#123;  </span><br><span class="line">         if(!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))t = j;  </span><br><span class="line">     &#125;  </span><br><span class="line"></span><br><span class="line">​     if(i &amp;&amp; dist[t] == INF)return INF;// 如果这个最下的点为INF则表明没有线到集合就是与集合不相连  </span><br><span class="line">​       </span><br><span class="line">​     if(i)res += dist[t];  </span><br><span class="line">​       </span><br><span class="line">​     for(int j = 1; j &lt;= n; j ++)dist[j] = min(dist[j], g[t][j]);  </span><br><span class="line">​       </span><br><span class="line">​     st[t] = true;  </span><br><span class="line">​       </span><br><span class="line"> &#125;  </span><br><span class="line"></span><br><span class="line"> return res;  </span><br><span class="line"></span><br><span class="line"> &#125;  </span><br><span class="line"></span><br><span class="line"> int main()  </span><br><span class="line"> &#123;  </span><br><span class="line">     scanf(&quot;%d%d&quot;, &amp;n, &amp;m);  </span><br><span class="line">       </span><br><span class="line"></span><br><span class="line"> memset(g, 0x3f, sizeof g);  </span><br><span class="line"></span><br><span class="line"> while(m --)  </span><br><span class="line"> &#123;  </span><br><span class="line">     int a, b, c;  </span><br><span class="line">     scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);  </span><br><span class="line">     g[a][b] = g[b][a] = min(g[a][b], c);// 无向图的存储  </span><br><span class="line"> &#125;  </span><br><span class="line"></span><br><span class="line"> int t = prim();  </span><br><span class="line"></span><br><span class="line"> if(t == INF)puts(&quot;impossible&quot;);  </span><br><span class="line"> else printf(&quot;%d\n&quot;,t);  </span><br><span class="line">       </span><br><span class="line"> return 0;  </span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h3 id="√9-Kruskal"><a href="#√9-Kruskal" class="headerlink" title="√9.Kruskal"></a>√9.Kruskal</h3><p>这个方法线将权重w排序使得每次循环都用的最短的那条路，这样就可以使得求出来的权值最小</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/861/">859. Kruskal算法求最小生成树 - AcWing题库</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;  </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;  </span><br><span class="line"><span class="type">int</span> p[N];  </span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;  </span><br><span class="line">    <span class="type">int</span> a, b, w;  </span><br><span class="line">    <span class="comment">// 自定义排序，按边的权重w从小到大排  </span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;W)<span class="type">const</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">return</span> w &lt; W.w;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;edges[N];  </span><br><span class="line"><span class="comment">// 并查集寻找祖宗节点  </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)p[x] = <span class="built_in">find</span>(p[x]);  </span><br><span class="line">    <span class="keyword">return</span> p[x];  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);  </span><br><span class="line">      </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;  <span class="comment">//并查集初始化  </span></span><br><span class="line"><span class="comment">//读入数据  </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> a, b, w;  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);  </span><br><span class="line">    edges[i] = &#123;a, b, w&#125;;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(edges, edges + m);  </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;<span class="comment">// res存权重之和，cnt存有多少条边可以来判断是否有生成树  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;  </span><br><span class="line">      </span><br><span class="line">    a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);  </span><br><span class="line">    <span class="keyword">if</span>(a != b)  </span><br><span class="line">    &#123;  </span><br><span class="line">        p[a] = b;  </span><br><span class="line">        res += w;  </span><br><span class="line">        cnt ++;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(cnt &lt; n - <span class="number">1</span>)<span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);  </span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>



<h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><h3 id="10-染色法判定二分图"><a href="#10-染色法判定二分图" class="headerlink" title="10.染色法判定二分图"></a>10.染色法判定二分图</h3><p>什么是二分图？</p>
<p>就是可以形成点在左右两个集合里边在中间的图</p>
<p>二分图当且仅当图中不含奇数环</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/862/">860. 染色法判定二分图 - AcWing题库</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">200010</span>;  </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;  </span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;  </span><br><span class="line"><span class="type">int</span> color[N];<span class="comment">// 1和2为不同颜色  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// dfs用于给点当前点染色并判断与之相连的点是否符合条件即颜色不同  </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> c)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    color[u] = c;  </span><br><span class="line">      </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> j = e[i];  </span><br><span class="line">    <span class="keyword">if</span>(!color[j])  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">dfs</span>(j, <span class="number">3</span> - c))<span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(color[j] == c)<span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);  </span><br><span class="line">      </span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(m --)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> a, b;  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);  </span><br><span class="line">    <span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a);<span class="comment">// 无向图的添加  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;  </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span>(!color[i])<span class="comment">// 如果为染色  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">dfs</span>(i, <span class="number">1</span>))<span class="comment">// 如果染色后不满足二分图的条件  </span></span><br><span class="line">        &#123;  </span><br><span class="line">            flag = <span class="literal">false</span>;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(flag)<span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);  </span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="11-匈牙利算法"><a href="#11-匈牙利算法" class="headerlink" title="11.匈牙利算法"></a>11.匈牙利算法</h3><p>怎么说呢</p>
<p>就是左右两个集合匹配问题，如果a想匹配b而b已被匹配但b有别的匹配方案那么b匹配另一个的a匹配b</p>
<p>具体可以看看Acwing上的视频这一课我认为是讲的最好的</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/video/290/">AcWing 861. 二分图的最大匹配 - AcWing</a>看他举的例子</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/863/">861. 二分图的最大匹配 - AcWing题库</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;  </span><br><span class="line">#include &lt;cstring&gt;  </span><br><span class="line"></span><br><span class="line">using namespace std;  </span><br><span class="line"></span><br><span class="line">const int N = 510, M = 100010;  </span><br><span class="line"></span><br><span class="line">int n1, n2, m;  </span><br><span class="line">int h[N], e[M], ne[M], idx;  </span><br><span class="line">int math[N];// math存储匹配的对象  </span><br><span class="line">bool st[N];// st存储当前点是否被考虑过  </span><br><span class="line"></span><br><span class="line">void add(int a, int b)  </span><br><span class="line">&#123;  </span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;  </span><br><span class="line">&#125;  </span><br><span class="line">// 匹配算法 成功返回true失败返回false  </span><br><span class="line">bool find(int x)  </span><br><span class="line">&#123;  </span><br><span class="line">    for(int i = h[x]; i != -1; i = ne[i])  </span><br><span class="line">    &#123;  </span><br><span class="line">        int j = e[i];  </span><br><span class="line">        if(!st[j])  </span><br><span class="line">        &#123;  </span><br><span class="line">            st[j] = true;  </span><br><span class="line">            if(math[j] == 0 || find(math[j]))// 如过当前点未匹配或者他可以匹配其他的点  </span><br><span class="line">            &#123;  </span><br><span class="line">                math[j] = x;  </span><br><span class="line">                return true;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return false;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">    scanf(&quot;%d%d%d&quot;, &amp;n1, &amp;n2, &amp;m);  </span><br><span class="line">    memset(h, -1, sizeof h);  </span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">while(m --)  </span><br><span class="line">&#123;  </span><br><span class="line">    int a, b;  </span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;a, &amp;b);  </span><br><span class="line">    add(a, b);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">int res = 0;  </span><br><span class="line">for(int i = 1; i &lt;= n1; i ++)  </span><br><span class="line">&#123;  </span><br><span class="line">    memset(st, false, sizeof st);  </span><br><span class="line">      </span><br><span class="line">    if(find(i))res ++;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">printf(&quot;%d&quot;, res);  </span><br><span class="line"></span><br><span class="line">return 0;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第四章数学知识"><a href="#第四章数学知识" class="headerlink" title="第四章数学知识"></a>第四章数学知识</h2><h2 id="1-质数"><a href="#1-质数" class="headerlink" title="1.质数"></a>1.质数</h2><h3 id="①试除法判断质数"><a href="#①试除法判断质数" class="headerlink" title="①试除法判断质数"></a>①试除法判断质数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//只强调写循环条件的时候</span><br><span class="line"> for9int i = 2;i &lt;= n/i;i ++) </span><br><span class="line"> //其他照旧</span><br></pre></td></tr></table></figure>

<h3 id="②试除法分解质因数"><a href="#②试除法分解质因数" class="headerlink" title="②试除法分解质因数"></a>②试除法分解质因数</h3><p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250126153901302.png" alt="image-20250126153901302"></p>
<h3 id="③筛质数"><a href="#③筛质数" class="headerlink" title="③筛质数"></a>③筛质数</h3><p>这里介绍线性算法，即用质数筛掉所有以该质数为因子的合数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int cnt,primes[N];</span><br><span class="line">bool st[N];</span><br><span class="line"></span><br><span class="line">void get_primes(int n)&#123;</span><br><span class="line">	for(int i = 2;i &lt;= n;i ++)&#123;</span><br><span class="line">		if(!st[i]) primes[cnt ++] = i;</span><br><span class="line">		else &#123;</span><br><span class="line">			for(int j = 0;primes[j] &lt;= n/i;j ++) &#123;</span><br><span class="line">			st[i * primes[j]] = true;</span><br><span class="line">			if(i % primes[j] == 0) break; // primes[j]一定是i的最小质因子</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int n; cin &gt;&gt; n;</span><br><span class="line">	get_primes(n);</span><br><span class="line">	cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-约数"><a href="#2-约数" class="headerlink" title="2.约数"></a>2.约数</h2><h3 id="①试除法求约数"><a href="#①试除法求约数" class="headerlink" title="①试除法求约数"></a>①试除法求约数</h3><p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250126164736991.png" alt="image-20250126164736991"></p>
<h3 id="②求约数个数"><a href="#②求约数个数" class="headerlink" title="②求约数个数"></a>②求约数个数</h3><p>约数个数公式</p>
<p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250126165536547.png" alt="image-20250126165536547"></p>
<p>所以我们需要先分界质因数然后再求指数，用hash表来存就好</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line">const int N = 1e7;</span><br><span class="line">const int mod = 1e9 + 7;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n; cin &gt;&gt; n;</span><br><span class="line">    unordered_map&lt;int,int&gt;primes; //用来存质因数和它的指数</span><br><span class="line">    while(n --)&#123;</span><br><span class="line">        int x; cin &gt;&gt; x;</span><br><span class="line">        for(int i = 2;i &lt;= n;i ++)&#123;</span><br><span class="line">            while(x % i == 0)&#123;</span><br><span class="line">                x /= i;</span><br><span class="line">                primes[i] ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll res = 0;</span><br><span class="line">    for(auto prime : primes) res = res * (prime.second + 1) % mod;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="③求约数之和"><a href="#③求约数之和" class="headerlink" title="③求约数之和"></a>③求约数之和</h3><p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250126174914523.png" alt="image-20250126174914523"></p>
<p>一样的，我们分解质因数然后按照公式计算即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line">const int N = 1e7;</span><br><span class="line">const int mod = 1e9 + 7;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n; cin &gt;&gt; n;</span><br><span class="line">    unordered_map&lt;int,int&gt;primes; //用来存质因数和它的指数</span><br><span class="line">    while(n --)&#123;</span><br><span class="line">        int x; cin &gt;&gt; x;</span><br><span class="line">        for(int i = 2;i &lt;= n;i ++)&#123;</span><br><span class="line">            while(x % i == 0)&#123;</span><br><span class="line">                x /= i;</span><br><span class="line">                primes[i] ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll res = 0;</span><br><span class="line">    for(auto prime : primes) res = res * (prime.second + 1) % mod;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;                                                                                 																																															</span><br></pre></td></tr></table></figure>

<h3 id="③最大公约数"><a href="#③最大公约数" class="headerlink" title="③最大公约数"></a>③最大公约数</h3><p>辗转相除法 欧几里得算法 gcd</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int gcd(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">	return b ? gcd(b,a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="④扩展欧几里得算法"><a href="#④扩展欧几里得算法" class="headerlink" title="④扩展欧几里得算法"></a>④扩展欧几里得算法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 求x, y，使得ax + by = gcd(a, b)</span><br><span class="line">int exgcd(int a, int b, int &amp;x, int &amp;y)</span><br><span class="line">&#123;</span><br><span class="line">    if (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = 1; y = 0;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">    int d = exgcd(b, a % b, y, x);</span><br><span class="line">    y -= (a/b) * x;</span><br><span class="line">    return d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-欧拉函数"><a href="#3-欧拉函数" class="headerlink" title="3.欧拉函数"></a>3.欧拉函数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250218212753454.png" alt="image-20250218212753454"></p>
<h3 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h3><h4 id="1、公式求欧拉函数"><a href="#1、公式求欧拉函数" class="headerlink" title="1、公式求欧拉函数"></a>1、公式求欧拉函数</h4><p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250218213643606.png" alt="image-20250218213643606"></p>
<p>其中第一行是对N进行分解质因数的结果</p>
<p>第二行是求欧拉函数的公式</p>
<p>代码实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int a; cin &gt;&gt; a;</span><br><span class="line">    int res = a;</span><br><span class="line">    for(int i = 2;i &lt;= a / i;i ++)&#123;</span><br><span class="line">        if(a % i == 0) &#123;</span><br><span class="line">            res = res / i * (i - 1);</span><br><span class="line">            while(a % i == 0) a /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(a &gt; 1) res = res / a * (a - 1);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h4 id="2、筛法求欧拉函数"><a href="#2、筛法求欧拉函数" class="headerlink" title="2、筛法求欧拉函数"></a>2、筛法求欧拉函数</h4><p>注意，这里是求1~N每一个数的欧拉函数</p>
<p> 这里以求1~N的每个数的欧拉函数之和为例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line">const int N = 1e6 + 10;</span><br><span class="line">int primes[N],cnt;</span><br><span class="line">int phi[N];</span><br><span class="line">bool st[N];</span><br><span class="line"></span><br><span class="line">ll get_eulers(int n)</span><br><span class="line">&#123;</span><br><span class="line">    phi[1] = 1;</span><br><span class="line">    for(int i = 2;i &lt;= n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!st[i]) &#123;</span><br><span class="line">            primes[cnt ++] = i;</span><br><span class="line">            phi[i] = i - 1; // 质数的欧拉函数</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j = 0; primes[j] &lt;= n / i; j ++)&#123;</span><br><span class="line">            st[primes[j] * i] = true;</span><br><span class="line">            if(i % primes[j] == 0) &#123;</span><br><span class="line">                phi[primes[j] * i] = primes[j] * phi[i];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            phi[primes[j] * i] = phi[i] * (primes[j] - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll res = 0;</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++) res += phi[i];</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n; cin &gt;&gt; n;</span><br><span class="line">    get_eulers(n);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-快速幂"><a href="#4-快速幂" class="headerlink" title="4.快速幂"></a>4.快速幂</h2><p>用于快速求出a的k次方 % p的结果</p>
<p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250218224555876.png" alt="image-20250218224555876"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 返回a ^ k % p</span><br><span class="line">ll qmi(int a,int k,int p)</span><br><span class="line">&#123;</span><br><span class="line">    int res = 1;</span><br><span class="line">    while(k) &#123;</span><br><span class="line">        if(k &amp; 1) res = (ll)res * a % p;</span><br><span class="line">        k &gt;&gt;= 1;</span><br><span class="line">        a = (ll)a * a % p;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速幂求逆元"><a href="#快速幂求逆元" class="headerlink" title="快速幂求逆元"></a>快速幂求逆元</h3><p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250218224846741.png" alt="image-20250218224846741"></p>
<h2 id="5-高斯消元求线性方程组"><a href="#5-高斯消元求线性方程组" class="headerlink" title="5.高斯消元求线性方程组"></a>5.高斯消元求线性方程组</h2><p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250218230839753.png" alt="image-20250218230839753"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// a[N][N]是增广矩阵</span><br><span class="line">int gauss()</span><br><span class="line">&#123;</span><br><span class="line">    int c, r;</span><br><span class="line">    for (c = 0, r = 0; c &lt; n; c ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        int t = r;</span><br><span class="line">        for (int i = r; i &lt; n; i ++ )   // 找到绝对值最大的行</span><br><span class="line">            if (fabs(a[i][c]) &gt; fabs(a[t][c]))</span><br><span class="line">                t = i;</span><br><span class="line"></span><br><span class="line">        if (fabs(a[t][c]) &lt; eps) continue;</span><br><span class="line"></span><br><span class="line">        for (int i = c; i &lt;= n; i ++ ) swap(a[t][i], a[r][i]);      // 将绝对值最大的行换到最顶端</span><br><span class="line">        for (int i = n; i &gt;= c; i -- ) a[r][i] /= a[r][c];      // 将当前行的首位变成1</span><br><span class="line">        for (int i = r + 1; i &lt; n; i ++ )       // 用当前行将下面所有的列消成0</span><br><span class="line">            if (fabs(a[i][c]) &gt; eps)</span><br><span class="line">                for (int j = n; j &gt;= c; j -- )</span><br><span class="line">                    a[i][j] -= a[r][j] * a[i][c];</span><br><span class="line"></span><br><span class="line">        r ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (r &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = r; i &lt; n; i ++ )</span><br><span class="line">            if (fabs(a[i][n]) &gt; eps)</span><br><span class="line">                return 2; // 无解</span><br><span class="line">        return 1; // 有无穷多组解</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = n - 1; i &gt;= 0; i -- )</span><br><span class="line">        for (int j = i + 1; j &lt; n; j ++ )</span><br><span class="line">            a[i][n] -= a[i][j] * a[j][n];</span><br><span class="line"></span><br><span class="line">    return 0; // 有唯一解</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="第五章动态规划"><a href="#第五章动态规划" class="headerlink" title="第五章动态规划"></a>第五章动态规划</h2><h2 id="√背包问题"><a href="#√背包问题" class="headerlink" title="√背包问题"></a>√背包问题</h2><h3 id="1-01背包问题"><a href="#1-01背包问题" class="headerlink" title="1.01背包问题"></a>1.01背包问题</h3><p>f[i] [j]数组表示前i个物品不超过j体积的价值数</p>
<p>那么我们可以将f[i] [j]分为包含第 i 个物品和不包含 i 两种再求一个max</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/2/">2. 01背包问题 - AcWing题库</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;  </span><br><span class="line"></span><br><span class="line">using namespace std;  </span><br><span class="line"></span><br><span class="line">const int N = 1010;  </span><br><span class="line"></span><br><span class="line">int n, m;  </span><br><span class="line">int v[N], w[N];  </span><br><span class="line">int f[N][N];  </span><br><span class="line"></span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;  </span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">for(int i = 1; i &lt;= n; i ++)cin &gt;&gt; v[i] &gt;&gt; w[i];  </span><br><span class="line"></span><br><span class="line">for(int i = 1; i &lt;= n; i ++)  </span><br><span class="line">    for(int j = 0; j &lt;= m; j ++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        f[i][j] = f[i - 1][j];  </span><br><span class="line">        if(j &gt;= v[i])f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">cout &lt;&lt; f[n][m];  </span><br><span class="line"></span><br><span class="line">return 0;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化:</p>
<p>我们可以将二维优化成一维</p>
<p>将 j 从大到小这样就保证每个 i 只被选一次</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;  </span><br><span class="line"></span><br><span class="line">using namespace std;  </span><br><span class="line"></span><br><span class="line">const int N = 1010;  </span><br><span class="line"></span><br><span class="line">int n, m;  </span><br><span class="line">int v[N], w[N];  </span><br><span class="line">int f[N];  </span><br><span class="line"></span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;  </span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">for(int i = 1; i &lt;= n; i ++)cin &gt;&gt; v[i] &gt;&gt; w[i];  </span><br><span class="line"></span><br><span class="line">for(int i = 1; i &lt;= n; i ++)  </span><br><span class="line">    for(int j = m; j &gt;= v[i]; j --)  </span><br><span class="line">        f[j] = max(f[j], f[j - v[i]] + w[i]);  </span><br><span class="line"></span><br><span class="line">cout &lt;&lt; f[m];  </span><br><span class="line"></span><br><span class="line">return 0;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-完全背包问题"><a href="#2-完全背包问题" class="headerlink" title="2.完全背包问题"></a>2.完全背包问题</h3><p>跟上面的思路差不多</p>
<p>但是此时我们将f [i] [j]分为包含0个i，1个i， 2个i……</p>
<p>所以max里面应该包含0个i项， 1个i项……</p>
<p>再进行整理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;  </span><br><span class="line"></span><br><span class="line">using namespace std;  </span><br><span class="line"></span><br><span class="line">const int N = 1010;  </span><br><span class="line"></span><br><span class="line">int n, m;  </span><br><span class="line">int v[N], w[N];  </span><br><span class="line">int f[N][N];  </span><br><span class="line"></span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;  </span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">for(int i = 1; i &lt;= n; i ++)cin &gt;&gt; v[i] &gt;&gt; w[i];  </span><br><span class="line"></span><br><span class="line">for(int i = 1; i &lt;= n; i ++)  </span><br><span class="line">    for(int j = 1; j &lt;= m; j ++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        f[i][j] = f[i - 1][j];  </span><br><span class="line">        if(j &gt;= v[i])f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">cout &lt;&lt; f[n][m];  </span><br><span class="line"></span><br><span class="line">return 0;  </span><br><span class="line"></span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>

<p>优化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;  </span><br><span class="line"></span><br><span class="line"> using namespace std;  </span><br><span class="line"></span><br><span class="line"> const int N = 1010;  </span><br><span class="line"></span><br><span class="line"> int n, m;  </span><br><span class="line"> int v[N], w[N];  </span><br><span class="line"> int f[N];  </span><br><span class="line"></span><br><span class="line"> int main()  </span><br><span class="line"> &#123;  </span><br><span class="line">     cin &gt;&gt; n &gt;&gt; m;  </span><br><span class="line">       </span><br><span class="line"></span><br><span class="line"> for(int i = 1; i &lt;= n; i ++)cin &gt;&gt; v[i] &gt;&gt; w[i];  </span><br><span class="line"></span><br><span class="line"> for(int i = 1; i &lt;= n; i ++)  </span><br><span class="line">     for(int j = v[i]; j &lt;= m; j ++)  </span><br><span class="line">         f[j] = max(f[j], f[j - v[i]] + w[i]);  </span><br><span class="line"></span><br><span class="line"> cout &lt;&lt; f[m];  </span><br><span class="line"></span><br><span class="line"> return 0;  </span><br><span class="line"></span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure>



<h3 id="3-多重背包问题（数据小的时候）"><a href="#3-多重背包问题（数据小的时候）" class="headerlink" title="3.多重背包问题（数据小的时候）"></a>3.多重背包问题（数据小的时候）</h3><p>直接暴力枚举</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/4/">4. 多重背包问题 I - AcWing题库</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;  </span><br><span class="line"></span><br><span class="line">using namespace std;  </span><br><span class="line"></span><br><span class="line">const int N = 110;  </span><br><span class="line"></span><br><span class="line">int n, m;  </span><br><span class="line">int f[N];  </span><br><span class="line"></span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;  </span><br><span class="line">    for(int i = 0; i &lt; n; i ++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        int v, w, s;  </span><br><span class="line">        cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;  </span><br><span class="line">        for(int j = m; j &gt;= 0; j -- )  </span><br><span class="line">            for(int k = 1; k &lt;= s &amp;&amp; k * v &lt;= j; k ++)  </span><br><span class="line">                f[j] = max(f[j], f[j - k * v] + k * w);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">cout &lt;&lt; f[m];  </span><br><span class="line"></span><br><span class="line">return 0;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-多重背包问题（数据大的时候）"><a href="#4-多重背包问题（数据大的时候）" class="headerlink" title="4.多重背包问题（数据大的时候）"></a>4.多重背包问题（数据大的时候）</h3><p>我们可以将每个数量拆出来变成01背包问题</p>
<p>怎么拆使得拆出来的数字个数最小呢？</p>
<p>用二进制的方式拆</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;  </span><br><span class="line"> #include &lt;vector&gt;  </span><br><span class="line"></span><br><span class="line"> using namespace std;  </span><br><span class="line"></span><br><span class="line"> const int N = 2010;  </span><br><span class="line"></span><br><span class="line"> int n, m;  </span><br><span class="line"> int f[N];  </span><br><span class="line"></span><br><span class="line"> struct Good&#123;  </span><br><span class="line">   int v, w;    </span><br><span class="line"> &#125;;  </span><br><span class="line"> int main()  </span><br><span class="line"> &#123;  </span><br><span class="line">     vector&lt;Good&gt; goods;  </span><br><span class="line">     cin &gt;&gt; n &gt;&gt; m;  </span><br><span class="line">     for(int i = 0; i &lt; n; i ++)  </span><br><span class="line">     &#123;  </span><br><span class="line">         int v, w, s;  </span><br><span class="line">         cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;  </span><br><span class="line">         for(int k = 1; k &lt;= s; k *= 2)  </span><br><span class="line">         &#123;  </span><br><span class="line">             s -= k;  </span><br><span class="line">             goods.push_back(&#123;v * k, w * k&#125;); // 二进制的方式拆  </span><br><span class="line">         &#125;  </span><br><span class="line">         if(s &gt; 0) goods.push_back(&#123;v * s, w * s&#125;); // 将剩下的数放进去  </span><br><span class="line">     &#125;  </span><br><span class="line">       </span><br><span class="line"></span><br><span class="line"> // 01 背包问题模板  </span><br><span class="line"> for(auto good : goods)  </span><br><span class="line">     for(int j = m; j &gt;= good.v; j --)  </span><br><span class="line">         f[j] = max(f[j], f[j - good.v] + good.w);  </span><br><span class="line">           </span><br><span class="line"> cout &lt;&lt; f[m];  </span><br><span class="line"></span><br><span class="line"> return 0;  </span><br><span class="line"></span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure>




<h3 id="5-分组背包问题"><a href="#5-分组背包问题" class="headerlink" title="5.分组背包问题"></a>5.分组背包问题</h3><p>多重背包问题是这个的特殊情况</p>
<p>代码思路差不多</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/9/">9. 分组背包问题 - AcWing题库</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;  </span><br><span class="line"></span><br><span class="line">using namespace std;  </span><br><span class="line"></span><br><span class="line">const int N = 110;  </span><br><span class="line"></span><br><span class="line">int n, m;  </span><br><span class="line">int f[N], v[N], w[N];  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;  </span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">for(int i = 0; i &lt; n; i ++)  </span><br><span class="line">&#123;  </span><br><span class="line">    int s;  </span><br><span class="line">    cin &gt;&gt; s;  </span><br><span class="line">    for(int j = 0; j &lt; s; j ++)cin &gt;&gt; v[j] &gt;&gt; w[j];  </span><br><span class="line">    for(int j = m; j &gt;= 0; j --)  </span><br><span class="line">        for(int k = 0; k &lt; s; k ++)  </span><br><span class="line">            if(j &gt;= v[k])  </span><br><span class="line">                f[j] = max(f[j], f[j - v[k]] + w[k]);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">cout &lt;&lt; f[m];  </span><br><span class="line"></span><br><span class="line">return 0;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a>线性DP</h2><h3 id="√6-数字三角形"><a href="#√6-数字三角形" class="headerlink" title="√6.数字三角形"></a>√6.数字三角形</h3><p>状态表示+计算</p>
<p>f[i] [j]表示到i行j列最大值</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/900/">898. 数字三角形 - AcWing题库</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;  </span><br><span class="line"></span><br><span class="line"> using namespace std;  </span><br><span class="line"></span><br><span class="line"> const int N = 510, INF= 1e9;  </span><br><span class="line"></span><br><span class="line"> int n;  </span><br><span class="line"> int a[N][N];  </span><br><span class="line"> int f[N][N];  </span><br><span class="line"></span><br><span class="line"> int main()  </span><br><span class="line"> &#123;  </span><br><span class="line">     cin &gt;&gt; n;  </span><br><span class="line">     for(int i = 1; i &lt;= n; i ++)  </span><br><span class="line">         for(int j = 1;j &lt;= i; j ++)  </span><br><span class="line">             cin &gt;&gt; a[i][j];  </span><br><span class="line">           </span><br><span class="line"></span><br><span class="line"> for(int i = 0; i &lt;= n; i ++)  </span><br><span class="line">     for(int j = 0; j &lt;= i + 1; j ++)  </span><br><span class="line">         f[i][j] = -INF;  </span><br><span class="line">           </span><br><span class="line"> f[1][1] = a[1][1];  </span><br><span class="line"> for(int i = 2; i &lt;= n; i ++)  </span><br><span class="line">     for(int j = 1; j &lt;= i ; j ++)  </span><br><span class="line">         f[i][j] = max(f[i - 1][j - 1] + a[i][j], f[i - 1][j] + a[i][j]);  </span><br><span class="line"></span><br><span class="line"> int res = -INF;          </span><br><span class="line"> for(int i = 1; i &lt;= n; i ++)res = max(res, f[n][i]);  </span><br><span class="line"></span><br><span class="line"> cout &lt;&lt; res;  </span><br><span class="line"></span><br><span class="line"> return 0;  </span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h3 id="√7-最长上升子序列（数据小时）"><a href="#√7-最长上升子序列（数据小时）" class="headerlink" title="√7.最长上升子序列（数据小时）"></a>√7.最长上升子序列（数据小时）</h3><p>f[i] 为以i为结尾的最长的长度</p>
<p>那么就可以得到他的最长长度等于0 …i - 1中比a[i]小的数的 f 值加1再跟i取max</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/897/">895. 最长上升子序列 - AcWing题库</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;  </span><br><span class="line"></span><br><span class="line">using namespace std;  </span><br><span class="line"></span><br><span class="line">const int N = 1010;  </span><br><span class="line"></span><br><span class="line">int n;  </span><br><span class="line">int a[N], f[N];  </span><br><span class="line"></span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">    cin &gt;&gt; n;  </span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; a[i];  </span><br><span class="line"></span><br><span class="line">for(int i = 1; i &lt;= n; i ++)  </span><br><span class="line">&#123;  </span><br><span class="line">    f[i] = 1;  </span><br><span class="line">    for(int j = 1; j &lt; i; j ++)  </span><br><span class="line">        if(a[j] &lt; a[i])  </span><br><span class="line">            f[i] = max(f[i], f[j] + 1);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">int res = 0;  </span><br><span class="line"></span><br><span class="line">for(int i = 1; i &lt;= n ; i ++) res = max(res, f[i]);  </span><br><span class="line"></span><br><span class="line">cout &lt;&lt; res;  </span><br><span class="line"></span><br><span class="line">return 0;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="√8-最长上升子序列（数据大时）"><a href="#√8-最长上升子序列（数据大时）" class="headerlink" title="√8.最长上升子序列（数据大时）"></a>√8.最长上升子序列（数据大时）</h3><p>先弄出每个长度子序列的最小值</p>
<p>枚举每个数把他接到小于他的最长的子序列这样就使得出来的子序列最长</p>
<p>用二分的方法找到小于他的最长的子序列</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/898/">896. 最长上升子序列 II - AcWing题库</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;  </span><br><span class="line"></span><br><span class="line">using namespace std;  </span><br><span class="line"></span><br><span class="line">const int N = 100010;  </span><br><span class="line"></span><br><span class="line">int n;  </span><br><span class="line">int a[N];  </span><br><span class="line">int q[N]; // q存储每个上升子序列长度结尾的数的最小值  </span><br><span class="line"></span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">    cin &gt;&gt; n;  </span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">for(int i = 0; i &lt; n; i ++) cin &gt;&gt; a[i];  </span><br><span class="line"></span><br><span class="line">int len = 0; // 最大长度（也是当前最长的子序列长度）  </span><br><span class="line">q[0] = -2e9;  </span><br><span class="line"></span><br><span class="line">for(int i = 0; i &lt; n; i ++)  </span><br><span class="line">&#123;  </span><br><span class="line">    int l = 0, r = len;  </span><br><span class="line">    while(l &lt; r)  </span><br><span class="line">    &#123;  </span><br><span class="line">        int mid = l + r + 1&gt;&gt; 1;  </span><br><span class="line">        if(q[mid] &lt; a[i]) l = mid;  </span><br><span class="line">        else r = mid - 1;  </span><br><span class="line">    &#125;  </span><br><span class="line">    len = max(len, r + 1);  </span><br><span class="line">    q[r + 1] = a[i];  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">cout &lt;&lt; len;  </span><br><span class="line"></span><br><span class="line">return 0;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="9-最长公共子序列"><a href="#9-最长公共子序列" class="headerlink" title="9.最长公共子序列"></a>9.最长公共子序列</h3><p>f[i] [j]表示所有a[1….i]和b[1….i]中公共子序列的集合的最大值</p>
<p>那么可以分为包含a[i]不包含b[j]包含a[i]包含b[j]等等四个</p>
<p>四个发现可以整合成三个</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/899/">897. 最长公共子序列 - AcWing题库</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;  </span><br><span class="line"></span><br><span class="line">using namespace std;  </span><br><span class="line"></span><br><span class="line">const int N = 1010;  </span><br><span class="line"></span><br><span class="line">int n, m;  </span><br><span class="line">char a[N], b[N];  </span><br><span class="line">int f[N][N];  </span><br><span class="line"></span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; a + 1 &gt;&gt; b + 1;  </span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">for(int i = 1; i &lt;= n; i ++)  </span><br><span class="line">    for(int j = 1; j &lt;= m; j ++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        f[i][j] = max(f[i - 1][j], f[i][j - 1]);  </span><br><span class="line">        if(a[i] == b[j]) f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">cout &lt;&lt; f[n][m];  </span><br><span class="line"></span><br><span class="line">return 0;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="10-最短编辑距离"><a href="#10-最短编辑距离" class="headerlink" title="10.最短编辑距离"></a>10.最短编辑距离</h3><p>f[i] [j]表示将a[i…i]变成b[1…j]的所有方式的最小值</p>
<p>根据题意分三步</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/904/">902. 最短编辑距离 - AcWing题库</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;  </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;  </span><br><span class="line"><span class="type">char</span> a[N], b[N];  </span><br><span class="line"><span class="type">int</span> f[N][N];  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; a + <span class="number">1</span>;  </span><br><span class="line">    cin &gt;&gt; m &gt;&gt; b + <span class="number">1</span>;  </span><br><span class="line">      </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i ++) f[<span class="number">0</span>][i] = i;  </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) f[i][<span class="number">0</span>] = i;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        f[i][j] = <span class="built_in">min</span>(f[i - <span class="number">1</span>][j] + <span class="number">1</span>, f[i][j - <span class="number">1</span>] + <span class="number">1</span>);  </span><br><span class="line">        <span class="keyword">if</span>(a[i] == b[j]) f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>]);  </span><br><span class="line">        <span class="keyword">else</span> f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">cout &lt;&lt; f[n][m];  </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h2><h3 id="11-石子合并"><a href="#11-石子合并" class="headerlink" title="11.石子合并"></a>11.石子合并</h3><p>f[i] [j]表示合并第i到j堆石子的代价最小值</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/284/">282. 石子合并 - AcWing题库</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">310</span>;  </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;  </span><br><span class="line"><span class="type">int</span> s[N];  </span><br><span class="line"><span class="type">int</span> f[N][N];  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">cin &gt;&gt; n;  </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i  = <span class="number">1</span>; i &lt;= n; i ++) cin &gt;&gt; s[i], s[i] += s[i - <span class="number">1</span>];  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len ++)  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i ++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="type">int</span> j = i + len - <span class="number">1</span>;  </span><br><span class="line">        f[i][j] = <span class="number">1e8</span>;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = i; k &lt; j; k ++)  </span><br><span class="line">            f[i][j] = <span class="built_in">min</span>(f[i][j], f[i][k] + f[k + <span class="number">1</span>][j] + s[j] - s[i - <span class="number">1</span>]);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">cout &lt;&lt; f[<span class="number">1</span>][n];  </span><br><span class="line">   </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="计数类DP"><a href="#计数类DP" class="headerlink" title="计数类DP"></a>计数类DP</h2><h3 id="12-整数划分"><a href="#12-整数划分" class="headerlink" title="12.整数划分"></a>12.整数划分</h3><p>可以发现他就是一个完全背包问题</p>
<p>f[i] [j]表示1…i中选总数恰好是j</p>
<p>而f[i] [j]恰好可以优化成跟f[i] [j - 1]有关</p>
<p>再进行优化</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/902/">900. 整数划分 - AcWing题库</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"></span><br><span class="line"> <span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;  </span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> n;  </span><br><span class="line"> <span class="type">int</span> f[N];  </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"> </span>&#123;  </span><br><span class="line">     cin &gt;&gt; n;  </span><br><span class="line">       </span><br><span class="line"></span><br><span class="line"> f[<span class="number">0</span>] = <span class="number">1</span>;  </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)  </span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt;= n; j ++)  </span><br><span class="line">         f[j] = (f[j]  +f[j - i]) % mod;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​       </span><br><span class="line">​     cout &lt;&lt; f[n];  </span><br><span class="line">​       </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h2 id="数位统计DP"><a href="#数位统计DP" class="headerlink" title="数位统计DP"></a>数位统计DP</h2><h3 id="13-计数问题"><a href="#13-计数问题" class="headerlink" title="13.计数问题"></a>13.计数问题</h3><p>分类讨论</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/340/">338. 计数问题 - AcWing题库</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;  </span><br><span class="line"> #include &lt;vector&gt;  </span><br><span class="line"></span><br><span class="line"> using namespace std;  </span><br><span class="line"></span><br><span class="line"> int get(vector&lt;int&gt; num, int l, int r) // num数组中r到l的数  </span><br><span class="line"> &#123;  </span><br><span class="line">     int res = 0;  </span><br><span class="line">     for(int i = l; i &gt;= r; i --)  </span><br><span class="line">         res = res * 10 + num[i];  </span><br><span class="line">     return res;  </span><br><span class="line"> &#125;  </span><br><span class="line"></span><br><span class="line"> int power10(int x) // 求10的x次方  </span><br><span class="line"> &#123;  </span><br><span class="line">     int res = 1;  </span><br><span class="line">     while(x --) res *= 10;  </span><br><span class="line">     return res;  </span><br><span class="line"> &#125;  </span><br><span class="line"></span><br><span class="line"> int count(int n, int x) // 表示前n个数中x在每一位出现的次数  </span><br><span class="line"> &#123;  </span><br><span class="line">     if(!n) return 0;  </span><br><span class="line">       </span><br><span class="line"></span><br><span class="line"> vector&lt;int&gt; num;  </span><br><span class="line"> while(n)  </span><br><span class="line"> &#123;  </span><br><span class="line">     num.push_back(n % 10);  </span><br><span class="line">     n /= 10;  </span><br><span class="line"> &#125;  </span><br><span class="line"></span><br><span class="line"> n = num.size();  </span><br><span class="line"></span><br><span class="line"> int res = 0;  </span><br><span class="line"> for(int i = n - 1 - !x; i &gt;= 0; i --)  </span><br><span class="line"> &#123;  </span><br><span class="line">     if(i &lt; n - 1)  </span><br><span class="line">     &#123;  </span><br><span class="line">         res += get(num, n - 1, i + 1) * power10(i);  </span><br><span class="line">         if(!x) res -= power10(i);  </span><br><span class="line">     &#125;  </span><br><span class="line">       </span><br><span class="line">      if(num[i] == x) res += get(num, i - 1, 0) + 1;  </span><br><span class="line">      else if(num[i] &gt; x) res += power10(i);  </span><br><span class="line"> &#125;  </span><br><span class="line"></span><br><span class="line"> return res;  </span><br><span class="line"></span><br><span class="line"> &#125;  </span><br><span class="line"></span><br><span class="line"> int main()  </span><br><span class="line"> &#123;  </span><br><span class="line">     int a, b;  </span><br><span class="line">     while(cin &gt;&gt; a &gt;&gt; b, a || b)  </span><br><span class="line">     &#123;  </span><br><span class="line">         if(a &gt; b) swap(a, b);  </span><br><span class="line">           </span><br><span class="line"></span><br><span class="line">​     for(int i = 0; i &lt; 10; i ++)  </span><br><span class="line">​         cout &lt;&lt; count(b, i) - count (a - 1, i) &lt;&lt; &#x27; &#x27;;  </span><br><span class="line">​     cout &lt;&lt; endl;  </span><br><span class="line"> &#125;  </span><br><span class="line"></span><br><span class="line"> return 0;  </span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h2 id="状态压缩DP"><a href="#状态压缩DP" class="headerlink" title="状态压缩DP"></a>状态压缩DP</h2><h3 id="14-蒙德里安的梦想"><a href="#14-蒙德里安的梦想" class="headerlink" title="14.蒙德里安的梦想"></a>14.蒙德里安的梦想</h3><h3 id="15-最短Hamilton路径"><a href="#15-最短Hamilton路径" class="headerlink" title="15.最短Hamilton路径"></a>15.最短Hamilton路径</h3><p>f[i] [j]表示经过了i里面的点现在在j点（i表示一个数组用二进制表示1为经过0表示不经过）</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/93/">91. 最短Hamilton路径 - AcWing题库</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;  </span><br><span class="line">#include &lt;cstring&gt;  </span><br><span class="line"></span><br><span class="line">using namespace std;  </span><br><span class="line"></span><br><span class="line">const int N = 20, M = 1 &lt;&lt; 20;  </span><br><span class="line"></span><br><span class="line">int n;  </span><br><span class="line">int f[M][N], weight[N][N];  </span><br><span class="line"></span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">    // 读入数据  </span><br><span class="line">    cin &gt;&gt; n;  </span><br><span class="line">    for(int i = 0; i &lt; n; i ++)  </span><br><span class="line">        for(int j = 0; j &lt; n; j ++)  </span><br><span class="line">            cin &gt;&gt; weight[i][j];  </span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">memset(f, 0x3f, sizeof f);  </span><br><span class="line">f[1][0] = 0;  </span><br><span class="line"></span><br><span class="line">for(int i = 0; i &lt; 1 &lt;&lt; n; i ++)  </span><br><span class="line">    for(int j = 0; j &lt; n; j ++)  </span><br><span class="line">        if(i &gt;&gt; j &amp; 1) // 判断j这个点是否经过  </span><br><span class="line">            for(int k = 0; k &lt; n; k ++) // DP  </span><br><span class="line">                if(i - (1 &lt;&lt; j) &gt;&gt; k &amp; 1) // 这里（1 &lt;&lt; j）没有也行主要是一个内在原理见上图  </span><br><span class="line">                    f[i][j] = min(f[i][j], f[i - (1 &lt;&lt; j)][k] + weight[k][j]);  </span><br><span class="line"></span><br><span class="line">cout &lt;&lt; f[(1 &lt;&lt; n) - 1][n - 1] &lt;&lt; endl;  </span><br><span class="line">return 0;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h2><h3 id="16-没有上司的舞会"><a href="#16-没有上司的舞会" class="headerlink" title="16.没有上司的舞会"></a>16.没有上司的舞会</h3><p>两个状态f[u] [0]表示从u为根的子树中选，不选u这个方案的值 f[u] [1]表示从u为根的子树中选，选择u这个点的方案</p>
<p>将两个取max则为答案</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/287/">285. 没有上司的舞会 - AcWing题库</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;  </span><br><span class="line"> #include &lt;cstring&gt;  </span><br><span class="line"></span><br><span class="line"> using namespace std;  </span><br><span class="line"></span><br><span class="line"> const int N = 6010;  </span><br><span class="line"></span><br><span class="line"> int n;  </span><br><span class="line"> int happy[N];  </span><br><span class="line"> int h[N], e[N], ne[N], idx;  </span><br><span class="line"> int f[N][2];  </span><br><span class="line"> bool has_father[N];  </span><br><span class="line"></span><br><span class="line"> void add(int a, int b)  </span><br><span class="line"> &#123;  </span><br><span class="line">     e[idx] = b, ne[idx] = h[a], h[a] = idx ++;   </span><br><span class="line"> &#125;  </span><br><span class="line"></span><br><span class="line"> void dfs(int u)  </span><br><span class="line"> &#123;  </span><br><span class="line">     f[u][1] = happy[u];  </span><br><span class="line">       </span><br><span class="line"></span><br><span class="line"> for(int i = h[u]; i != -1; i = ne[i])  </span><br><span class="line"> &#123;  </span><br><span class="line">     int j = e[i];  </span><br><span class="line">     dfs(j);  </span><br><span class="line">       </span><br><span class="line">     f[u][0] += max(f[j][0], f[j][1]);  </span><br><span class="line">     f[u][1] += f[j][0];  </span><br><span class="line"> &#125;  </span><br><span class="line"></span><br><span class="line"> &#125;  </span><br><span class="line"></span><br><span class="line"> int main()  </span><br><span class="line"> &#123;  </span><br><span class="line">     cin &gt;&gt; n;  </span><br><span class="line">     for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; happy[i];  </span><br><span class="line">       </span><br><span class="line"></span><br><span class="line"> memset(h, -1, sizeof h);  </span><br><span class="line"> for(int i = 0; i &lt; n - 1; i ++)  </span><br><span class="line"> &#123;  </span><br><span class="line">     int a, b;  </span><br><span class="line">     cin &gt;&gt; a &gt;&gt; b;  </span><br><span class="line">     has_father[a] = true;  </span><br><span class="line">     add(b, a);  </span><br><span class="line"> &#125;  </span><br><span class="line"></span><br><span class="line"> int root = 1;  </span><br><span class="line"> while(has_father[root]) root ++;  </span><br><span class="line"></span><br><span class="line"> dfs(root);  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​       </span><br><span class="line">​     cout &lt;&lt;  max(f[root][0], f[root][1]);  </span><br><span class="line">​       </span><br><span class="line"></span><br><span class="line"> return 0;  </span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><h3 id="17-滑雪"><a href="#17-滑雪" class="headerlink" title="17.滑雪"></a>17.滑雪</h3><p>f[i] [j] 表示从当前位置滑经过路径的最大值</p>
<p>显然f[i] [j] 等于下一个路径的f值加一</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/903/">901. 滑雪 - AcWing题库</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;  </span><br><span class="line">#include &lt;cstring&gt;  </span><br><span class="line"></span><br><span class="line">using namespace std;  </span><br><span class="line"></span><br><span class="line">const int N = 310;  </span><br><span class="line"></span><br><span class="line">int n, m;  </span><br><span class="line">int h[N][N];  </span><br><span class="line">int f[N][N];  </span><br><span class="line"></span><br><span class="line">int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;;  </span><br><span class="line"></span><br><span class="line">int dp(int x, int y)  </span><br><span class="line">&#123;  </span><br><span class="line">    int &amp;v = f[x][y];  </span><br><span class="line">    if(v != -1) return v;  </span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">v = 1;  </span><br><span class="line">for(int i = 0; i &lt; 4; i ++)  </span><br><span class="line">&#123;  </span><br><span class="line">    int a = x + dx[i], b = y + dy[i];  </span><br><span class="line">    if(a &gt;= 1 &amp;&amp; a &lt;= n &amp;&amp; b &gt;= 1 &amp;&amp; b &lt;= m &amp;&amp; h[a][b] &lt; h[x][y])  </span><br><span class="line">        v = max(v, dp(a, b) + 1);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">return v;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;  </span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">for(int i = 1; i &lt;= n; i ++)  </span><br><span class="line">    for(int j = 1; j &lt;= m; j ++)  </span><br><span class="line">        cin &gt;&gt; h[i][j];  </span><br><span class="line"></span><br><span class="line">memset(f, -1, sizeof f);  </span><br><span class="line"></span><br><span class="line">int res = 0;  </span><br><span class="line">for(int i = 1; i &lt;= n; i ++)  </span><br><span class="line">    for(int j = 1; j &lt;= m; j ++)  </span><br><span class="line">        res = max(res, dp(i, j));  </span><br><span class="line">          </span><br><span class="line">cout &lt;&lt; res;  </span><br><span class="line"></span><br><span class="line">return 0;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="第六章贪心"><a href="#第六章贪心" class="headerlink" title="第六章贪心"></a>第六章贪心</h1><h2 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h2><h3 id="1-区间选点"><a href="#1-区间选点" class="headerlink" title="1.区间选点"></a>1.区间选点</h3><p>主要思路：</p>
<p>1.是将每个区间按右端点排序</p>
<p>2.枚举每个区间若当前区间已包含点则下一个 若没有则右端点为一个点</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/907/">905. 区间选点 - AcWing题库</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;  </span><br><span class="line">#include &lt;algorithm&gt;  </span><br><span class="line"></span><br><span class="line">using namespace std;  </span><br><span class="line"></span><br><span class="line">const int N = 100010;  </span><br><span class="line"></span><br><span class="line">int n;  </span><br><span class="line">struct Range  </span><br><span class="line">&#123;  </span><br><span class="line">    int l, r;  </span><br><span class="line">    bool operator&lt; (const Range &amp;W)const  </span><br><span class="line">    &#123;  </span><br><span class="line">        return r &lt; W.r;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;range[N];  </span><br><span class="line"></span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">cin &gt;&gt; n;  </span><br><span class="line">for(int i = 0; i &lt; n; i ++)  </span><br><span class="line">&#123;  </span><br><span class="line">    int l, r;  </span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r;  </span><br><span class="line">    range[i] = &#123;l, r&#125;;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">sort(range, range + n);  </span><br><span class="line"></span><br><span class="line">int res = 0, ed = -2e9;  </span><br><span class="line">for(int i = 0; i &lt; n; i ++)  </span><br><span class="line">    if(range[i].l &gt; ed)  </span><br><span class="line">    &#123;  </span><br><span class="line">        res ++;  </span><br><span class="line">        ed = range[i].r;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">cout &lt;&lt; res;  </span><br><span class="line"></span><br><span class="line">return 0;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-区间分组"><a href="#2-区间分组" class="headerlink" title="2.区间分组"></a>2.区间分组</h3><p>将区间按左端点排序</p>
<p>如果当前区间的左端点大于已有组区间的右端点则放在组里</p>
<p>否则开个新组</p>
<p>因此当前区间的左端点拿去跟组里面的最小右端点比就行了</p>
<p>所以就可以用小根堆</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/908/">906. 区间分组 - AcWing题库</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;  </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;  </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> l, r;  </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Range &amp;W)<span class="type">const</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">return</span> l &lt; W.l;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;range[N];  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    cin &gt;&gt; n;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="type">int</span> l, r;  </span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;  </span><br><span class="line">        range[i] = &#123;l, r&#125;;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(range, range + n);  </span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; heap;  </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">auto</span> r = range[i];  </span><br><span class="line">    <span class="keyword">if</span>(heap.<span class="built_in">empty</span>() || heap.<span class="built_in">top</span>() &gt;= r.l) heap.<span class="built_in">push</span>(r. r);  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="type">int</span> t = heap.<span class="built_in">top</span>();  </span><br><span class="line">        heap.<span class="built_in">pop</span>();  </span><br><span class="line">        heap.<span class="built_in">push</span>(r.r);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">cout &lt;&lt; heap.<span class="built_in">size</span>();  </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-区间覆盖"><a href="#3-区间覆盖" class="headerlink" title="3.区间覆盖"></a>3.区间覆盖</h3><p>1.将左端点进行排序</p>
<p>2.找到覆盖线段左端点最长的区间</p>
<p>3.将区间右端点变成一个新的线段左端点重复上面第二步</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/909/">907. 区间覆盖 - AcWing题库</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;  </span><br><span class="line">#include &lt;algorithm&gt;  </span><br><span class="line"></span><br><span class="line">using namespace std;  </span><br><span class="line"></span><br><span class="line">const int N = 100010;  </span><br><span class="line"></span><br><span class="line">int n;  </span><br><span class="line">struct Range  </span><br><span class="line">&#123;  </span><br><span class="line">    int l, r;  </span><br><span class="line">    bool operator&lt; (const Range &amp;W)const  </span><br><span class="line">    &#123;  </span><br><span class="line">        return l &lt; W.l;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;range[N];  </span><br><span class="line"></span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">    int st, ed;  </span><br><span class="line">    cin &gt;&gt; st &gt;&gt; ed;  </span><br><span class="line"></span><br><span class="line">cin &gt;&gt; n;  </span><br><span class="line">for(int i = 0; i &lt; n; i ++)  </span><br><span class="line">&#123;  </span><br><span class="line">    int l, r;  </span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r;  </span><br><span class="line">    range[i] = &#123;l, r&#125;;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">sort(range, range + n);  </span><br><span class="line"></span><br><span class="line">int res = 0;  </span><br><span class="line">bool success = false;  </span><br><span class="line">for(int i = 0; i &lt; n; i ++)  </span><br><span class="line">&#123;  </span><br><span class="line">    int j = i, r = -2e9;  </span><br><span class="line">    while(j &lt; n &amp;&amp; range[j].l &lt;= st)  </span><br><span class="line">    &#123;  </span><br><span class="line">        r = max(r, range[j].r);  </span><br><span class="line">        j ++;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    if(r &lt; st)  </span><br><span class="line">    &#123;  </span><br><span class="line">        res = -1;  </span><br><span class="line">        break;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    res ++;  </span><br><span class="line">    if(r &gt;= ed)  </span><br><span class="line">    &#123;  </span><br><span class="line">        success = true;  </span><br><span class="line">        break;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    st = r;  </span><br><span class="line">    i = j - 1;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">if(!success)res = -1;  </span><br><span class="line">cout &lt;&lt; res;  </span><br><span class="line"></span><br><span class="line">return 0;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Huffman树"><a href="#Huffman树" class="headerlink" title="Huffman树"></a>Huffman树</h2><h3 id="4-合并果子"><a href="#4-合并果子" class="headerlink" title="4.合并果子"></a>4.合并果子</h3><p>每次合并最小的果子</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/150/">148. 合并果子 - AcWing题库</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="type">int</span> n;  </span><br><span class="line">      </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cin &gt;&gt; n;  </span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; heap;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> x;  </span><br><span class="line">    cin &gt;&gt; x;  </span><br><span class="line">    heap.<span class="built_in">push</span>(x);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">while</span>(heap.<span class="built_in">size</span>() &gt; <span class="number">1</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> a = heap.<span class="built_in">top</span>(); heap.<span class="built_in">pop</span>();  </span><br><span class="line">    <span class="type">int</span> b = heap.<span class="built_in">top</span>(); heap.<span class="built_in">pop</span>();  </span><br><span class="line">    res += a + b;  </span><br><span class="line">    heap.<span class="built_in">push</span>(a + b);  </span><br><span class="line">&#125;  </span><br><span class="line">cout &lt;&lt; res;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="排序不等式"><a href="#排序不等式" class="headerlink" title="排序不等式"></a>排序不等式</h2><h3 id="5-打水问题"><a href="#5-打水问题" class="headerlink" title="5.打水问题"></a>5.打水问题</h3><p>从小到大排序</p>
<p>让花费时间最少的先打</p>
<p>代码就不写了</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/915/">913. 排队打水 - AcWing题库</a></p>
<h2 id="绝对值不等式"><a href="#绝对值不等式" class="headerlink" title="绝对值不等式"></a>绝对值不等式</h2><h3 id="6-货仓选址"><a href="#6-货仓选址" class="headerlink" title="6.货仓选址"></a>6.货仓选址</h3><p>就选中间就行了</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/106/">104. 货仓选址 - AcWing题库</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"></span><br><span class="line"> <span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;  </span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> n;  </span><br><span class="line"> <span class="type">int</span> a[N];  </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"> </span>&#123;  </span><br><span class="line">     cin &gt;&gt; n;  </span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) cin &gt;&gt; a[i];  </span><br><span class="line"></span><br><span class="line">​       </span><br><span class="line"></span><br><span class="line"> <span class="built_in">sort</span>(a, a + n);  </span><br><span class="line"> <span class="type">int</span> res = <span class="number">0</span>;  </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) res += <span class="built_in">abs</span>(a[i] - a[n / <span class="number">2</span>]);  </span><br><span class="line"> cout &lt;&lt; res;  </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h2 id="推公式"><a href="#推公式" class="headerlink" title="推公式"></a>推公式</h2><h3 id="7-耍杂技的牛"><a href="#7-耍杂技的牛" class="headerlink" title="7.耍杂技的牛"></a>7.耍杂技的牛</h3><p>我们先随便排序</p>
<p>发现将第i个和第i + 1 个交换后 如果Wi + Si &gt; Wi+1 + Si+1那么就会使这两个交换后风险值变小</p>
<p>由局部推导全局</p>
<p>则这个顺序是升序的</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/127/">125. 耍杂技的牛 - AcWing题库</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;  </span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50010</span>;  </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;  </span><br><span class="line">PII cows[N];  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    cin &gt;&gt; n;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="type">int</span> w, s;  </span><br><span class="line">        cin &gt;&gt; w &gt;&gt; s;  </span><br><span class="line">        cows[i] = &#123;w + s, w&#125;;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(cows, cows + n);  </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>, res = INT_MIN;  </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> w = cows[i].second, s = cows[i].first - w;  </span><br><span class="line">    res = <span class="built_in">max</span>(res, sum - s);  </span><br><span class="line">    sum += w;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">cout &lt;&lt; res;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">NJY</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/06/23/%E6%9C%AA%E5%91%BD%E5%90%8D%201/%E7%AE%97%E6%B3%95/">http://example.com/2025/06/23/%E6%9C%AA%E5%91%BD%E5%90%8D%201/%E7%AE%97%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">NJYgocrazy</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/cpp/">cpp</a></div><div class="post-share"><div class="social-share" data-image="https://s21.ax1x.com/2025/06/23/pVZxcaF.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/06/23/%E6%9C%AA%E5%91%BD%E5%90%8D%201/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0/" title="刷题小记--从下笔到遗忘"><img class="cover" src="https://s21.ax1x.com/2025/06/23/pVZxHaD.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">刷题小记--从下笔到遗忘</div></div><div class="info-2"><div class="info-item-1">刷题吗？我只看到一个绝望的算法最菜之人</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/06/23/%E6%9C%AA%E5%91%BD%E5%90%8D%201/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0/" title="刷题小记--从下笔到遗忘"><img class="cover" src="https://s21.ax1x.com/2025/06/23/pVZxHaD.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-23</div><div class="info-item-2">刷题小记--从下笔到遗忘</div></div><div class="info-2"><div class="info-item-1">刷题吗？我只看到一个绝望的算法最菜之人</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/ava.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">NJY</div><div class="author-info-description">LEC SWPU 前端</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">第一章基础算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9"><span class="toc-number">1.2.1.</span> <span class="toc-text">快速排序与快速选择</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%A1%AE%E5%AE%9A%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E5%86%85%E7%9A%84%E5%80%BC%E7%94%A8%E6%9D%A5%E5%88%92%E5%88%86%E6%95%B0%E7%BB%84"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">1.确定一个数组内的值用来划分数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AF%B9%E4%BA%8E%E5%8E%9F%E6%95%B0%E7%BB%84%E8%BF%9B%E8%A1%8C%E5%88%92%E5%88%86%E3%80%82"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">2.对于原数组进行划分。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AF%B9%E5%88%86%E5%87%BA%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%8C%BA%E5%9F%9F%E8%BF%9B%E8%A1%8C%E9%80%92%E5%BD%92%E5%A4%84%E7%90%86"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">3.对分出的两个区域进行递归处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">4.快速选择</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">1. 基本步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E4%B8%AD%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2.归并排序中求逆序对</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86"><span class="toc-number">1.2.3.</span> <span class="toc-text">整数二分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">1.整数二分</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF1"><span class="toc-number">1.2.3.1.1.</span> <span class="toc-text">模板1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF2"><span class="toc-number">1.2.3.1.2.</span> <span class="toc-text">模板2</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B5%AE%E7%82%B9%E4%BA%8C%E5%88%86%EF%BC%9A"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">2.浮点二分：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">3.二分答案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6"><span class="toc-number">1.2.4.</span> <span class="toc-text">高精度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">1.高精度加法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">2.高精度减法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">3.高精度乘法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%A7%E6%95%B0%C3%97%E5%A4%A7%E6%95%B0%E7%9A%84%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95"><span class="toc-number">1.2.4.3.1.</span> <span class="toc-text">大数×大数的高精度乘法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%99%A4%E6%B3%95"><span class="toc-number">1.2.4.4.</span> <span class="toc-text">4.高精度除法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-number">1.2.5.</span> <span class="toc-text">前缀和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%80%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">1.一维前缀和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">2.二维前缀和</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%AE%E5%88%86"><span class="toc-number">1.2.6.</span> <span class="toc-text">差分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%80%E7%BB%B4%E5%B7%AE%E5%88%86"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">1.一维差分</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%AE%E5%88%86%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.2.6.1.1.</span> <span class="toc-text">差分的应用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">1.2.6.1.2.</span> <span class="toc-text">差分数组的构造</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">2.二维差分</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">1.2.6.2.1.</span> <span class="toc-text">应用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0"><span class="toc-number">1.2.6.2.2.</span> <span class="toc-text">构造</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A6%BB%E6%95%A3%E5%8C%96"><span class="toc-number">1.2.7.</span> <span class="toc-text">离散化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E5%92%8C"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">区间和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6"><span class="toc-number">1.2.7.2.</span> <span class="toc-text">区间合并</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text">第二章数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">1.4.</span> <span class="toc-text">栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%88"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%98%9F%E5%88%97"><span class="toc-number">1.4.2.</span> <span class="toc-text">2.队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E7%9A%84%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.3.</span> <span class="toc-text">3.使用场景的总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97"><span class="toc-number">1.4.4.</span> <span class="toc-text">4.单调栈和单调队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8D%95%E8%B0%83%E6%A0%88"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">1.单调栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">2.单调队列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Trie%E6%A0%91"><span class="toc-number">1.5.</span> <span class="toc-text">Trie树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">1.5.1.</span> <span class="toc-text">并查集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%8D%E7%B1%BB%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">1.5.2.</span> <span class="toc-text">种类并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E5%AF%B9%E5%85%B3%E7%B3%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">注意对关系之间的处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E6%9D%83%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">1.5.3.</span> <span class="toc-text">带权并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Q1-%E5%AE%9A%E4%B9%89"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">Q1 定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q3%E6%9D%83%E5%80%BC%E5%88%B0%E5%BA%95%E4%BB%A3%E8%A1%A8%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">Q3权值到底代表了什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q2%E6%9D%83%E5%80%BC%E7%9A%84%E8%BD%AC%E7%A7%BB"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">Q2权值的转移</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E8%A7%81%E6%B4%9B%E8%B0%B7P2024%E9%A3%9F%E7%89%A9%E9%93%BE"><span class="toc-number">1.5.3.4.</span> <span class="toc-text">详见洛谷P2024食物链</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">1.6.</span> <span class="toc-text">堆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A0%86%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.6.1.</span> <span class="toc-text">1.堆的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A0%B9%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">1.6.2.</span> <span class="toc-text">2.根的存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A0%86%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.6.3.</span> <span class="toc-text">3.堆的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A0%86%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%85%83%E7%B4%A0%E5%A4%84%E7%90%86"><span class="toc-number">1.6.4.</span> <span class="toc-text">4.堆中的一些元素处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E9%A1%B6%E5%A0%86"><span class="toc-number">1.6.5.</span> <span class="toc-text">对顶堆</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">1.7.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8"><span class="toc-number">1.7.1.</span> <span class="toc-text">链表的主要作用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8D%95%E9%93%BE%E8%A1%A8-%E9%82%BB%E6%8E%A5%E8%A1%A8-%E7%94%A8%E6%9D%A5%E5%82%A8%E5%AD%98%E6%A0%91%E5%92%8C%E5%9B%BE"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">1.单链表-&gt;邻接表-&gt;用来储存树和图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8F%8C%E9%93%BE%E8%A1%A8-%E7%94%A8%E6%9D%A5%E4%BC%98%E5%8C%96%E6%9F%90%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">2.双链表-&gt;用来优化某些问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="toc-number">1.7.2.</span> <span class="toc-text">用指针实现的链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">一，单向链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">1.初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.7.2.3.</span> <span class="toc-text">2.单向链表的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5"><span class="toc-number">1.7.2.4.</span> <span class="toc-text">3.单向链表的插入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">1.7.2.5.</span> <span class="toc-text">4.单链表的删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9E%84%E5%BB%BA"><span class="toc-number">1.7.2.6.</span> <span class="toc-text">5.链表的构建</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8C%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">1.7.3.</span> <span class="toc-text">二，双向链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9D%E5%A7%8B%E5%8C%96-1"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">1.初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%9C%A8p%E8%8A%82%E7%82%B9%E5%90%8E%E6%8F%92%E5%85%A5now%E8%8A%82%E7%82%B9"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">2.在p节点后插入now节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AAnow%E8%8A%82%E7%82%B9"><span class="toc-number">1.7.3.3.</span> <span class="toc-text">3.删除一个now节点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%EF%BC%8C%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">1.7.4.</span> <span class="toc-text">三，循环链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="toc-number">1.7.5.</span> <span class="toc-text">用数组模拟实现的链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8-1"><span class="toc-number">1.7.5.1.</span> <span class="toc-text">一，单向链表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%A8%A1%E6%8B%9F%E6%96%B9%E5%BC%8F"><span class="toc-number">1.7.5.1.1.</span> <span class="toc-text">1.模拟方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.7.5.1.2.</span> <span class="toc-text">2.初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">1.7.5.1.3.</span> <span class="toc-text">3.插入操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">1.7.5.1.4.</span> <span class="toc-text">4.删除操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8C%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8-1"><span class="toc-number">1.7.5.2.</span> <span class="toc-text">二，双向链表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%A8%A1%E6%8B%9F%E6%96%B9%E5%BC%8F-1"><span class="toc-number">1.7.5.2.1.</span> <span class="toc-text">1.模拟方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%88%9D%E5%A7%8B%E5%8C%96-1"><span class="toc-number">1.7.5.2.2.</span> <span class="toc-text">2.初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C-1"><span class="toc-number">1.7.5.2.3.</span> <span class="toc-text">3.插入操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C-1"><span class="toc-number">1.7.5.2.4.</span> <span class="toc-text">4.删除操作</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C"><span class="toc-number">1.8.</span> <span class="toc-text">哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.8.1.</span> <span class="toc-text">1.简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%80%BC%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">1.8.2.</span> <span class="toc-text">2.值冲突解决方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Plan-A-%E8%B7%B3%E8%BF%87%E6%B3%95"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">Plan A 跳过法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Plan-B-%E5%AE%B9%E5%99%A8%E6%B3%95"><span class="toc-number">1.8.2.2.</span> <span class="toc-text">Plan B  容器法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.8.3.</span> <span class="toc-text">3.哈希函数的设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C"><span class="toc-number">1.8.4.</span> <span class="toc-text">4.字符串哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%94%A8%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B0%E5%AD%97"><span class="toc-number">1.8.4.1.</span> <span class="toc-text">1.用哈希函数将字符串转化为数字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%87%BD%E6%95%B0%E7%9A%84%E8%A7%A3%E9%87%8A"><span class="toc-number">1.8.4.2.</span> <span class="toc-text">2.函数的解释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%B1%82%E4%BB%BB%E6%84%8F%E7%89%87%E6%AE%B5%E5%AD%90%E4%B8%B2%E7%9A%84%E5%93%88%E5%B8%8C%E5%80%BC"><span class="toc-number">1.8.4.3.</span> <span class="toc-text">3.求任意片段子串的哈希值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-stl%E5%BA%93%E4%B8%AD%E7%9A%84hash"><span class="toc-number">1.8.5.</span> <span class="toc-text">5.stl库中的hash</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stl%E5%BA%93%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.9.</span> <span class="toc-text">stl库中的数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA"><span class="toc-number">1.10.</span> <span class="toc-text">第三章搜索与图论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E5%92%8C%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%EF%BC%88%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%89"><span class="toc-number">1.11.</span> <span class="toc-text">树和图的存储（邻接表）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-DFS"><span class="toc-number">1.12.</span> <span class="toc-text">1.DFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-BFS"><span class="toc-number">1.13.</span> <span class="toc-text">2.BFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">1.14.</span> <span class="toc-text">3.拓扑排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="toc-number">1.15.</span> <span class="toc-text">最短路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%88%9A4-Dijkstra"><span class="toc-number">1.15.1.</span> <span class="toc-text">√4.Dijkstra</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%88%9A5-bellman-ford"><span class="toc-number">1.15.2.</span> <span class="toc-text">√5.bellman-ford</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-spfa"><span class="toc-number">1.15.3.</span> <span class="toc-text">6.spfa</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="toc-number">1.15.3.1.</span> <span class="toc-text">判断最短路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#spfa%E5%88%A4%E6%96%AD%E8%B4%9F%E7%8E%AF"><span class="toc-number">1.15.3.2.</span> <span class="toc-text">spfa判断负环</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%88%9A7-Floyd"><span class="toc-number">1.15.4.</span> <span class="toc-text">√7.Floyd</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">1.16.</span> <span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-Prim"><span class="toc-number">1.16.1.</span> <span class="toc-text">8.Prim</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%88%9A9-Kruskal"><span class="toc-number">1.16.2.</span> <span class="toc-text">√9.Kruskal</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="toc-number">1.17.</span> <span class="toc-text">二分图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E6%9F%93%E8%89%B2%E6%B3%95%E5%88%A4%E5%AE%9A%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="toc-number">1.17.1.</span> <span class="toc-text">10.染色法判定二分图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95"><span class="toc-number">1.17.2.</span> <span class="toc-text">11.匈牙利算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86"><span class="toc-number">1.18.</span> <span class="toc-text">第四章数学知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%B4%A8%E6%95%B0"><span class="toc-number">1.19.</span> <span class="toc-text">1.质数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E8%AF%95%E9%99%A4%E6%B3%95%E5%88%A4%E6%96%AD%E8%B4%A8%E6%95%B0"><span class="toc-number">1.19.1.</span> <span class="toc-text">①试除法判断质数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E8%AF%95%E9%99%A4%E6%B3%95%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0"><span class="toc-number">1.19.2.</span> <span class="toc-text">②试除法分解质因数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%E7%AD%9B%E8%B4%A8%E6%95%B0"><span class="toc-number">1.19.3.</span> <span class="toc-text">③筛质数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BA%A6%E6%95%B0"><span class="toc-number">1.20.</span> <span class="toc-text">2.约数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E8%AF%95%E9%99%A4%E6%B3%95%E6%B1%82%E7%BA%A6%E6%95%B0"><span class="toc-number">1.20.1.</span> <span class="toc-text">①试除法求约数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E6%B1%82%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0"><span class="toc-number">1.20.2.</span> <span class="toc-text">②求约数个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%E6%B1%82%E7%BA%A6%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">1.20.3.</span> <span class="toc-text">③求约数之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0"><span class="toc-number">1.20.4.</span> <span class="toc-text">③最大公约数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95"><span class="toc-number">1.20.5.</span> <span class="toc-text">④扩展欧几里得算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0"><span class="toc-number">1.21.</span> <span class="toc-text">3.欧拉函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.21.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E6%B3%95"><span class="toc-number">1.21.2.</span> <span class="toc-text">求法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%85%AC%E5%BC%8F%E6%B1%82%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0"><span class="toc-number">1.21.2.1.</span> <span class="toc-text">1、公式求欧拉函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E7%AD%9B%E6%B3%95%E6%B1%82%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0"><span class="toc-number">1.21.2.2.</span> <span class="toc-text">2、筛法求欧拉函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="toc-number">1.22.</span> <span class="toc-text">4.快速幂</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82%E6%B1%82%E9%80%86%E5%85%83"><span class="toc-number">1.22.1.</span> <span class="toc-text">快速幂求逆元</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E6%B1%82%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84"><span class="toc-number">1.23.</span> <span class="toc-text">5.高斯消元求线性方程组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">1.24.</span> <span class="toc-text">第五章动态规划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%88%9A%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.25.</span> <span class="toc-text">√背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.25.1.</span> <span class="toc-text">1.01背包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.25.2.</span> <span class="toc-text">2.完全背包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%88%E6%95%B0%E6%8D%AE%E5%B0%8F%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%89"><span class="toc-number">1.25.3.</span> <span class="toc-text">3.多重背包问题（数据小的时候）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%88%E6%95%B0%E6%8D%AE%E5%A4%A7%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%89"><span class="toc-number">1.25.4.</span> <span class="toc-text">4.多重背包问题（数据大的时候）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.25.5.</span> <span class="toc-text">5.分组背包问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7DP"><span class="toc-number">1.26.</span> <span class="toc-text">线性DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%88%9A6-%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="toc-number">1.26.1.</span> <span class="toc-text">√6.数字三角形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%88%9A7-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88%E6%95%B0%E6%8D%AE%E5%B0%8F%E6%97%B6%EF%BC%89"><span class="toc-number">1.26.2.</span> <span class="toc-text">√7.最长上升子序列（数据小时）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%88%9A8-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88%E6%95%B0%E6%8D%AE%E5%A4%A7%E6%97%B6%EF%BC%89"><span class="toc-number">1.26.3.</span> <span class="toc-text">√8.最长上升子序列（数据大时）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">1.26.4.</span> <span class="toc-text">9.最长公共子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="toc-number">1.26.5.</span> <span class="toc-text">10.最短编辑距离</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4DP"><span class="toc-number">1.27.</span> <span class="toc-text">区间DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6"><span class="toc-number">1.27.1.</span> <span class="toc-text">11.石子合并</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E7%B1%BBDP"><span class="toc-number">1.28.</span> <span class="toc-text">计数类DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86"><span class="toc-number">1.28.1.</span> <span class="toc-text">12.整数划分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E4%BD%8D%E7%BB%9F%E8%AE%A1DP"><span class="toc-number">1.29.</span> <span class="toc-text">数位统计DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98"><span class="toc-number">1.29.1.</span> <span class="toc-text">13.计数问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP"><span class="toc-number">1.30.</span> <span class="toc-text">状态压缩DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E8%92%99%E5%BE%B7%E9%87%8C%E5%AE%89%E7%9A%84%E6%A2%A6%E6%83%B3"><span class="toc-number">1.30.1.</span> <span class="toc-text">14.蒙德里安的梦想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E6%9C%80%E7%9F%ADHamilton%E8%B7%AF%E5%BE%84"><span class="toc-number">1.30.2.</span> <span class="toc-text">15.最短Hamilton路径</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E5%BD%A2DP"><span class="toc-number">1.31.</span> <span class="toc-text">树形DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E6%B2%A1%E6%9C%89%E4%B8%8A%E5%8F%B8%E7%9A%84%E8%88%9E%E4%BC%9A"><span class="toc-number">1.31.1.</span> <span class="toc-text">16.没有上司的舞会</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2"><span class="toc-number">1.32.</span> <span class="toc-text">记忆化搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E6%BB%91%E9%9B%AA"><span class="toc-number">1.32.1.</span> <span class="toc-text">17.滑雪</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%B4%AA%E5%BF%83"><span class="toc-number">2.</span> <span class="toc-text">第六章贪心</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.</span> <span class="toc-text">区间问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8C%BA%E9%97%B4%E9%80%89%E7%82%B9"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.区间选点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8C%BA%E9%97%B4%E5%88%86%E7%BB%84"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.区间分组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8C%BA%E9%97%B4%E8%A6%86%E7%9B%96"><span class="toc-number">2.1.3.</span> <span class="toc-text">3.区间覆盖</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Huffman%E6%A0%91"><span class="toc-number">2.2.</span> <span class="toc-text">Huffman树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%90%88%E5%B9%B6%E6%9E%9C%E5%AD%90"><span class="toc-number">2.2.1.</span> <span class="toc-text">4.合并果子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E4%B8%8D%E7%AD%89%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">排序不等式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%89%93%E6%B0%B4%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.1.</span> <span class="toc-text">5.打水问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%9D%E5%AF%B9%E5%80%BC%E4%B8%8D%E7%AD%89%E5%BC%8F"><span class="toc-number">2.4.</span> <span class="toc-text">绝对值不等式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%B4%A7%E4%BB%93%E9%80%89%E5%9D%80"><span class="toc-number">2.4.1.</span> <span class="toc-text">6.货仓选址</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A8%E5%85%AC%E5%BC%8F"><span class="toc-number">2.5.</span> <span class="toc-text">推公式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%80%8D%E6%9D%82%E6%8A%80%E7%9A%84%E7%89%9B"><span class="toc-number">2.5.1.</span> <span class="toc-text">7.耍杂技的牛</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/06/23/%E6%9C%AA%E5%91%BD%E5%90%8D%201/%E5%88%9D%E9%9B%AA/" title="初雪"><img src="https://s21.ax1x.com/2025/04/29/pE7rah4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="初雪"/></a><div class="content"><a class="title" href="/2025/06/23/%E6%9C%AA%E5%91%BD%E5%90%8D%201/%E5%88%9D%E9%9B%AA/" title="初雪">初雪</a><time datetime="2025-06-23T14:34:49.296Z" title="发表于 2025-06-23 14:34:49">2025-06-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/23/%E6%9C%AA%E5%91%BD%E5%90%8D%201/%E6%A0%91/" title="树"><img src="https://s21.ax1x.com/2025/04/29/pE7rNAU.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="树"/></a><div class="content"><a class="title" href="/2025/06/23/%E6%9C%AA%E5%91%BD%E5%90%8D%201/%E6%A0%91/" title="树">树</a><time datetime="2025-06-23T14:34:49.296Z" title="发表于 2025-06-23 14:34:49">2025-06-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/23/%E6%9C%AA%E5%91%BD%E5%90%8D%201/%E7%AB%A5%E5%B9%B4%E5%9B%9E%E5%BF%86-%E7%B1%BB%E5%8A%A0%E9%80%9F%E7%90%83%E7%9A%84%E6%B0%B4%E7%90%83%E5%8A%A0%E8%BD%BD%E5%8A%A8%E7%94%BB/" title="实现一个小水球动画"><img src="https://s21.ax1x.com/2025/06/23/pVe9FiD.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="实现一个小水球动画"/></a><div class="content"><a class="title" href="/2025/06/23/%E6%9C%AA%E5%91%BD%E5%90%8D%201/%E7%AB%A5%E5%B9%B4%E5%9B%9E%E5%BF%86-%E7%B1%BB%E5%8A%A0%E9%80%9F%E7%90%83%E7%9A%84%E6%B0%B4%E7%90%83%E5%8A%A0%E8%BD%BD%E5%8A%A8%E7%94%BB/" title="实现一个小水球动画">实现一个小水球动画</a><time datetime="2025-06-23T14:34:49.296Z" title="发表于 2025-06-23 14:34:49">2025-06-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/23/%E6%9C%AA%E5%91%BD%E5%90%8D%201/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0/" title="刷题小记--从下笔到遗忘"><img src="https://s21.ax1x.com/2025/06/23/pVZxHaD.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="刷题小记--从下笔到遗忘"/></a><div class="content"><a class="title" href="/2025/06/23/%E6%9C%AA%E5%91%BD%E5%90%8D%201/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932.0/" title="刷题小记--从下笔到遗忘">刷题小记--从下笔到遗忘</a><time datetime="2025-06-23T14:34:49.296Z" title="发表于 2025-06-23 14:34:49">2025-06-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/23/%E6%9C%AA%E5%91%BD%E5%90%8D%201/%E7%AE%97%E6%B3%95/" title="算法--从入门到出门"><img src="https://s21.ax1x.com/2025/06/23/pVZxcaF.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法--从入门到出门"/></a><div class="content"><a class="title" href="/2025/06/23/%E6%9C%AA%E5%91%BD%E5%90%8D%201/%E7%AE%97%E6%B3%95/" title="算法--从入门到出门">算法--从入门到出门</a><time datetime="2025-06-23T14:34:49.296Z" title="发表于 2025-06-23 14:34:49">2025-06-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By NJY</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script> $(".category-list-count").prepend("<i class=\"fas fa-book\"></i>");</script><script> $(".category-list-item").eq(0).insertAfter($(".gallery-group-name").eq(0))</script><script> $(".category-list-item").eq(1).insertAfter($(".gallery-group-name").eq(1))</script><script> $(".category-list-item").eq(2).insertAfter($(".gallery-group-name").eq(2))</script><script> $(".category-list-item").eq(3).insertAfter($(".gallery-group-name").eq(3))</script><script> $(".category-list-item").eq(4).insertAfter($(".gallery-group-name").eq(4))</script><script> $(".category-list-item").eq(5).insertAfter($(".gallery-group-name").eq(5))</script><script> $(".category-list-item a").hide();</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="N,LOVE,T" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://s21.ax1x.com/2025/06/23/pVe9ueP.png);"> <a class="categoryBar-list-link" href="categories/前端/">前端</a><span class="categoryBar-list-count">4</span><span class="categoryBar-list-descr">前端成长历程</span></li><li class="categoryBar-list-item" style="background:url(https://s21.ax1x.com/2025/06/23/pVe9Tld.jpg);"> <a class="categoryBar-list-link" href="categories/苦吟/">苦吟</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">苦吟的文学世界</span></li><li class="categoryBar-list-item" style="background:url(https://s21.ax1x.com/2025/06/23/pVe9L0P.png);"> <a class="categoryBar-list-link" href="categories/算法/">算法</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">算法</span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><!-- hexo injector body_end end --></body></html>